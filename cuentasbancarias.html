<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sistema de Consignaciones - Blindado y Final</title>

  <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js">// ===== NUEVA LÃ“GICA PARA TOTALES VERDES =====
async function nuevaLogicaTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('âŒ No hay cuenta seleccionada');
    return;
  }
  
  console.log('ðŸ”„ NUEVA LÃ“GICA: Recalculando separadores verdes...');
  
  try {
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`ðŸ“Š Total items: ${allItems.length}`);
    
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`ðŸŸ¢ Separadores verdes: ${separadoresVerdes.length}`);
    
    if (separadoresVerdes.length === 0) return;
    
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`\nðŸŸ¢ Procesando: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      let ordenRojoAnterior = -Infinity;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) < ordenVerde) {
          ordenRojoAnterior = Math.max(ordenRojoAnterior, item.orden || 0);
        }
      }
      
      console.log(`ðŸ”´ Rojo anterior: ${ordenRojoAnterior === -Infinity ? 'NINGUNO' : ordenRojoAnterior}`);
      
      let total = 0;
      let conteo = 0;
      
      for (const item of allItems) {
        if (item.isSeparator) continue;
        if (item.verifiedRole !== 'Gerente') continue;
        
        const ordenItem = item.orden || 0;
        if (ordenItem > ordenRojoAnterior && ordenItem < ordenVerde) {
          total += Number(item.valor || 0);
          conteo++;
        }
      }
      
      console.log(`ðŸŸ¢ Total calculado: ${conteo} consignaciones = ${total}`);
      
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`âœ… Actualizando: ${separadorVerde.total} â†’ ${total}`);
      }
    }
    
    await batch.commit();
    console.log('âœ… RecÃ¡lculo completado');
    await loadConsignaciones();
    
  } catch (error) {
    console.error('âŒ Error:', error);
  }
}

async function probarNuevaLogicaCompleta() {
  console.log('ðŸ§ª PROBANDO NUEVA LÃ“GICA...');
  if (!selectedAccountId) {
    console.log('âŒ Selecciona una cuenta primero');
    return;
  }
  await nuevaLogicaTotalesVerdes();
  console.log('âœ… PRUEBA TERMINADA');
}

// Actualizar funciÃ³n existente para usar la nueva lÃ³gica
async function actualizarTotalesVerdes() {
  await nuevaLogicaTotalesVerdes();
}
// ===== LÃ“GICA CORREGIDA PARA TOTALES VERDES =====
async function logicaCorregidaTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('âŒ No hay cuenta seleccionada');
    return;
  }
  
  console.log('ðŸ”„ LÃ“GICA CORREGIDA: Recalculando separadores verdes...');
  
  try {
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`ðŸ“Š Total items: ${allItems.length}`);
    console.log('ðŸ“‹ Estructura de datos:');
    allItems.forEach((item, index) => {
      if (item.isSeparator) {
        console.log(`${index + 1}. ðŸ”´ðŸŸ¢ SEPARADOR ${item.type.toUpperCase()}: orden ${item.orden}, total: ${item.total || 0}`);
      } else {
        const estado = item.verifiedRole === 'Gerente' ? 'ðŸŸ¡ AMARILLO' : 
                     item.verifiedRole === 'Administrativo' ? 'âšª GRIS' : 'âš« BLANCO';
        console.log(`${index + 1}. ${estado}: ${item.valor}, ref: ${item.referencia}, orden: ${item.orden}`);
      }
    });
    
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`ðŸŸ¢ Separadores verdes: ${separadoresVerdes.length}`);
    
    if (separadoresVerdes.length === 0) return;
    
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`\nðŸŸ¢ Procesando: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      // LÃ“GICA CORREGIDA: Encontrar el separador rojo que estÃ¡ DESPUÃ‰S del verde
      let separadorRojoPosterior = null;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) > ordenVerde) {
          separadorRojoPosterior = item;
          break; // Tomar el primer rojo despuÃ©s del verde
        }
      }
      
      console.log(`ðŸ”´ Separador rojo posterior: ${separadorRojoPosterior ? 
        `${separadorRojoPosterior.id.substring(0, 8)}, orden: ${separadorRojoPosterior.orden}` : 'NINGUNO'}`);
      
      let total = 0;
      let conteo = 0;
      const consignacionesEncontradas = [];
      
      // LÃ“GICA CORREGIDA: Sumar consignaciones que estÃ¡n DESPUÃ‰S del rojo posterior
      for (const item of allItems) {
        if (item.isSeparator) continue;
        if (item.verifiedRole !== 'Gerente') continue;
        
        const ordenItem = item.orden || 0;
        let incluirConsignacion = false;
        
        if (separadorRojoPosterior) {
          // Hay rojo posterior: incluir consignaciones despuÃ©s del rojo
          incluirConsignacion = ordenItem > separadorRojoPosterior.orden;
          console.log(`  ðŸ” Evaluando consignaciÃ³n ${item.id.substring(0, 8)}: orden ${ordenItem} > ${separadorRojoPosterior.orden}? ${incluirConsignacion}`);
        } else {
          // No hay rojo posterior: incluir todas las consignaciones despuÃ©s del verde
          incluirConsignacion = ordenItem > ordenVerde;
          console.log(`  ðŸ” Evaluando consignaciÃ³n ${item.id.substring(0, 8)}: orden ${ordenItem} > ${ordenVerde}? ${incluirConsignacion}`);
        }
        
        if (incluirConsignacion) {
          total += Number(item.valor || 0);
          conteo++;
          consignacionesEncontradas.push({
            id: item.id.substring(0, 8),
            valor: item.valor,
            orden: ordenItem,
            referencia: item.referencia
          });
        }
      }
      
      console.log(`ðŸ“‹ Consignaciones encontradas:`, consignacionesEncontradas);
      console.log(`ðŸŸ¢ Total calculado: ${conteo} consignaciones = ${total}`);
      
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`âœ… Actualizando: ${separadorVerde.total} â†’ ${total}`);
      } else {
        console.log(`â„¹ï¸ Ya correcto: ${total}`);
      }
    }
    
    await batch.commit();
    console.log('âœ… RecÃ¡lculo completado');
    await loadConsignaciones();
    
  } catch (error) {
    console.error('âŒ Error:', error);
  }
}

async function probarLogicaCorregida() {
  console.log('ðŸ§ª PROBANDO LÃ“GICA CORREGIDA...');
  if (!selectedAccountId) {
    console.log('âŒ Selecciona una cuenta primero');
    return;
  }
  await logicaCorregidaTotalesVerdes();
  console.log('âœ… PRUEBA TERMINADA');
}
</script>

  <style>
    :root{
      --bg: linear-gradient(135deg, #a8e6cf 0%, #dcedc1 100%);
      --card: rgba(255, 255, 255, 0.95);
      --accent: #4CAF50;
      --accent-hover: #45a049;
      --muted: #555;
      --border: #e8f5e8;
      --danger: #f44336;
      --ok: #4CAF50;
      --admin-gray: #e5e7eb;
      --manager-yellow: rgba(255, 193, 7, 0.2);
      --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      --shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.15);
    }
    *{
      box-sizing:border-box;
      margin: 0;
      padding: 0;
    }
    
    body{
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin:0;
      background: var(--bg);
      color: #2e7d32;
    }
    
    #topbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:5px 10px;
      background: var(--card);
      backdrop-filter: blur(10px);
      border-bottom: 2px solid var(--border);
      box-shadow: var(--shadow);
      position: relative;
      z-index: 100;
    }
    
    .layout{
      display:flex;
      height:calc(100vh - 40px);
    }
    
    .sidebar{
      width:250px;
      padding:8px;
      background: var(--card);
      backdrop-filter: blur(10px);
      border-right: 2px solid var(--border);
      overflow:auto;
      box-shadow: var(--shadow);
    }
    
    .main{
      flex:1;
      padding:8px;
      overflow:auto;
    }
    h2,h3{
      margin:0 0 5px 0;
      color: #2e7d32;
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-size: 1em;
    }

    h3 {
      position: relative;
    }

    h3::after {
      content: '';
      position: absolute;
      bottom: -3px;
      left: 0;
      width: 30px;
      height: 2px;
      background: linear-gradient(90deg, var(--accent), #66BB6A);
      border-radius: 2px;
    }
    
    label{
      display:block;
      font-size:11px;
      color: var(--muted);
      margin-bottom:2px;
      font-weight: 600;
    }
    
    input[type=text], input[type=number], input[type=date], select, textarea, input[type=password]{
      width:100%;
      padding:5px 8px;
      border: 1px solid var(--border);
      border-radius:6px;
      background: rgba(255, 255, 255, 0.9);
      font-size: 12px;
      color: #2e7d32;
    }

    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
    }

    input:hover, select:hover, textarea:hover {
      border-color: #66BB6A;
    }
    
    textarea{resize:vertical}
    
    .btn{
      background: linear-gradient(135deg, var(--accent), #66BB6A);
      color:white;
      border:none;
      padding:6px 12px;
      border-radius:6px;
      cursor:pointer;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.2px;
      position: relative;
      overflow: hidden;
    }

    .btn:hover {
      background: linear-gradient(135deg, var(--accent-hover), #5cb85c);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.3);
    }
    
    .btn.ghost{
      background: rgba(255, 255, 255, 0.9);
      color: var(--accent);
      border: 2px solid var(--accent);
    }

    .btn.ghost:hover {
      background: var(--accent);
      color: white;
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.3);
    }
    
    .btn.danger{
      background: linear-gradient(135deg, var(--danger), #ef5350);
    }

    .btn.danger:hover {
      background: linear-gradient(135deg, #d32f2f, #e53935);
      box-shadow: 0 8px 25px rgba(244, 67, 54, 0.3);
    }
    
    .btn.success{
      background: linear-gradient(135deg, var(--ok), #66BB6A);
    }

    .btn.success:hover {
      background: linear-gradient(135deg, var(--accent-hover), #5cb85c);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.3);
    }
    
    .panel{
      background: var(--card);
      backdrop-filter: blur(10px);
      padding:8px;
      border-radius:8px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      margin-bottom:8px;
    }

    .panel:hover {
      box-shadow: var(--shadow-hover);
    }
    
    .account-item{
      padding:5px;
      border-radius:6px;
      border: 1px solid var(--border);
      margin-bottom:4px;
      cursor:pointer;
      background: rgba(255, 255, 255, 0.9);
      position: relative;
      backdrop-filter: blur(5px);
      font-size: 12px;
    }

    .account-item:hover {
      border-color: var(--accent);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.15);
    }
    
    .account-item.selected{
      border-left: 6px solid var(--accent);
      background: rgba(76, 175, 80, 0.1);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.2);
    }
    
    .account-item .del-btn {
      position: absolute; 
      top: 12px; 
      right: 12px; 
      color: var(--danger); 
      font-size: 18px; 
      display: none; 
      padding: 6px;
      border-radius: 8px;
    }
    
    .account-item .del-btn:hover { 
      background: rgba(244, 67, 54, 0.1);
    }

    .flex-row{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap: wrap;
    }
    
    table{
      width:100%;
      border-collapse:collapse;
      font-size:14px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: var(--shadow);
      table-layout: fixed;
    }
    
    th,td{
      padding:4px 6px;
      border: 1px solid var(--border);
      background:transparent;
      text-align: center;
      font-size: 11px;
    }

    th {
      background: linear-gradient(135deg, var(--accent), #66BB6A);
      color: white;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.2px;
      font-size: 10px;
    }

    /* Filas sin verificar - fondo blanco */
    tr:nth-child(even) {
      background: transparent;
    }

    tr:hover {
      background: rgba(76, 175, 80, 0.08);
    }
    
    /* Filas verificadas por administrador - gris intenso */
    tr.verified-admin{
      background: var(--admin-gray) !important;
      border-left: 4px solid #6b7280;
    }
    
    tr.verified-admin:hover{
      background: #d1d5db !important;
    }
    
    /* Filas verificadas por gerente - amarillo */
    tr.verified-gerente{
      background: var(--manager-yellow) !important;
      border-left: 4px solid #FFC107;
    }
    
    tr.verified-gerente:hover{
      background: rgba(255, 193, 7, 0.3) !important;
    }
    
    /* Separadores */
    tr.separator{
      font-weight:700;
      text-align:center;
      font-size: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    tr.sep-green{
      background: linear-gradient(135deg, #d1fae5, #a7f3d0)!important; 
      color: #065f46;
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.2);
    }
    
    tr.sep-red{
      background: linear-gradient(135deg, #fee2e2, #fecaca)!important; 
      color: #991b1b;
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.2);
    }
    
    /* Foco teclado */
    tr.keyboard-focus { 
      outline: 3px solid var(--accent); 
      z-index: 10; 
      position: relative;
      box-shadow: 0 0 0 6px rgba(76, 175, 80, 0.2);
    }

    .muted{
      color:var(--muted);
      font-size:14px;
      font-style: italic;
    }
    
    .top-totals{
      display:flex;
      gap:5px;
      align-items:center;
      flex-wrap: wrap;
    }
    
    .top-totals .card{
      padding:3px 6px;
      border-radius:6px;
      border: 1px solid var(--border);
      background: var(--card);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }

    .top-totals .card:hover {
      box-shadow: var(--shadow-hover);
    }
    
    .small{
      font-size:9px;
      color: var(--muted);
      font-weight: 500;
    }
    
    .modal{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(5px);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:999;
    }
    
    .modal .card{
      width:750px;
      max-width:96%;
      padding:25px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    .hidden{display:none}
    
    .gear{
      cursor:pointer;
      padding:8px;
      border-radius:10px;
      border: 2px solid var(--border);
      background: var(--card);
      font-size: 16px;
    }

    .gear:hover {
      border-color: var(--accent);
      background: rgba(76, 175, 80, 0.1);
    }
    
    /* Nuevo modal genÃ©rico */
    #generic-modal .card{
      width:500px!important; 
      max-width:96%; 
      padding:25px; 
      position:relative;
      border-radius: 20px;
      overflow: hidden;
    }
    
    #modal-title{
      color: var(--accent); 
      margin-bottom:20px;
      font-size: 1.4em;
      font-weight: 600;
      text-align: center;
    }
    
    #modal-body{
      margin-bottom:20px;
      line-height: 1.6;
      color: #2e7d32;
    }
    
    #modal-password-input{
      margin-top:10px;
    }

    /* ESTILO DINÃMICO DE ADVERTENCIA MODERNIZADO */
    .warning-icon {
        font-size: 36px;
        color: var(--danger);
        margin-right: 15px;
    }
    
    .warning-title-container {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        padding: 15px 0;
        border-bottom: 2px solid var(--border);
        background: rgba(244, 67, 54, 0.05);
        border-radius: 10px;
        padding: 15px;
    }
    
    .warning-message {
        font-weight: 500;
        line-height: 1.6;
        padding-top: 10px;
        color: #2e7d32;
        background: rgba(76, 175, 80, 0.05);
        padding: 15px;
        border-radius: 10px;
        border-left: 4px solid var(--accent);
    }

    /* Modal de datos grandes */
    #data-modal {
      display: none;
      position: fixed;
      z-index: 1001;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(8px);
    }

    #data-modal .modal-content {
      background: linear-gradient(135deg, #a8e6cf 0%, #dcedc1 100%);
      margin: 5% auto;
      padding: 0;
      border-radius: 20px;
      width: 80%;
      max-width: 600px;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }

    #data-modal .modal-header {
      background: linear-gradient(135deg, #4CAF50, #66BB6A);
      color: white;
      padding: 25px;
      text-align: center;
      position: relative;
    }

    #data-modal .modal-header h2 {
      margin: 0;
      font-size: 2em;
      font-weight: 700;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    #data-modal .modal-header .close {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 35px;
      font-weight: bold;
      cursor: pointer;
      color: white;
    }

    #data-modal .modal-header .close:hover {
      opacity: 0.8;
    }

    #data-modal .modal-body {
      padding: 40px;
      text-align: center;
      background: rgba(255, 255, 255, 0.95);
    }

    #data-modal .data-value {
      font-size: 4em;
      font-weight: 900;
      color: #2e7d32;
      text-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      margin: 20px 0;
      font-family: 'Courier New', monospace;
      letter-spacing: 2px;
    }

    #data-modal .data-label {
      font-size: 1.3em;
      color: #555;
      font-weight: 600;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #data-modal .data-icon {
      font-size: 3em;
      margin-bottom: 20px;
      opacity: 0.8;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .layout {
        flex-direction: column;
        height: auto;
      }

      .sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 2px solid var(--border);
      }

      .top-totals {
        flex-direction: column;
        gap: 10px;
      }

      .flex-row {
        flex-direction: column;
        gap: 8px;
      }

      .modal .card {
        width: 95%;
        padding: 20px;
      }

      table {
        font-size: 12px;
      }

      th, td {
        padding: 8px 4px;
      }

      #data-modal .modal-content {
        width: 95%;
        margin: 10% auto;
      }

      #data-modal .data-value {
        font-size: 2.5em;
      }

      #data-modal .modal-body {
        padding: 25px;
      }
    }
  </style>
</head>
<body>

  <div id="topbar">
    <div style="display:flex;gap:6px;align-items:center">
      <strong style="font-size: 1em; color: #2e7d32; text-shadow: 0 2px 4px rgba(0,0,0,0.1);">ðŸ’° Sistema de Consignaciones</strong>
      <div class="small" style="background: rgba(76, 175, 80, 0.1); padding: 1px 5px; border-radius: 10px; color: #2e7d32; font-weight: 600;">Gerencia</div>
    </div>

    <div class="top-totals">
      <div class="card small">
        <div class="muted">ðŸ’µ Total general</div>
        <div id="total-general" style="font-weight: 700; color: #2e7d32; font-size: 0.8em;">0</div>
      </div>
      <div class="card small">
        <div class="muted">ðŸ¦ Total cuenta actual</div>
        <div id="total-cuenta" style="font-weight: 700; color: #2e7d32; font-size: 0.8em;">0</div>
      </div>
      <div class="card small">
        <div class="muted">ðŸ‘¤ Usuario</div>
        <div id="user-info" style="font-weight: 600; color: #2e7d32; font-size: 0.8em;">...</div>
      </div>
      <button id="btn-back" class="btn ghost">â¬…ï¸ AtrÃ¡s</button>
      <button id="open-options" class="btn ghost">âš™ï¸ Opciones</button>
      <button id="logout" class="btn ghost">ðŸšª Salir</button>
    </div>
  </div>

  <div class="layout">
    <div class="sidebar">
      <h3>ðŸ” Buscar / Cuentas</h3>
      <label>ðŸ·ï¸ Buscar por nombre</label>
      <input id="search-name" type="text" placeholder="Nombre de cuenta...">
      <label style="margin-top:8px">ðŸ”¢ Buscar por nÃºmero</label>
      <input id="search-account" type="text" placeholder="NÃºmero de cuenta...">

      <div style="margin-top:6px" class="panel">
        <h4 style="margin-bottom:5px; color: #2e7d32; font-weight: 600; font-size: 0.9em;">âž• Nueva cuenta</h4>
        <label>ðŸ“ Nombre</label>
        <input id="new-account-name" type="text" placeholder="Nombre">
        <label style="margin-top:4px">ðŸ”¢ NÃºmero</label>
        <input id="new-account-number" type="text" placeholder="NÃºmero">
        <div style="margin-top:5px" class="flex-row">
          <button id="add-account" class="btn" style="flex:1">âœ… Agregar</button>
        </div>
      </div>

      <div>
        <div class="muted" style="margin-bottom:4px; font-weight: 600; color: #2e7d32; font-size: 10px;">ðŸ“‹ Lista de Cuentas</div>
        <div id="accounts-list" style="max-height:50vh;overflow:auto;padding-right:5px;"></div>
      </div>
    </div>

    <div class="main">
      <div class="panel">
        <h3>ðŸ’° Agregar consignaciÃ³n</h3>
        <div id="selected-account-info" class="muted" style="margin-bottom:5px; padding: 4px; background: rgba(76, 175, 80, 0.1); border-radius: 4px; border-left: 2px solid var(--accent); font-size: 10px;">Ninguna cuenta seleccionada</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <div style="flex:1;min-width:200px;">
            <label>ðŸ“… FECHA DE CONSIGNACIÃ“N</label>
            <div style="display:flex;gap:5px;align-items:center;flex-wrap:wrap;margin-bottom:4px;">
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="dateOpt" value="today"> ðŸ“… Hoy</label>
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="dateOpt" value="yesterday"> ðŸ“… Ayer</label>
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="dateOpt" value="daybefore"> ðŸ“… Antier</label>
              <label style="margin-left:10px;font-weight:600;">ðŸ“ Manual:</label>
            </div>
            <input id="date-picker" type="date">
          </div>
          <div style="flex:1;min-width:200px;">
            <label>ðŸ‘ï¸ FECHA DE OBSERVACIÃ“N</label>
            <div style="display:flex;gap:5px;align-items:center;flex-wrap:wrap;margin-bottom:4px;">
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="obsOpt" value="today"> ðŸ“… Hoy</label>
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="obsOpt" value="yesterday"> ðŸ“… Ayer</label>
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="obsOpt" value="daybefore"> ðŸ“… Antier</label>
              <label style="margin-left:10px;font-weight:600;">ðŸ“ Manual:</label>
            </div>
            <input id="obsdate-picker" type="date">
          </div>
        </div>
        <div style="margin-top:8px;display:flex;gap:6px;align-items:end;flex-wrap:wrap;">
          <div style="flex:1;min-width:120px;">
            <label>ðŸ’µ VALOR (COP)</label>
            <input id="valor" type="text" placeholder="Ingrese el valor..." style="font-size:12px;font-weight:600;" maxlength="15">
          </div>
          <div style="flex:1;min-width:120px;">
            <label>ðŸ“ REFERENCIA</label>
            <input id="referencia" type="text" placeholder="Ingrese la referencia..." style="font-size:12px;font-weight:600;text-transform:uppercase;" maxlength="50">
          </div>
          <div style="min-width:140px;">
            <button id="add-consign" class="btn" style="width:100%;padding:5px;font-size:10px;">âœ… Agregar ConsignaciÃ³n</button>
          </div>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center; flex-wrap:wrap; gap:5px;">
          <h3 style="margin:0">ðŸ“Š Movimientos</h3>
          <div style="display:flex; gap:4px; flex-wrap:wrap;">
            <button id="btn-export-excel" class="btn success">ðŸ“¥ Descargar Cuenta</button>
            <button id="btn-export-master" class="btn success" style="display:none; background:linear-gradient(135deg, #7c3aed, #8b5cf6); color:white;">ðŸ“¥ Descargar Maestra (G)</button>

            <div style="width:2px; background:var(--border); margin:0 8px; border-radius:1px;"></div>
            <button id="btn-verify" class="btn">âœ… Verificado</button>
            <button id="btn-unverify" class="btn ghost">âŒ Desverificar</button>
            <button id="btn-delete" class="btn danger" style="display:none">ðŸ—‘ï¸ Eliminar</button>
            <button id="btn-sumar" class="btn ghost">âž• Sumar</button>
            <button id="btn-cuadrar" class="btn ghost" style="display:none; border:2px solid var(--accent); color:var(--accent); font-weight:600;">âœ… Cuadrar (Corte)</button>
          </div>
        </div>

        <div style="margin-top:6px;max-height:58vh;overflow:auto;border-radius:6px;width:100%;" tabindex="0" id="table-container"></div>
          <table>
            <thead>
              <tr>
                <th>â˜‘ï¸ Sel</th>
                <th>ðŸ“… FECHA</th>
                <th>ðŸ’µ VALOR</th>
                <th>ï¿½ REF</th>
                <th>ï¿½ ï¸ FECHA OBS</th>
                <th>ðŸ“‹ ESTADO</th>
              </tr>
            </thead>
            <tbody id="consigns-body"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <div id="modal-options" class="modal hidden">
    <div class="panel card" style="width:750px;max-width:96%">
      <h3 style="text-align:center; color:#2e7d32; margin-bottom:25px;">âš™ï¸ Opciones de Acceso</h3>
      <div style="margin-top:20px; display:flex; gap:20px; justify-content:center;">
        <label style="display:flex; align-items:center; gap:8px; padding:10px 20px; border:2px solid var(--border); border-radius:10px; cursor:pointer;">
          <input type="radio" name="sessionRole" value="Administrativo" checked> 
          <span style="font-weight:600;">ðŸ‘¤ Administrativo</span>
        </label>
        <label style="display:flex; align-items:center; gap:8px; padding:10px 20px; border:2px solid var(--border); border-radius:10px; cursor:pointer;">
          <input type="radio" name="sessionRole" value="Gerente"> 
          <span style="font-weight:600;">ðŸ‘‘ Gerente</span>
        </label>
      </div>
      <div id="manager-pass-area" class="hidden" style="margin-top:20px">
        <label>ðŸ” Clave Gerente</label>
        <input id="manager-pass" type="password" placeholder="Ingrese la clave de gerente">
      </div>
      <div style="margin-top:20px;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:15px;">
        <div style="display:flex;align-items:center;gap:10px;">
          <span class="gear" id="gear-change" title="Cambiar clave">âš™ï¸</span>
          <small class="muted" style="font-weight:500;">Configurar clave</small>
        </div>
        <div style="display:flex;gap:10px;">
          <button id="options-continue" class="btn">âœ… Continuar</button>
          <button id="options-cancel" class="btn ghost">âŒ Cancelar</button>
        </div>
      </div>
      <div id="gear-panel" class="hidden" style="margin-top:20px; padding:15px; background:rgba(76,175,80,0.05); border-radius:10px; border:2px solid var(--border);">
        <label>ðŸ”‘ Nueva clave Gerente</label>
        <input id="new-manager-pass" type="text" placeholder="Ingrese nueva clave">
        <div style="margin-top:15px;display:flex;gap:10px;justify-content:flex-end">
          <button id="save-manager-pass" class="btn">ðŸ’¾ Guardar</button>
          <button id="cancel-gear" class="btn ghost">âŒ Cerrar</button>
        </div>
      </div>
    </div>
  </div>

  <div id="generic-modal" class="modal hidden">
    <div class="panel card">
        <h4 id="modal-title" style="margin-top:0;"></h4>
        <div id="modal-body"></div>
        <div id="modal-password-area" class="hidden" style="margin-top:20px">
            <label>ðŸ” CLAVE DE GERENTE</label>
            <input id="modal-password-input" type="password" placeholder="Ingrese la clave de gerente">
        </div>
        <div style="margin-top:25px;display:flex;gap:12px;justify-content:flex-end">
            <button id="modal-cancel-btn" class="btn ghost hidden">âŒ Cancelar</button>
            <button id="modal-ok-btn" class="btn">âœ… Aceptar</button>
        </div>
    </div>
  </div>

  <!-- Modal de Datos Grandes -->
  <div id="data-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="data-modal-title">InformaciÃ³n</h2>
        <span class="close" onclick="closeDataModal()">&times;</span>
      </div>
      <div class="modal-body">
        <div id="data-modal-icon" class="data-icon">ðŸ’°</div>
        <div id="data-modal-label" class="data-label">Total</div>
        <div id="data-modal-value" class="data-value">0</div>
      </div>
    </div>
  </div>

<script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-app-compat.js">// ===== NUEVA LÃ“GICA PARA TOTALES VERDES =====
async function nuevaLogicaTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('âŒ No hay cuenta seleccionada');
    return;
  }
  
  console.log('ðŸ”„ NUEVA LÃ“GICA: Recalculando separadores verdes...');
  
  try {
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`ðŸ“Š Total items: ${allItems.length}`);
    
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`ðŸŸ¢ Separadores verdes: ${separadoresVerdes.length}`);
    
    if (separadoresVerdes.length === 0) return;
    
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`\nðŸŸ¢ Procesando: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      let ordenRojoAnterior = -Infinity;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) < ordenVerde) {
          ordenRojoAnterior = Math.max(ordenRojoAnterior, item.orden || 0);
        }
      }
      
      console.log(`ðŸ”´ Rojo anterior: ${ordenRojoAnterior === -Infinity ? 'NINGUNO' : ordenRojoAnterior}`);
      
      let total = 0;
      let conteo = 0;
      
      for (const item of allItems) {
        if (item.isSeparator) continue;
        if (item.verifiedRole !== 'Gerente') continue;
        
        const ordenItem = item.orden || 0;
        if (ordenItem > ordenRojoAnterior && ordenItem < ordenVerde) {
          total += Number(item.valor || 0);
          conteo++;
        }
      }
      
      console.log(`ðŸŸ¢ Total calculado: ${conteo} consignaciones = ${total}`);
      
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`âœ… Actualizando: ${separadorVerde.total} â†’ ${total}`);
      }
    }
    
    await batch.commit();
    console.log('âœ… RecÃ¡lculo completado');
    await loadConsignaciones();
    
  } catch (error) {
    console.error('âŒ Error:', error);
  }
}

async function probarNuevaLogicaCompleta() {
  console.log('ðŸ§ª PROBANDO NUEVA LÃ“GICA...');
  if (!selectedAccountId) {
    console.log('âŒ Selecciona una cuenta primero');
    return;
  }
  await nuevaLogicaTotalesVerdes();
  console.log('âœ… PRUEBA TERMINADA');
}

// Actualizar funciÃ³n existente para usar la nueva lÃ³gica
async function actualizarTotalesVerdes() {
  await nuevaLogicaTotalesVerdes();
}
// ===== LÃ“GICA CORREGIDA PARA TOTALES VERDES =====
async function logicaCorregidaTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('âŒ No hay cuenta seleccionada');
    return;
  }
  
  console.log('ðŸ”„ LÃ“GICA CORREGIDA: Recalculando separadores verdes...');
  
  try {
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`ðŸ“Š Total items: ${allItems.length}`);
    console.log('ðŸ“‹ Estructura de datos:');
    allItems.forEach((item, index) => {
      if (item.isSeparator) {
        console.log(`${index + 1}. ðŸ”´ðŸŸ¢ SEPARADOR ${item.type.toUpperCase()}: orden ${item.orden}, total: ${item.total || 0}`);
      } else {
        const estado = item.verifiedRole === 'Gerente' ? 'ðŸŸ¡ AMARILLO' : 
                     item.verifiedRole === 'Administrativo' ? 'âšª GRIS' : 'âš« BLANCO';
        console.log(`${index + 1}. ${estado}: ${item.valor}, ref: ${item.referencia}, orden: ${item.orden}`);
      }
    });
    
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`ðŸŸ¢ Separadores verdes: ${separadoresVerdes.length}`);
    
    if (separadoresVerdes.length === 0) return;
    
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`\nðŸŸ¢ Procesando: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      // LÃ“GICA CORREGIDA: Encontrar el separador rojo que estÃ¡ DESPUÃ‰S del verde
      let separadorRojoPosterior = null;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) > ordenVerde) {
          separadorRojoPosterior = item;
          break; // Tomar el primer rojo despuÃ©s del verde
        }
      }
      
      console.log(`ðŸ”´ Separador rojo posterior: ${separadorRojoPosterior ? 
        `${separadorRojoPosterior.id.substring(0, 8)}, orden: ${separadorRojoPosterior.orden}` : 'NINGUNO'}`);
      
      let total = 0;
      let conteo = 0;
      const consignacionesEncontradas = [];
      
      // LÃ“GICA CORREGIDA: Sumar consignaciones que estÃ¡n DESPUÃ‰S del rojo posterior
      for (const item of allItems) {
        if (item.isSeparator) continue;
        if (item.verifiedRole !== 'Gerente') continue;
        
        const ordenItem = item.orden || 0;
        let incluirConsignacion = false;
        
        if (separadorRojoPosterior) {
          // Hay rojo posterior: incluir consignaciones despuÃ©s del rojo
          incluirConsignacion = ordenItem > separadorRojoPosterior.orden;
          console.log(`  ðŸ” Evaluando consignaciÃ³n ${item.id.substring(0, 8)}: orden ${ordenItem} > ${separadorRojoPosterior.orden}? ${incluirConsignacion}`);
        } else {
          // No hay rojo posterior: incluir todas las consignaciones despuÃ©s del verde
          incluirConsignacion = ordenItem > ordenVerde;
          console.log(`  ðŸ” Evaluando consignaciÃ³n ${item.id.substring(0, 8)}: orden ${ordenItem} > ${ordenVerde}? ${incluirConsignacion}`);
        }
        
        if (incluirConsignacion) {
          total += Number(item.valor || 0);
          conteo++;
          consignacionesEncontradas.push({
            id: item.id.substring(0, 8),
            valor: item.valor,
            orden: ordenItem,
            referencia: item.referencia
          });
        }
      }
      
      console.log(`ðŸ“‹ Consignaciones encontradas:`, consignacionesEncontradas);
      console.log(`ðŸŸ¢ Total calculado: ${conteo} consignaciones = ${total}`);
      
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`âœ… Actualizando: ${separadorVerde.total} â†’ ${total}`);
      } else {
        console.log(`â„¹ï¸ Ya correcto: ${total}`);
      }
    }
    
    await batch.commit();
    console.log('âœ… RecÃ¡lculo completado');
    await loadConsignaciones();
    
  } catch (error) {
    console.error('âŒ Error:', error);
  }
}

async function probarLogicaCorregida() {
  console.log('ðŸ§ª PROBANDO LÃ“GICA CORREGIDA...');
  if (!selectedAccountId) {
    console.log('âŒ Selecciona una cuenta primero');
    return;
  }
  await logicaCorregidaTotalesVerdes();
  console.log('âœ… PRUEBA TERMINADA');
}
</script>
<script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-firestore-compat.js">// ===== NUEVA LÃ“GICA PARA TOTALES VERDES =====
async function nuevaLogicaTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('âŒ No hay cuenta seleccionada');
    return;
  }
  
  console.log('ðŸ”„ NUEVA LÃ“GICA: Recalculando separadores verdes...');
  
  try {
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`ðŸ“Š Total items: ${allItems.length}`);
    
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`ðŸŸ¢ Separadores verdes: ${separadoresVerdes.length}`);
    
    if (separadoresVerdes.length === 0) return;
    
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`\nðŸŸ¢ Procesando: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      let ordenRojoAnterior = -Infinity;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) < ordenVerde) {
          ordenRojoAnterior = Math.max(ordenRojoAnterior, item.orden || 0);
        }
      }
      
      console.log(`ðŸ”´ Rojo anterior: ${ordenRojoAnterior === -Infinity ? 'NINGUNO' : ordenRojoAnterior}`);
      
      let total = 0;
      let conteo = 0;
      
      for (const item of allItems) {
        if (item.isSeparator) continue;
        if (item.verifiedRole !== 'Gerente') continue;
        
        const ordenItem = item.orden || 0;
        if (ordenItem > ordenRojoAnterior && ordenItem < ordenVerde) {
          total += Number(item.valor || 0);
          conteo++;
        }
      }
      
      console.log(`ðŸŸ¢ Total calculado: ${conteo} consignaciones = ${total}`);
      
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`âœ… Actualizando: ${separadorVerde.total} â†’ ${total}`);
      }
    }
    
    await batch.commit();
    console.log('âœ… RecÃ¡lculo completado');
    await loadConsignaciones();
    
  } catch (error) {
    console.error('âŒ Error:', error);
  }
}

async function probarNuevaLogicaCompleta() {
  console.log('ðŸ§ª PROBANDO NUEVA LÃ“GICA...');
  if (!selectedAccountId) {
    console.log('âŒ Selecciona una cuenta primero');
    return;
  }
  await nuevaLogicaTotalesVerdes();
  console.log('âœ… PRUEBA TERMINADA');
}

// Actualizar funciÃ³n existente para usar la nueva lÃ³gica
async function actualizarTotalesVerdes() {
  await nuevaLogicaTotalesVerdes();
}
// ===== LÃ“GICA CORREGIDA PARA TOTALES VERDES =====
async function logicaCorregidaTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('âŒ No hay cuenta seleccionada');
    return;
  }
  
  console.log('ðŸ”„ LÃ“GICA CORREGIDA: Recalculando separadores verdes...');
  
  try {
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`ðŸ“Š Total items: ${allItems.length}`);
    console.log('ðŸ“‹ Estructura de datos:');
    allItems.forEach((item, index) => {
      if (item.isSeparator) {
        console.log(`${index + 1}. ðŸ”´ðŸŸ¢ SEPARADOR ${item.type.toUpperCase()}: orden ${item.orden}, total: ${item.total || 0}`);
      } else {
        const estado = item.verifiedRole === 'Gerente' ? 'ðŸŸ¡ AMARILLO' : 
                     item.verifiedRole === 'Administrativo' ? 'âšª GRIS' : 'âš« BLANCO';
        console.log(`${index + 1}. ${estado}: ${item.valor}, ref: ${item.referencia}, orden: ${item.orden}`);
      }
    });
    
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`ðŸŸ¢ Separadores verdes: ${separadoresVerdes.length}`);
    
    if (separadoresVerdes.length === 0) return;
    
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`\nðŸŸ¢ Procesando: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      // LÃ“GICA CORREGIDA: Encontrar el separador rojo que estÃ¡ DESPUÃ‰S del verde
      let separadorRojoPosterior = null;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) > ordenVerde) {
          separadorRojoPosterior = item;
          break; // Tomar el primer rojo despuÃ©s del verde
        }
      }
      
      console.log(`ðŸ”´ Separador rojo posterior: ${separadorRojoPosterior ? 
        `${separadorRojoPosterior.id.substring(0, 8)}, orden: ${separadorRojoPosterior.orden}` : 'NINGUNO'}`);
      
      let total = 0;
      let conteo = 0;
      const consignacionesEncontradas = [];
      
      // LÃ“GICA CORREGIDA: Sumar consignaciones que estÃ¡n DESPUÃ‰S del rojo posterior
      for (const item of allItems) {
        if (item.isSeparator) continue;
        if (item.verifiedRole !== 'Gerente') continue;
        
        const ordenItem = item.orden || 0;
        let incluirConsignacion = false;
        
        if (separadorRojoPosterior) {
          // Hay rojo posterior: incluir consignaciones despuÃ©s del rojo
          incluirConsignacion = ordenItem > separadorRojoPosterior.orden;
          console.log(`  ðŸ” Evaluando consignaciÃ³n ${item.id.substring(0, 8)}: orden ${ordenItem} > ${separadorRojoPosterior.orden}? ${incluirConsignacion}`);
        } else {
          // No hay rojo posterior: incluir todas las consignaciones despuÃ©s del verde
          incluirConsignacion = ordenItem > ordenVerde;
          console.log(`  ðŸ” Evaluando consignaciÃ³n ${item.id.substring(0, 8)}: orden ${ordenItem} > ${ordenVerde}? ${incluirConsignacion}`);
        }
        
        if (incluirConsignacion) {
          total += Number(item.valor || 0);
          conteo++;
          consignacionesEncontradas.push({
            id: item.id.substring(0, 8),
            valor: item.valor,
            orden: ordenItem,
            referencia: item.referencia
          });
        }
      }
      
      console.log(`ðŸ“‹ Consignaciones encontradas:`, consignacionesEncontradas);
      console.log(`ðŸŸ¢ Total calculado: ${conteo} consignaciones = ${total}`);
      
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`âœ… Actualizando: ${separadorVerde.total} â†’ ${total}`);
      } else {
        console.log(`â„¹ï¸ Ya correcto: ${total}`);
      }
    }
    
    await batch.commit();
    console.log('âœ… RecÃ¡lculo completado');
    await loadConsignaciones();
    
  } catch (error) {
    console.error('âŒ Error:', error);
  }
}

async function probarLogicaCorregida() {
  console.log('ðŸ§ª PROBANDO LÃ“GICA CORREGIDA...');
  if (!selectedAccountId) {
    console.log('âŒ Selecciona una cuenta primero');
    return;
  }
  await logicaCorregidaTotalesVerdes();
  console.log('âœ… PRUEBA TERMINADA');
}
</script>
<script>
/* CONFIGURACIÃ“N FIREBASE */
const firebaseConfig = {
  apiKey:"AIzaSyChvezwN6DrYXdnBvGLxnjhi4I9xUaxKfU",
  authDomain:"lazapateria-c4157.firebaseapp.com",
  projectId:"lazapateria-c4157",
  storageBucket:"lazapateria-c4157.firebasestorage.app",
  messagingSenderId:"300241769138",
  appId:"1:300241769138:web:8ca1847de3c4fb5042afab"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

/* ESTADO GLOBAL */
const usuario = JSON.parse(localStorage.getItem('datosUsuario') || 'null');
if(!usuario){ showModal('Error', 'No hay sesiÃ³n activa.', false, ()=>location.href='index.html'); }
if(usuario.permisos !== 'Administrador'){ showModal('Error', 'Acceso denegado.', false, ()=>location.href='index.html'); }

$('user-info').textContent = usuario.usuario;
$('logout').onclick = ()=>{ localStorage.removeItem('datosUsuario'); location.href='index.html'; };
$('btn-back').onclick = ()=>{ location.href='paneldecuentas.html'; };

let sessionRole = 'Administrativo';
let managerPass = '0000'; 
const settingsRef = db.collection('settings').doc('managerPassword');

function loadManagerPass() {
    settingsRef.onSnapshot(doc => {
        if (doc.exists && doc.data().password) {
            managerPass = doc.data().password;
        } else {
            // Si el documento no existe, lo creamos con una clave por defecto
            if (!doc.exists) {
                settingsRef.set({ password: '0000' }).catch(e => console.error("Error creando clave por defecto:", e));
            }
            managerPass = '0000'; 
        }
    }, error => {
        console.error("Error al cargar la clave de gerente:", error);
    });
}
loadManagerPass();

let selectedAccountId = null;
let selectedAccountName = "SinNombre";
let currentConsignsSnapshot = []; 
let selectedConsignIds = new Set(); // Almacenamiento local de IDs seleccionados (para persistencia en UI)

/* UTILIDADES */
function $(id){ return document.getElementById(id); }
function fmtCOP(n){ return new Intl.NumberFormat('es-CO').format(Number(n||0)); }

// FunciÃ³n para verificar si una referencia ya existe en cualquier cuenta
async function checkReferenciaExists(referencia) {
  if (!referencia || referencia.trim() === '') return { exists: false };
  
  try {
    // Buscar en todas las cuentas
    const cuentasSnapshot = await db.collection('cuentas').get();
    
    for (const cuentaDoc of cuentasSnapshot.docs) {
      const consignacionesSnapshot = await db.collection('cuentas')
        .doc(cuentaDoc.id)
        .collection('consignaciones')
        .where('referencia', '==', referencia.trim())
        .get();
      
      if (!consignacionesSnapshot.empty) {
        const cuentaData = cuentaDoc.data();
        return { 
          exists: true, 
          cuentaId: cuentaDoc.id,
          cuentaNombre: cuentaData.name || 'Cuenta sin nombre'
        };
      }
    }
    
    return { exists: false };
  } catch (error) {
    console.error('Error verificando referencia:', error);
    throw new Error('Error al verificar la referencia: ' + error.message);
  }
}
function parseDateRadio(name, pickerId){ 
  const opts = document.getElementsByName(name); 
  let sel = null; 
  for(const r of opts) if(r.checked) sel = r.value; 
  
  // Crear fechas en zona horaria de Colombia (UTC-5)
  const now = new Date();
  const colombiaOffset = -5 * 60; // UTC-5 en minutos
  const localOffset = now.getTimezoneOffset();
  const colombiaTime = new Date(now.getTime() + (localOffset + colombiaOffset) * 60000);
  
  if(sel === 'today') return colombiaTime; 
  if(sel === 'yesterday'){ 
    const d = new Date(colombiaTime); 
    d.setDate(d.getDate()-1); 
    return d; 
  } 
  if(sel === 'daybefore'){ 
    const d = new Date(colombiaTime); 
    d.setDate(d.getDate()-2); 
    return d; 
  } 
  
  // Si no hay radio button seleccionado, usar el date picker
  const v = $(pickerId).value; 
  if(v) {
    // Crear fecha local correctamente para Colombia
    const parts = v.split('-');
    const selectedDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    // Ajustar a hora de Colombia (mediodÃ­a para evitar problemas de zona horaria)
    selectedDate.setHours(12, 0, 0, 0);
    return selectedDate;
  }
  
  return null; 
}

/* FUNCIONES DE MODAL GENÃ‰RICO */
function showModal(title, message, isConfirm, onOk, onCancel){
    $('modal-title').textContent = title;
    $('modal-body').innerHTML = message;
    $('modal-password-area').classList.add('hidden');
    $('modal-password-input').value = '';

    $('modal-cancel-btn').textContent = "Cancelar";
    $('modal-cancel-btn').classList.toggle('hidden', !isConfirm);
    $('modal-ok-btn').textContent = "Aceptar";
    $('modal-ok-btn').onclick = () => { $('generic-modal').classList.add('hidden'); if(onOk) onOk(); };
    $('modal-cancel-btn').onclick = () => { $('generic-modal').classList.add('hidden'); if(onCancel) onCancel(); };

    $('generic-modal').classList.remove('hidden');
}

function showPasswordModal(title, message){
    return new Promise((resolve, reject) => {
        $('modal-title').textContent = title;
        $('modal-body').textContent = message;
        $('modal-password-area').classList.remove('hidden');
        $('modal-password-input').value = '';
        $('modal-password-input').focus();
        
        $('modal-cancel-btn').textContent = "Cancelar";
        $('modal-cancel-btn').classList.remove('hidden');
        $('modal-ok-btn').textContent = "Aceptar";

        const checkPass = () => {
            const pass = $('modal-password-input').value;
            if (pass === managerPass) {
                $('generic-modal').classList.add('hidden');
                resolve(true);
            } else {
                showModal('Error de Seguridad', 'Clave incorrecta. Intente de nuevo.', false);
                $('modal-password-input').value = '';
                $('modal-password-input').focus();
            }
        };

        const handleCancel = () => {
            $('generic-modal').classList.add('hidden');
            reject(new Error("AcciÃ³n cancelada."));
        };

        $('modal-ok-btn').onclick = checkPass;
        $('modal-cancel-btn').onclick = handleCancel;
        
        // Permite usar Enter en el input de contraseÃ±a
        $('modal-password-input').onkeydown = (e) => {
            if(e.key === 'Enter') { e.preventDefault(); checkPass(); }
        };

        $('generic-modal').classList.remove('hidden');
    }).catch(e => {
        if(e.message !== "AcciÃ³n cancelada.") {
            showModal('Error', e.message, false);
        }
        throw e; // Re-throw to propagate rejection
    });
}

/** Muestra advertencia dinÃ¡mica (Cierre/Cuadre) y pregunta si continuar */
function showSuperWarning(title, message, onContinue) {
    return new Promise((resolve) => {
        $('modal-title').innerHTML = `
            <div class="warning-title-container">
                <span class="warning-icon">ðŸš¨</span>
                <span style="font-size: 1.2em; font-weight: bold; color: var(--danger);">${title}</span>
            </div>
        `;
        $('modal-body').innerHTML = `<p class="warning-message">${message}</p>`;
        $('modal-password-area').classList.add('hidden');
        
        $('modal-cancel-btn').textContent = "Cancelar AcciÃ³n";
        $('modal-cancel-btn').classList.remove('hidden');
        
        $('modal-ok-btn').textContent = "SÃ­, Continuar Agregando";
        $('modal-ok-btn').classList.remove('danger');
        
        $('modal-ok-btn').onclick = () => { 
            $('generic-modal').classList.add('hidden'); 
            resolve(true);
        };
        $('modal-cancel-btn').onclick = () => { 
            $('generic-modal').classList.add('hidden'); 
            resolve(false);
        };

        $('generic-modal').classList.remove('hidden');
    });
}

/** FunciÃ³n para InserciÃ³n Retroactiva (Doble Clic) */
async function handleDoubleClick(clickedConsign, index) {
    if (sessionRole !== 'Gerente') {
        showModal('Acceso Denegado', 'Solo el **Gerente** puede insertar movimientos retroactivos.', false);
        return;
    }
    
    if (clickedConsign.isSeparator || !clickedConsign.verifiedRole) {
         showModal('AtenciÃ³n', 'Solo puede insertar antes de consignaciones verificadas.', false);
         return;
    }
    
    // 3. Preparar datos
    const clickedDate = clickedConsign.fecha.toDate();
    const clickedTimestamp = clickedDate.getTime();
    // Obtener fecha actual en zona horaria de Colombia
    const now = new Date();
    const colombiaOffset = -5 * 60; // UTC-5 en minutos
    const localOffset = now.getTimezoneOffset();
    const colombiaTime = new Date(now.getTime() + (localOffset + colombiaOffset) * 60000);
    const today = colombiaTime.toISOString().substring(0, 10);
    const clickedDateStr = clickedDate.toLocaleDateString('es-CO');

    // 4. Configurar el Modal DinÃ¡mico con inputs de Fecha y ObservaciÃ³n
    $('modal-title').innerHTML = `
        <div class="warning-title-container">
            <span class="warning-icon" style="color: var(--accent);">ðŸ“</span> 
            <span style="font-size: 1.2em; font-weight: bold; color: var(--accent);">InserciÃ³n Retroactiva</span>
        </div>
    `;
    $('modal-body').innerHTML = `
        <p class="warning-message">
            El nuevo movimiento se insertarÃ¡ con la fecha y valor que especifique, aparecerÃ¡ **justo encima** de la consignaciÃ³n del **${clickedDateStr}** y se marcarÃ¡ como Verificado (Gerente).
        </p>
        <div style="display:flex; gap:10px;">
            <div style="flex:1">
                <label style="font-size:13px; color:var(--muted); margin-bottom:6px;">FECHA CONSIGNACIÃ“N:</label>
                <input type="date" id="modal-retro-fecha" required value="${today}" style="width: 100%;">
            </div>
            <div style="flex:1">
                <label style="font-size:13px; color:var(--muted); margin-bottom:6px;">FECHA DE OBSERVACIÃ“N (Opcional):</label>
                <input type="date" id="modal-retro-obsdate" style="width: 100%;">
            </div>
        </div>
        <div style="margin-top:12px;">
            <label style="font-size:13px; color:var(--muted); margin-bottom:6px;">VALOR (COP) a insertar:</label>
            <input type="number" id="modal-retro-valor" placeholder="0.00" style="padding: 8px; border: 1px solid var(--border); border-radius: 6px; width: 100%;">
        </div>
        <div style="margin-top:12px;">
            <label style="font-size:13px; color:var(--muted); margin-bottom:6px;">REFERENCIA:</label>
            <input type="text" id="modal-retro-referencia" placeholder="Ingrese la referencia..." style="padding: 8px; border: 1px solid var(--border); border-radius: 6px; width: 100%; text-transform: uppercase;" maxlength="50">
        </div>
    `;
    
    $('modal-password-area').classList.add('hidden');
    $('modal-cancel-btn').textContent = "Cancelar";
    $('modal-cancel-btn').classList.remove('hidden');
    $('modal-ok-btn').textContent = "Insertar";

    // 5. LÃ³gica de Aceptar
    const insertAction = async () => {
        const valorInput = document.getElementById('modal-retro-valor');
        const referenciaInput = document.getElementById('modal-retro-referencia');
        const fechaInput = document.getElementById('modal-retro-fecha');
        const obsdateInput = document.getElementById('modal-retro-obsdate');
        
        const valor = Number(valorInput.value);
        const referencia = referenciaInput.value.trim();
        const fechaStr = fechaInput.value;
        const obsdateStr = obsdateInput.value;

        if (isNaN(valor) || valor <= 0) {
            showModal('Error', 'Valor invÃ¡lido o no ingresado. Intente de nuevo.', false);
            return handleDoubleClick(clickedConsign, index); 
        }
        if (!referencia) {
            showModal('Error', 'La referencia es obligatoria. Intente de nuevo.', false);
            return handleDoubleClick(clickedConsign, index);
        }
        if (!fechaStr) {
            showModal('Error', 'Debe seleccionar una fecha para la consignaciÃ³n.', false);
            return handleDoubleClick(clickedConsign, index);
        }

        // Verificar que la referencia no exista
        try {
            const referenciaCheck = await checkReferenciaExists(referencia);
            if (referenciaCheck.exists) {
                showModal('Error', `La referencia "${referencia}" ya fue utilizada en la cuenta "${referenciaCheck.cuentaNombre}".`, false);
                return handleDoubleClick(clickedConsign, index);
            }
        } catch (error) {
            showModal('Error', error.message, false);
            return handleDoubleClick(clickedConsign, index);
        }

        // Crear fechas correctamente para Colombia
        const fechaParts = fechaStr.split('-');
        const userFecha = new Date(parseInt(fechaParts[0]), parseInt(fechaParts[1]) - 1, parseInt(fechaParts[2]), 12, 0, 0, 0);
        
        let userObsdate = null;
        if (obsdateStr) {
            const obsParts = obsdateStr.split('-');
            userObsdate = new Date(parseInt(obsParts[0]), parseInt(obsParts[1]) - 1, parseInt(obsParts[2]), 12, 0, 0, 0);
        }
        
        // RETROACTIVA: Con cortes arriba, insertar encima de la fila clickeada
        // Encontrar la posiciÃ³n de la consignaciÃ³n clickeada
        const clickedIndex = currentConsignsSnapshot.findIndex(c => c.id === clickedConsign.id);
        let nuevoOrden;
        
        if (clickedIndex > 0) {
          // Hay una fila encima, insertar entre esa fila y la clickeada
          const filaEncima = currentConsignsSnapshot[clickedIndex - 1];
          const filaClickeada = currentConsignsSnapshot[clickedIndex];
          
          const ordenEncima = filaEncima.orden || 0;
          const ordenClickeada = filaClickeada.orden || 0;
          
          // Usar el promedio entre los dos Ã³rdenes (con decimales para precisiÃ³n)
          nuevoOrden = (ordenEncima + ordenClickeada) / 2;
        } else {
          // Es la primera fila visible, insertar justo despuÃ©s del Ãºltimo corte rojo
          // Buscar el Ãºltimo separador rojo
          let ultimoCorteRojo = null;
          currentConsignsSnapshot.forEach(item => {
            if (item.isSeparator && item.type === 'red') {
              if (!ultimoCorteRojo || (item.orden || 0) < (ultimoCorteRojo.orden || 0)) {
                ultimoCorteRojo = item;
              }
            }
          });
          
          if (ultimoCorteRojo) {
            // Insertar justo despuÃ©s del corte rojo
            nuevoOrden = ultimoCorteRojo.orden + 0.1;
          } else {
            // No hay cortes, usar orden menor que la primera consignaciÃ³n
            const ordenClickeada = clickedConsign.orden || 0;
            nuevoOrden = ordenClickeada - 0.1;
          }
        }
        
        console.log('ðŸ”„ INSERCIÃ“N RETROACTIVA (ENCIMA DE FILA):');
        console.log('  - Ãndice clickeado:', clickedIndex);
        console.log('  - Orden clickeado:', clickedConsign.orden);
        console.log('  - Nuevo orden calculado:', nuevoOrden);
        console.log('  - Fecha usuario:', userFecha);
        console.log('  - Referencia:', referencia);
        
        try {
            await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').add({ 
                fecha: firebase.firestore.Timestamp.fromDate(userFecha), // Fecha seleccionada por el usuario
                obsdate: userObsdate ? firebase.firestore.Timestamp.fromDate(userObsdate) : null,
                valor: valor, 
                referencia: referencia.toUpperCase(), // Convertir a mayÃºsculas
                verifiedBy: usuario.usuario, 
                verifiedRole: 'Gerente',
                orden: nuevoOrden // Campo dedicado para ordenamiento manual
            });
            
            // RECÃLCULO AUTOMÃTICO DESPUÃ‰S DE INSERCIÃ“N RETROACTIVA
            const nuevaConsignacion = {
              orden: nuevoOrden,
              valor: valor,
              verifiedRole: 'Gerente' // InserciÃ³n retroactiva se marca como verificada por Gerente
            };
            await actualizarTotalesVerdes(); // Nueva lÃ³gica simple
            
            // Esperar un momento para que se actualice Firebase y luego actualizar la UI
            setTimeout(() => {
              updateSelectedTotals();
            }, 1000);
            
            console.log('âœ… ConsignaciÃ³n retroactiva agregada exitosamente con orden:', nuevoOrden);
            
        } catch(e) { 
            showModal('Error', 'Error al insertar consignaciÃ³n: '+e.message, false); 
        } finally {
            $('generic-modal').classList.add('hidden');
        }
    };

    $('modal-ok-btn').onclick = insertAction;
    $('modal-cancel-btn').onclick = () => {
        $('generic-modal').classList.add('hidden');
    };
    
    $('generic-modal').classList.remove('hidden');
    document.getElementById('modal-retro-valor').focus();
    
    // Event listener para convertir referencia a mayÃºsculas en el modal
    document.getElementById('modal-retro-referencia').addEventListener('input', function(e) {
        e.target.value = e.target.value.toUpperCase();
    });
}


/* MODAL DE OPCIONES Y ROLES */
$('open-options').addEventListener('click', ()=> {
  $('modal-options').classList.remove('hidden');
  document.querySelector('input[name="sessionRole"][value="Administrativo"]').checked = true;
  $('manager-pass-area').classList.add('hidden');
  $('manager-pass').value = '';
  $('gear-panel').classList.add('hidden');
});

document.querySelectorAll('input[name="sessionRole"]').forEach(r=>{
  r.addEventListener('change', (e)=>{
    if(e.target.value === 'Gerente') $('manager-pass-area').classList.remove('hidden');
    else $('manager-pass-area').classList.add('hidden');
  });
});

$('options-cancel').addEventListener('click', ()=> $('modal-options').classList.add('hidden'));
$('gear-change').addEventListener('click', ()=> $('gear-panel').classList.toggle('hidden'));
$('cancel-gear').addEventListener('click', ()=> $('gear-panel').classList.add('hidden'));

$('save-manager-pass').addEventListener('click', async ()=>{
  const p = $('new-manager-pass').value.trim(); 
  if(!p){ showModal('AtenciÃ³n', 'Ingrese nueva clave.', false); return; }
  
  try {
    // Guardar la nueva clave en Firebase
    await settingsRef.set({ password: p }, { merge: true }); 
    managerPass = p; // Actualiza el estado local inmediatamente
    showModal('Ã‰xito', 'Clave actualizada en el sistema.', false); 
    $('gear-panel').classList.add('hidden');
  } catch(e) {
    showModal('Error', 'Error al guardar la clave: ' + e.message, false);
  }
});

$('options-continue').addEventListener('click', ()=>{
  const chosen = document.querySelector('input[name="sessionRole"]:checked').value;
  if(chosen === 'Gerente'){
    if($('manager-pass').value !== managerPass){ showModal('Error', 'Clave incorrecta.', false); return; }
    sessionRole = 'Gerente';
  } else sessionRole = 'Administrativo';

  const isMgr = (sessionRole === 'Gerente');
  $('btn-delete').style.display = isMgr ? 'inline-block' : 'none';
  $('btn-cuadrar').style.display = isMgr ? 'inline-block' : 'none';
  $('btn-export-master').style.display = isMgr ? 'inline-block' : 'none';
  document.querySelectorAll('.del-btn').forEach(b => b.style.display = isMgr ? 'block' : 'none');
  
  // Habilita/Deshabilita los toggles de cierre de cuenta
  document.querySelectorAll('.close-account-toggle').forEach(t => t.disabled = !isMgr);

  $('modal-options').classList.add('hidden');
  showModal('Acceso', 'Rol activo: ' + sessionRole, false);
  
  // Actualizar indicadores de jerarquÃ­a cuando cambia el rol
  setTimeout(() => {
    updateVerificationIndicators();
  }, 200);
});

/* SEGURIDAD EXTRA: Proteger cambios en items verificados */
async function checkSensitiveAction(selectedData) {
  const lockedItems = selectedData.filter(i => i.verifiedRole || i.isSeparator);
  
  if (lockedItems.length > 0) {
    try {
        await showPasswordModal(
            "âš ï¸ ACCIÃ“N RESTRINGIDA âš ï¸", 
            "EstÃ¡ intentando modificar/eliminar registros VERIFICADOS o CORTES. Ingrese la CLAVE DE GERENTE para continuar:"
        );
        return true;
    } catch (e) {
        return false;
    }
  }
  return true; 
}

/* GESTIÃ“N DE CUENTAS (Incluye lÃ³gica de cierre y re-apertura con clave) */
function subscribeAccounts(){
  db.collection('cuentas').orderBy('name').onSnapshot(snapshot=>{
    const container = $('accounts-list'); container.innerHTML = '';
    
    let firstAccount = null;
    let accountsData = [];
    snapshot.forEach(doc => accountsData.push({ id: doc.id, ...doc.data() }));

    // Si no hay ninguna cuenta seleccionada, seleccionamos la primera
    if(!selectedAccountId && accountsData.length > 0){
        firstAccount = accountsData[0];
        selectedAccountId = firstAccount.id; 
        selectedAccountName = firstAccount.name;
    }

    // Renderizar cuentas
    accountsData.forEach(a=>{
      const isClosed = a.closed || false; 
      const isMgr = (sessionRole === 'Gerente');

      const div = document.createElement('div'); 
      // *** FIX 1: Aplicar el resalte visual correctamente ***
      div.className = 'account-item' + (selectedAccountId === a.id ? ' selected' : '');
      div.innerHTML = `
        <div style="font-weight:600; padding-right:20px;">${a.name} ${isClosed ? ' (ðŸ”’ CERRADA)' : ''}</div>
        <div class="muted">${a.number || ''}</div>
        <label style="margin-top:4px; display: block; font-size:12px;">
            <input type="checkbox" data-id="${a.id}" class="close-account-toggle" ${isClosed ? 'checked' : ''} ${isMgr ? '' : 'disabled'}> 
            ${isClosed ? 'Cuenta Cerrada' : 'Marcar para Cerrar'}
        </label>
      `;
      
      const delBtn = document.createElement('span');
      delBtn.className = 'del-btn';
      delBtn.textContent = 'ðŸ—‘ï¸';
      delBtn.title = "Eliminar cuenta";
      if(isMgr) delBtn.style.display = 'block';
      delBtn.onclick = (e) => { e.stopPropagation(); deleteAccount(a.id, a.name); };
      div.appendChild(delBtn);

      div.onclick = ()=>{ 
        selectedAccountId = a.id; 
        selectedAccountName = a.name;
        
        // LIMPIAR LA SELECCIÃ“N AL CAMBIAR DE CUENTA
        selectedConsignIds.clear(); 
        document.querySelectorAll('#consigns-body input[type="checkbox"]').forEach(chk => chk.checked = false);
        activeRowIndex = -1; // Limpiar Ã­ndice activo/ancla
        anchorRowIndex = -1;
        
        // La actualizaciÃ³n de la UI se maneja mejor forzando el resalto localmente 
        // y dejando que la prÃ³xima snapshot de cuentas actualice todo el sidebar.
        document.querySelectorAll('#accounts-list .account-item').forEach(el => el.classList.remove('selected'));
        div.classList.add('selected');

        const isClosedState = a.closed || false;
        $('selected-account-info').textContent = `Cuenta: ${a.name} â€” ${a.number || ''}${isClosedState ? ' (ðŸ”’ CERRADA)' : ''}`; 
        
        // Recalcular totales de separadores verdes al cambiar de cuenta
        setTimeout(async () => {
          await actualizarTotalesVerdes(); // Nueva lÃ³gica simple
        }, 500);
        
        updateSelectedTotals(); 
        renderConsigns(); 
      };
      container.appendChild(div);
    });

    // *** FIX 2: Asegurar que el tÃ­tulo se actualice en la carga inicial si se seleccionÃ³ la primera cuenta ***
    if(firstAccount){ 
        const isClosed = firstAccount.closed || false;
        $('selected-account-info').textContent = `Cuenta: ${selectedAccountName} â€” ${firstAccount.number || ''}${isClosed ? ' (ðŸ”’ CERRADA)' : ''}`; 
        renderConsigns(); 
        updateSelectedTotals();
        
        // Recalcular totales al cargar la primera cuenta
        setTimeout(async () => {
          await actualizarTotalesVerdes(); // Nueva lÃ³gica simple
        }, 1000);
    }
    // Aseguramos que el total general se actualice al cargar las cuentas por primera vez
    updateTotalGeneral(); 
  });
}
subscribeAccounts();

// Listener para el Toggle de Cierre de Cuenta
document.addEventListener('change', async (e) => {
    if (e.target.classList.contains('close-account-toggle')) {
        const accountId = e.target.dataset.id;
        const newState = e.target.checked;
        
        // Obtener el nombre de la cuenta para el modal de confirmaciÃ³n
        const accountDoc = await db.collection('cuentas').doc(accountId).get();
        const accountName = accountDoc.data()?.name || 'Seleccionada';

        try {
            if (newState) {
                // Requiere clave para CERRAR
                await showPasswordModal("ConfirmaciÃ³n de Cierre", `Â¿Desea CERRAR la cuenta "${accountName}" permanentemente? Esto evitarÃ¡ nuevas consignaciones, a menos que se fuerce la acciÃ³n.`);
            } else {
                // REQUISITO NUEVO: Requiere clave para REABRIR (quitar el cerrado)
                await showPasswordModal("ConfirmaciÃ³n de Apertura", `Â¿Desea REABRIR la cuenta "${accountName}"? Esto permitirÃ¡ nuevas consignaciones. Ingrese CLAVE DE GERENTE.`);
            }
            
            await db.collection('cuentas').doc(accountId).update({ closed: newState });
        } catch (error) {
            e.target.checked = !newState; // Revertir estado en la UI si falla o cancela
            if (error.message !== "AcciÃ³n cancelada.") {
                showModal('Error', "Error al actualizar el estado de la cuenta: " + error.message, false);
            }
        }
    }
});

async function deleteAccount(id, name){
    if(sessionRole !== 'Gerente') return showModal('Error', "Solo Gerente puede eliminar cuentas.", false);
    
    showModal('ConfirmaciÃ³n', `Â¿Eliminar cuenta "${name}" permanentemente?`, true, async () => {
        try {
            await showPasswordModal(
                "âš ï¸ PELIGRO âš ï¸",
                `Va a eliminar la cuenta "${name}" y todo su historial. Ingrese CLAVE DE GERENTE para confirmar:`
            );

            await db.collection('cuentas').doc(id).delete();
            if(selectedAccountId === id) { selectedAccountId=null; $('consigns-body').innerHTML=''; $('selected-account-info').textContent='...'; }
            showModal('Ã‰xito', "Cuenta eliminada.", false);
        } catch(e) { 
            if(e.message !== "AcciÃ³n cancelada.") showModal('Error', "Error: " + e.message, false);
        }
    });
}

/** LÃ³gica para agregar cuentas nuevas */
$('add-account').addEventListener('click', async ()=>{
  const name = $('new-account-name').value.trim();
  const number = $('new-account-number').value.trim();
  
  if(!name){
    return showModal('AtenciÃ³n', 'El nombre de la cuenta es obligatorio.', false);
  }
  
  if(!number){
    return showModal('AtenciÃ³n', 'El nÃºmero de cuenta es obligatorio.', false);
  }
  
  try {
    // Verificar si ya existe una cuenta con el mismo nÃºmero
    const existingAccountQuery = await db.collection('cuentas')
      .where('number', '==', number)
      .get();
    
    if (!existingAccountQuery.empty) {
      const existingAccount = existingAccountQuery.docs[0].data();
      return showModal('Error', `Ya existe una cuenta con el nÃºmero "${number}". Nombre: "${existingAccount.name}".`, false);
    }
    
    await db.collection('cuentas').add({
      name: name,
      number: number,
      closed: false // Default to open
    });
    
    // Success: Clear fields and notify user
    $('new-account-name').value = '';
    $('new-account-number').value = '';
    showModal('Ã‰xito', 'Cuenta agregada con Ã©xito. Ya puede seleccionarla de la lista.', false); 
  } catch(e) {
    showModal('Error', 'Error al agregar la cuenta: ' + e.message, false);
  }
});


/* RENDER CONSIGNACIONES */
let consignsUnsub = null;
function renderConsigns(){ 
  if(consignsUnsub) consignsUnsub(); 
  const tbody = $('consigns-body'); tbody.innerHTML = '';
  currentConsignsSnapshot = [];

  if(!selectedAccountId) return;

  // Obtener todas las consignaciones y ordenar manualmente para manejar migraciÃ³n
  consignsUnsub = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').onSnapshot(async snapshot=>{
    tbody.innerHTML = '';
    currentConsignsSnapshot = [];
    
    // 1. FILTRAR LA SELECCIÃ“N: Eliminar de la "memoria" IDs que ya no existen en el snapshot
    const newSnapshotIds = new Set(snapshot.docs.map(doc => doc.id));
    selectedConsignIds = new Set([...selectedConsignIds].filter(id => newSnapshotIds.has(id)));
    
    // 2. MIGRACIÃ“N: Asignar orden a consignaciones que no lo tienen
    const batch = db.batch();
    let needsMigration = false;
    let maxOrdenExistente = 0;
    
    // Primero, encontrar el orden mÃ¡ximo existente
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      if (data.orden !== undefined) {
        maxOrdenExistente = Math.max(maxOrdenExistente, data.orden);
      }
    });
    
    // Luego, asignar orden a los que no lo tienen (mÃ¡s antiguos primero)
    const docsWithoutOrder = snapshot.docs.filter(doc => doc.data().orden === undefined);
    docsWithoutOrder.sort((a, b) => {
      const fechaA = a.data().fecha?.toDate() || new Date(0);
      const fechaB = b.data().fecha?.toDate() || new Date(0);
      return fechaA.getTime() - fechaB.getTime(); // MÃ¡s antiguos primero
    });
    
    docsWithoutOrder.forEach((doc, index) => {
      const nuevoOrden = maxOrdenExistente + index + 1;
      batch.update(doc.ref, { orden: nuevoOrden });
      needsMigration = true;
    });
    
    if (needsMigration) {
      console.log('ðŸ”„ Migrando consignaciones sin campo orden...');
      await batch.commit();
      return; // El snapshot se actualizarÃ¡ automÃ¡ticamente
    }
    
    // 3. PROCESAR Y ORDENAR DATOS
    snapshot.forEach(doc => currentConsignsSnapshot.push({id: doc.id, ...doc.data()}));
    
    // Ordenar por campo orden (ascendente = orden de ingreso)
    currentConsignsSnapshot.sort((a, b) => {
      const ordenA = a.orden || 0;
      const ordenB = b.orden || 0;
      return ordenA - ordenB; // Ascendente - mantiene orden de ingreso
    });

    currentConsignsSnapshot.forEach((c, index)=>{
      
      const isSelected = selectedConsignIds.has(c.id); // <-- Verificar el estado en la "memoria"
      const checkedAttr = isSelected ? 'checked' : ''; // <-- Atributo 'checked'

      if(c.isSeparator){
        const tr=document.createElement('tr');
        tr.classList.add('separator');
        if(c.type==='green') tr.classList.add('sep-green');
        if(c.type==='red') tr.classList.add('sep-red');
        let labelText = `--- ${c.label} ---`;
        if(c.type === 'green') labelText = `ðŸ’° TOTAL: ${fmtCOP(c.total)}`;
        if(c.type === 'red') labelText = `ðŸ›‘ CORTE (${c.label})`;
        tr.innerHTML = `<td><input type="checkbox" data-id="${c.id}" data-idx="${index}" data-separator="true" ${checkedAttr}></td><td colspan="4">${labelText}</td><td></td>`;
        tbody.appendChild(tr);
        return;
      }

      const tr = document.createElement('tr');
      tr.setAttribute('data-index', index);
      if(c.verifiedRole === 'Administrativo') tr.classList.add('verified-admin');
      if(c.verifiedRole === 'Gerente') tr.classList.add('verified-gerente');
      
      // Usar fecha normal (ya no necesitamos fechaOriginal o fechaUsuario)
      const fechaText = c.fecha && c.fecha.toDate ? new Date(c.fecha.toDate()).toLocaleDateString() : '';
      const obsText = c.obsdate && c.obsdate.toDate ? new Date(c.obsdate.toDate()).toLocaleDateString() : '';
      
      tr.innerHTML = `
        <td style="width:56px; text-align:center;"><input type="checkbox" data-id="${c.id}" data-idx="${index}" ${checkedAttr}></td>
        <td style="width:160px">${fechaText}</td>
        <td style="width:140px">${fmtCOP(c.valor)}</td>
        <td style="width:100px; font-size:10px;">${c.referencia || ''}</td>
        <td style="width:160px">${obsText}</td>
        <td style="width:160px">${c.verifiedRole ? (c.verifiedRole === 'Gerente' ? 'Verificado (Amarillo)' : 'Verificado (Gris)') : 'Pendiente'}</td>
      `;
      
      // *** MODIFICACIÃ“N CRUCIAL AQUÃ ***
      tr.addEventListener('click', (e)=>{
        if(e.target.type !== 'checkbox') {
            activeRowIndex = index;
            anchorRowIndex = index; // <-- FIX: Establecer el ancla al hacer clic en la fila
            
            // Comportamiento estÃ¡ndar: Un clic simple en la fila limpia la selecciÃ³n previa
            if(!e.shiftKey && !e.ctrlKey && !e.metaKey) {
                selectedConsignIds.clear();
                document.querySelectorAll('#consigns-body input[type="checkbox"]').forEach(chk => chk.checked = false);
            }

            highlightRow(index);
        }
      });
      // Listener para doble clic (inserciÃ³n retroactiva)
      tr.addEventListener('dblclick', (e) => handleDoubleClick(c, index));

      tbody.appendChild(tr);
    });
    
    // Actualizar totales automáticamente (solo si no hay un cuadre en proceso)
    if (!window.isProcessingCuadre) {
      updateSelectedTotals(); 
      updateTotalGeneral();
    }
    
    // Actualizar indicadores de jerarquÃ­a despuÃ©s de renderizar
    setTimeout(() => {
      if (typeof updateVerificationIndicators === 'function') {
        updateVerificationIndicators();
      }
    }, 300);
  });
}

/* LÃ“GICA DE TECLADO Y SELECCIÃ“N */
let activeRowIndex = -1;
let anchorRowIndex = -1;
function getRows(){ return Array.from(document.querySelectorAll('#consigns-body tr')); }
function highlightRow(idx){
    const rows = getRows();
    rows.forEach(r => r.classList.remove('keyboard-focus'));
    if(idx >= 0 && idx < rows.length){
        rows[idx].classList.add('keyboard-focus');
        rows[idx].scrollIntoView({block:'nearest'});
    }
}

// SINCRONIZA LA SELECCIÃ“N DEL CHECKBOX CON LA MEMORIA LOCAL
$('consigns-body').addEventListener('change', (e)=>{
    if(e.target.type === 'checkbox'){
        const id = e.target.dataset.id;
        const idx = parseInt(e.target.dataset.idx);
        
        // ACTUALIZA EL SET GLOBAL DE SELECCIÃ“N (MEMORIA LOCAL)
        if(e.target.checked) {
            selectedConsignIds.add(id);
        } else {
            selectedConsignIds.delete(id);
        }
        
        if(!lastShiftState) anchorRowIndex = idx; // Se actualiza el ancla si NO se usa Shift
    }
});

let lastShiftState = false;
document.addEventListener('keydown', e => { if(e.key === 'Shift') lastShiftState = true; });
document.addEventListener('keyup', e => { if(e.key === 'Shift') lastShiftState = false; });

document.addEventListener('keydown', e => {
    if(e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA') return;
    const rows = getRows();
    if(rows.length === 0) return;
    if(['ArrowUp','ArrowDown'].includes(e.key)){
        e.preventDefault();
        
        // Inicializa o corrige el Ã­ndice activo/ancla
        if(activeRowIndex === -1) { 
            activeRowIndex = 0; 
            anchorRowIndex = 0; 
        }
        
        let newIndex = activeRowIndex;
        if(e.key === 'ArrowDown') newIndex++;
        if(e.key === 'ArrowUp') newIndex--;
        newIndex = Math.max(0, Math.min(newIndex, rows.length - 1));
        
        if(e.shiftKey){
            // LÃ³gica de selecciÃ³n de rango (Shift + Flechas)
            
            // Calcula el rango entre el ancla y la nueva posiciÃ³n
            const start = Math.min(anchorRowIndex, newIndex);
            const end = Math.max(anchorRowIndex, newIndex);
            
            // Limpia la selecciÃ³n actual para re-aplicar el nuevo rango
            selectedConsignIds.clear(); 
            
            rows.forEach((r, i) => {
                const chk = r.querySelector('input[type="checkbox"]');
                if(!chk) return;
                
                // Selecciona solo los elementos dentro del nuevo rango
                if(i >= start && i <= end){
                    chk.checked = true;
                    selectedConsignIds.add(chk.dataset.id); 
                } else {
                    chk.checked = false; // Deselecciona los que quedan fuera
                }
            });
            
        } else {
            // Sin Shift: se mueve el cursor y se establece un nuevo ancla
            anchorRowIndex = newIndex;
            // Opcional: limpiar la selecciÃ³n si no se usa Shift (ya manejado en click, pero aquÃ­ garantiza que solo se mueva el foco)
            selectedConsignIds.clear(); 
            document.querySelectorAll('#consigns-body input[type="checkbox"]').forEach(chk => chk.checked = false);
        }
        
        activeRowIndex = newIndex;
        highlightRow(activeRowIndex);
    }
    
    // Toggle Checkbox con barra espaciadora
    if(e.key === ' '){
        e.preventDefault();
        if(activeRowIndex >= 0 && activeRowIndex < rows.length){
            const chk = rows[activeRowIndex].querySelector('input[type="checkbox"]');
            if(chk) {
                // Toggla el estado del checkbox
                chk.checked = !chk.checked;
                
                // SINCRONIZA EL ESTADO CON EL SET
                if(chk.checked) {
                    selectedConsignIds.add(chk.dataset.id);
                } else {
                    selectedConsignIds.delete(chk.dataset.id);
                }
                
                // Actualiza el ancla si no se usÃ³ Shift (aunque ya estÃ¡ en el change listener, lo ponemos aquÃ­ por si acaso)
                if(!e.shiftKey) {
                    anchorRowIndex = activeRowIndex;
                }
            }
        }
    }
});

/* BOTONES DE EXPORTACIÃ“N (Con formato de fecha corregido) */
const longDateFormat = '[$-es-ES]d\ \d\e\ mmmm\ \d\e\ aaaa'; 
const shortDateFormat = 'DD/MM/YYYY'; 

function applyExcelDateFormats(ws) {
    if (!ws['!ref']) return;
    const range = XLSX.utils.decode_range(ws['!ref']);
    
    for (let R = range.s.r + 1; R <= range.e.r; ++R) { 
        const cell_fecha_addr = XLSX.utils.encode_cell({ r: R, c: 0 }); // FECHA
        const cell_valor_addr = XLSX.utils.encode_cell({ r: R, c: 1 }); // VALOR
        const cell_ref_addr = XLSX.utils.encode_cell({ r: R, c: 2 }); // REFERENCIA
        const cell_obs_addr = XLSX.utils.encode_cell({ r: R, c: 3 }); // OBSERVACIONES

        // FECHA: Formato de fecha LARGO
        if (ws[cell_fecha_addr] && ws[cell_fecha_addr].t === 'n') {
            ws[cell_fecha_addr].z = longDateFormat; 
        }
        // OBSERVACIONES: Formato de fecha CORTO (dd/mm/yyyy)
        if (ws[cell_obs_addr] && ws[cell_obs_addr].t === 'n') {
            ws[cell_obs_addr].z = shortDateFormat; 
        }
        
        // Formato de moneda
        if (ws[cell_valor_addr]) {
            ws[cell_valor_addr].z = '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"??_);_(@_)';
        }
    }
    // Ajuste de anchos 
    ws['!cols'] = [{wch: 25}, {wch: 15}, {wch: 15}, {wch: 25}, {wch: 20}];
}

// FunciÃ³n de exportaciÃ³n de cuenta seleccionada
$('btn-export-excel').addEventListener('click', () => {
  if(!selectedAccountId || currentConsignsSnapshot.length === 0) return showModal('AtenciÃ³n', "No hay datos para exportar.", false);

  const dataForExcel = currentConsignsSnapshot
    .filter(c => !c.isSeparator)
    .map(c => {
      // Es crucial pasar los objetos Date para que el formato de Excel funcione
      // Usar fechaOriginal si existe, sino usar fecha normal
      const fechaParaExportar = c.fechaOriginal || c.fecha;
      const fechaDate = fechaParaExportar && fechaParaExportar.toDate ? fechaParaExportar.toDate() : null;
      const obsDate = c.obsdate && c.obsdate.toDate ? c.obsdate.toDate() : null;
      
      const estado = !c.verifiedRole 
          ? 'Pendiente' 
          : c.verifiedRole === 'Administrativo' 
            ? 'Verificado (Gris)' 
            : 'Verificado (Amarillo)';

      return {
        FECHA: fechaDate, 
        VALOR: Number(c.valor || 0),
        REFERENCIA: c.referencia || '',
        OBSERVACIONES: obsDate,
        'ESTADO/COLOR': estado 
      };
    });

  if(dataForExcel.length === 0) return showModal('AtenciÃ³n', "No hay movimientos vÃ¡lidos (solo separadores).", false);

  const wb = XLSX.utils.book_new();
  // El orden de la exportaciÃ³n es el mismo que el del snapshot (ascendente = orden de ingreso)
  const ws = XLSX.utils.json_to_sheet(dataForExcel, { header: ["FECHA", "VALOR", "REFERENCIA", "OBSERVACIONES", "ESTADO/COLOR"] }); 

  applyExcelDateFormats(ws);
  
  XLSX.utils.book_append_sheet(wb, ws, selectedAccountName.substring(0, 31)); 
  XLSX.writeFile(wb, `Consignaciones_${selectedAccountName.replace(/\s+/g,'_')}.xlsx`);
});

// FunciÃ³n de exportaciÃ³n de maestra
$('btn-export-master').addEventListener('click', async () => {
  if (sessionRole !== 'Gerente') return;
  
  try {
    await showPasswordModal(
        "âš ï¸ DESCARGA DE MAESTRA âš ï¸",
        "Esta acciÃ³n descarga toda la informaciÃ³n del sistema. Ingrese la CLAVE DE GERENTE para continuar:"
    );

    const accountsSnapshot = await db.collection('cuentas').get();
    const wb = XLSX.utils.book_new();

    for (const doc of accountsSnapshot.docs) {
      const account = { id: doc.id, ...doc.data() };
      const accountName = account.name.substring(0, 31).replace(/[\/\?\[\]\*\\\: ]/g, '_'); 

      // Las consignaciones se ordenan cronolÃ³gicamente para la maestra (por convenciÃ³n de archivo histÃ³rico)
      const consignsSnapshot = await db.collection('cuentas').doc(account.id).collection('consignaciones').orderBy('fecha').get();

      const dataForExcel = consignsSnapshot.docs
        .map(d => d.data())
        .filter(c => !c.isSeparator)
        .map(c => {
          // Usar fechaOriginal si existe, sino usar fecha normal
          const fechaParaExportar = c.fechaOriginal || c.fecha;
          const fechaDate = fechaParaExportar && fechaParaExportar.toDate ? fechaParaExportar.toDate() : null;
          const obsDate = c.obsdate && c.obsdate.toDate ? c.obsdate.toDate() : null;
          
          const estado = !c.verifiedRole 
              ? 'Pendiente' 
              : c.verifiedRole === 'Administrativo' 
                ? 'Verificado (Gris)' 
                : 'Verificado (Amarillo)';

          return {
            FECHA: fechaDate, 
            VALOR: Number(c.valor || 0),
            REFERENCIA: c.referencia || '',
            OBSERVACIONES: obsDate,
            'ESTADO/COLOR': estado 
          };
        });

      if (dataForExcel.length === 0) continue; 

      const ws = XLSX.utils.json_to_sheet(dataForExcel, { header: ["FECHA", "VALOR", "REFERENCIA", "OBSERVACIONES", "ESTADO/COLOR"] }); 

      applyExcelDateFormats(ws);

      XLSX.utils.book_append_sheet(wb, ws, accountName);
    }
    
    if (wb.SheetNames.length > 0) {
      XLSX.writeFile(wb, `Maestra_Consignaciones_${new Date().toLocaleDateString().replace(/\//g,'-')}.xlsx`);
    } else {
      showModal('AtenciÃ³n', "No se encontraron movimientos en ninguna cuenta para exportar.", false);
    }
  } catch (e) {
    if(e.message !== "AcciÃ³n cancelada.") showModal('Error', "OcurriÃ³ un error al intentar exportar la maestra: " + e.message, false);
  }
});


/* OPERACIONES DE DATOS (Sin modal de Ã©xito) */
$('add-consign').addEventListener('click', async ()=>{
  if(!selectedAccountId) return showModal('AtenciÃ³n', 'Seleccione una cuenta.', false);
  
  // 1. Validar datos con nueva validaciÃ³n mejorada
  const fecha = parseDateRadio('dateOpt','date-picker'); 
  const obsdate = parseDateRadio('obsOpt','obsdate-picker'); 
  const referencia = $('referencia').value.trim();
  
  if(!fecha) return showModal('AtenciÃ³n', 'Fecha invÃ¡lida.', false);
  if(!referencia) return showModal('AtenciÃ³n', 'La referencia es obligatoria.', false);
  
  // Validar valor usando la nueva funciÃ³n de validaciÃ³n
  let valor;
  try {
    valor = validateValorInput($('valor').value);
  } catch (error) {
    $('valor').focus();
    return showModal('Error de ValidaciÃ³n', error.message, false);
  }
  
  // 2. Verificar que la referencia no exista
  try {
    const referenciaCheck = await checkReferenciaExists(referencia);
    if (referenciaCheck.exists) {
      return showModal('Error', `La referencia "${referencia}" ya fue utilizada en la cuenta "${referenciaCheck.cuentaNombre}".`, false);
    }
  } catch (error) {
    return showModal('Error', error.message, false);
  }

  // --- LÃ“GICA DE ADVERTENCIA DINÃMICA ---
  
  const accountDoc = await db.collection('cuentas').doc(selectedAccountId).get();
  const isClosed = accountDoc.data()?.closed || false;
  
  let proceed = true;

  if (isClosed) {
    proceed = await showSuperWarning(
      "CUENTA CERRADA DETECTADA", 
      `La cuenta "${selectedAccountName}" ha sido marcada como CERRADA. Agregar una consignaciÃ³n puede indicar un error.`,
      null
    );
  } 
  
  if (!proceed) {
      return; // Detiene la acciÃ³n si el usuario selecciona "Cancelar AcciÃ³n"
  }
  
  // --- FIN DE LÃ“GICA DE ADVERTENCIA ---

  // 3. Ejecutar adiciÃ³n
  try{ 
    // CONSIGNACIONES NORMALES: Con cortes en la parte superior
    // Buscar el separador rojo mÃ¡s reciente (que estarÃ¡ en la parte superior)
    let ultimoCorteRojo = null;
    let ordenParaNuevaConsignacion = 0;
    
    // Buscar el separador rojo con el orden mÃ¡s PEQUEÃ‘O (mÃ¡s reciente, ya que estÃ¡n arriba)
    for (const item of currentConsignsSnapshot) {
      if (item.isSeparator && item.type === 'red') {
        if (!ultimoCorteRojo || (item.orden || 0) < (ultimoCorteRojo.orden || 0)) {
          ultimoCorteRojo = item;
        }
      }
    }
    
    if (ultimoCorteRojo) {
      // HAY UN CORTE: Las nuevas consignaciones deben ir ENCIMA del separador verde
      // Buscar el separador verde mÃ¡s reciente (el que tiene menor orden, ya que estÃ¡n arriba)
      let separadorVerdeMasReciente = null;
      currentConsignsSnapshot.forEach(c => {
        if (c.isSeparator && c.type === 'green') {
          if (!separadorVerdeMasReciente || (c.orden || 0) < (separadorVerdeMasReciente.orden || 0)) {
            separadorVerdeMasReciente = c;
          }
        }
      });
      
      if (separadorVerdeMasReciente) {
        // Insertar ENCIMA del separador verde (orden menor)
        ordenParaNuevaConsignacion = separadorVerdeMasReciente.orden - 0.1;
      } else {
        // No hay separador verde, insertar despuÃ©s del rojo
        ordenParaNuevaConsignacion = ultimoCorteRojo.orden + 0.1;
      }
      
      console.log('ðŸ†• CONSIGNACIÃ“N ENCIMA DEL SEPARADOR VERDE:');
      console.log('  - Orden corte rojo:', ultimoCorteRojo.orden);
      console.log('  - Orden separador verde:', separadorVerdeMasReciente?.orden);
      console.log('  - Nuevo orden (ENCIMA del verde):', ordenParaNuevaConsignacion);
      
    } else {
      // NO HAY CORTES: Agregar al final de la lista (orden mÃ¡ximo + 1)
      let maxOrden = 0;
      currentConsignsSnapshot.forEach(c => {
        if (!c.isSeparator && c.orden !== undefined) {
          maxOrden = Math.max(maxOrden, c.orden);
        }
      });
      
      ordenParaNuevaConsignacion = maxOrden + 1;
      
      console.log('ðŸ†• CONSIGNACIÃ“N SIN CORTES (AL FINAL):');
      console.log('  - Orden actual mÃ¡ximo:', maxOrden);
      console.log('  - Nuevo orden:', ordenParaNuevaConsignacion);
    }
    console.log('  - Fecha seleccionada:', fecha.toISOString());
    console.log('  - Referencia:', referencia);
    
    await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').add({ 
        fecha: firebase.firestore.Timestamp.fromDate(fecha), // Fecha seleccionada por el usuario (para mostrar)
        obsdate: obsdate? firebase.firestore.Timestamp.fromDate(obsdate): null, 
        valor, 
        referencia: referencia.toUpperCase(), // Convertir a mayÃºsculas
        verifiedBy:null, 
        verifiedRole:null,
        orden: ordenParaNuevaConsignacion // Campo dedicado para ordenamiento manual
    }); 
    
    // RECALCULAR SEPARADORES AFECTADOS AUTOMÃTICAMENTE
    const nuevaConsignacion = { 
      orden: ordenParaNuevaConsignacion,
      valor: valor,
      verifiedRole: null // Nueva consignaciÃ³n sin verificar
    };
    await actualizarTotalesVerdes(); // Nueva lÃ³gica simple
    
    // Esperar un momento para que se actualice Firebase y luego actualizar la UI
    setTimeout(() => {
      updateSelectedTotals();
    }, 1000);
    
    $('valor').value=''; 
    $('referencia').value=''; // Limpiar el campo de referencia
    $('valor').focus(); // Enfocar el campo valor para la siguiente consignaciÃ³n
    
    console.log('âœ… ConsignaciÃ³n agregada exitosamente con orden:', ordenParaNuevaConsignacion);
    
  }catch(e){ showModal('Error', 'Error al agregar consignaciÃ³n: '+e.message, false); }
});

/* MANEJO ROBUSTO DE ERRORES Y RECOVERY STRATEGIES */

// Estrategias de recuperaciÃ³n para cÃ¡lculos fallidos
const errorRecoveryStrategies = {
  // Contador de errores por cuenta
  errorCounts: new Map(),
  
  // Ãšltimo valor conocido vÃ¡lido por cuenta
  lastKnownValues: new Map(),
  
  // Registrar error y decidir estrategia
  handleCalculationError(accountId, operation, error) {
    const key = `${accountId}_${operation}`;
    const currentCount = this.errorCounts.get(key) || 0;
    this.errorCounts.set(key, currentCount + 1);
    
    console.error(`âŒ Error en ${operation} (intento ${currentCount + 1}):`, error);
    
    // Estrategia basada en nÃºmero de errores
    if (currentCount < 2) {
      console.log('ðŸ”„ Reintentando operaciÃ³n...');
      return 'retry';
    } else if (currentCount < 5) {
      console.log('â³ Usando Ãºltimo valor conocido...');
      return 'useLastKnown';
    } else {
      console.log('ðŸš¨ Demasiados errores, recÃ¡lculo completo...');
      return 'fullRecalculation';
    }
  },
  
  // Guardar Ãºltimo valor conocido vÃ¡lido
  saveLastKnownValue(accountId, operation, value) {
    const key = `${accountId}_${operation}`;
    this.lastKnownValues.set(key, {
      value: value,
      timestamp: Date.now()
    });
    // Resetear contador de errores en Ã©xito
    this.errorCounts.delete(key);
  },
  
  // Obtener Ãºltimo valor conocido vÃ¡lido
  getLastKnownValue(accountId, operation) {
    const key = `${accountId}_${operation}`;
    const stored = this.lastKnownValues.get(key);
    
    if (stored && (Date.now() - stored.timestamp) < 300000) { // 5 minutos
      console.log('ðŸ“š Usando Ãºltimo valor conocido vÃ¡lido:', stored.value);
      return stored.value;
    }
    
    return null;
  }
};

// FunciÃ³n para detectar inconsistencias en cÃ¡lculos
function detectCalculationInconsistency(separator, calculatedTotal) {
  const storedTotal = separator.total || 0;
  const tolerance = 1; // 1 peso de tolerancia
  
  const difference = Math.abs(storedTotal - calculatedTotal);
  
  if (difference > tolerance) {
    console.warn('âš ï¸ INCONSISTENCIA DETECTADA:');
    console.warn(`  - Separador ID: ${separator.id}`);
    console.warn(`  - Total almacenado: ${fmtCOP(storedTotal)}`);
    console.warn(`  - Total calculado: ${fmtCOP(calculatedTotal)}`);
    console.warn(`  - Diferencia: ${fmtCOP(difference)}`);
    
    return {
      hasInconsistency: true,
      difference: difference,
      storedTotal: storedTotal,
      calculatedTotal: calculatedTotal
    };
  }
  
  return { hasInconsistency: false };
}

// FunciÃ³n para logging detallado de debugging
function logCalculationDebug(operation, data) {
  const timestamp = new Date().toISOString();
  const debugInfo = {
    timestamp: timestamp,
    operation: operation,
    accountId: selectedAccountId,
    data: data
  };
  
  console.group(`ðŸ› DEBUG: ${operation} - ${timestamp}`);
  console.log('Account ID:', debugInfo.accountId);
  console.log('Data:', debugInfo.data);
  console.groupEnd();
  
  // Guardar en localStorage para debugging persistente
  const debugLog = JSON.parse(localStorage.getItem('calculationDebugLog') || '[]');
  debugLog.push(debugInfo);
  
  // Mantener solo los Ãºltimos 50 logs
  if (debugLog.length > 50) {
    debugLog.splice(0, debugLog.length - 50);
  }
  
  localStorage.setItem('calculationDebugLog', JSON.stringify(debugLog));
}

// FunciÃ³n para recÃ¡lculo completo como fallback
async function performFullRecalculation(accountId) {
  console.log('ðŸ”„ INICIANDO RECÃLCULO COMPLETO COMO FALLBACK...');
  
  try {
    showCalculationIndicator(true);
    
    // Invalidar todo el cachÃ©
    invalidateCache(accountId);
    
    // Obtener todos los datos frescos
    const allItems = await getConsignationsOptimized(accountId);
    
    // Encontrar todos los separadores verdes
    const greenSeparators = allItems.filter(item => item.isSeparator && item.type === 'green');
    
    if (greenSeparators.length === 0) {
      console.log('â„¹ï¸ No hay separadores verdes para recalcular');
      return;
    }
    
    console.log(`ðŸ”„ Recalculando ${greenSeparators.length} separadores verdes...`);
    
    // Recalcular todos los separadores
    const separatorIds = greenSeparators.map(s => s.id);
    await batchRecalculateSeparators(separatorIds, accountId);
    
    // Actualizar totales de UI
    await updateSelectedTotals();
    
    console.log('âœ… RECÃLCULO COMPLETO EXITOSO');
    
  } catch (error) {
    console.error('âŒ Error en recÃ¡lculo completo:', error);
    
    // Ãšltimo recurso: mostrar mensaje al usuario
    showModal('Error de Sistema', 
      'Hubo un problema con los cÃ¡lculos. Por favor, recarga la pÃ¡gina y contacta al administrador si el problema persiste.', 
      false);
  } finally {
    showCalculationIndicator(false);
  }
}
// ===== LÃ“GICA CORREGIDA PARA TOTALES VERDES =====
async function recalcularTodosLosSeparadoresVerdes() {
  if (!selectedAccountId) return;
  
  console.log('ðŸ”„ LÃ“GICA CORREGIDA: Recalculando todos los separadores verdes...');
  
  try {
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`ðŸŸ¢ Procesando ${separadoresVerdes.length} separadores verdes`);
    
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      console.log(`\nðŸŸ¢ PROCESANDO: ${separadorVerde.id.substring(0, 8)}, orden: ${separadorVerde.orden}`);
      
      // Encontrar el separador rojo anterior
      let separadorRojoAnterior = null;
      for (const item of allItems) {
        if (item.orden >= separadorVerde.orden) break; // Parar antes del verde
        if (item.isSeparator && item.type === 'red') {
          separadorRojoAnterior = item; // El Ãºltimo rojo antes del verde
        }
      }
      
      console.log('ðŸ”´ Separador rojo anterior:', separadorRojoAnterior ? 
        `${separadorRojoAnterior.id.substring(0, 8)}, orden: ${separadorRojoAnterior.orden}` : 'NINGUNO');
      
      // LÃ“GICA CORREGIDA: Buscar consignaciones amarillas
      let total = 0;
      let conteoConsignaciones = 0;
      let consignacionesEncontradas = [];
      
      for (const item of allItems) {
        // Solo procesar consignaciones (no separadores)
        if (item.isSeparator) continue;
        
        // NUEVA LÃ“GICA: Si hay separador rojo anterior, contar DESPUÃ‰S de Ã©l
        // Si NO hay separador rojo anterior, contar ANTES del verde
        let incluirConsignacion = false;
        
        if (separadorRojoAnterior) {
          // Hay rojo anterior: incluir consignaciones entre rojo y verde
          incluirConsignacion = item.orden > separadorRojoAnterior.orden && item.orden < separadorVerde.orden;
        } else {
          // No hay rojo anterior: incluir consignaciones antes del verde
          incluirConsignacion = item.orden < separadorVerde.orden;
        }
        
        if (incluirConsignacion && item.verifiedRole === 'Gerente') {
          total += Number(item.valor || 0);
          conteoConsignaciones++;
          consignacionesEncontradas.push({
            id: item.id.substring(0, 8),
            valor: item.valor,
            orden: item.orden
          });
        }
      }
      
      console.log(`ðŸ“Š Consignaciones encontradas:`, consignacionesEncontradas);
      console.log(`ðŸ’° Total calculado: ${total}`);
      
      // Actualizar si cambiÃ³
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`âœ… Actualizando: ${separadorVerde.total} â†’ ${total}`);
      } else {
        console.log(`â„¹ï¸ Ya correcto: ${total}`);
      }
    }
    
    await batch.commit();
    console.log('âœ… LÃ“GICA CORREGIDA: Completado exitosamente');
    
  } catch (error) {
    console.error('âŒ Error:', error);
  }
}

// FunciÃ³n de depuraciÃ³n para ver exactamente quÃ© datos tenemos
async function debugearDatos() {
  if (!selectedAccountId) return;
  
  console.log('ðŸ” DEPURANDO DATOS...');
  
  const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
  const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
  
  console.log('ðŸ“‹ TODOS LOS ITEMS:');
  allItems.forEach((item, index) => {
    console.log(`${index + 1}. ID: ${item.id.substring(0, 8)}, ` +
      `Separador: ${item.isSeparator ? item.type : 'NO'}, ` +
      `Verificado: ${item.verifiedRole || 'NO'}, ` +
      `Valor: ${item.valor || 0}, ` +
      `Orden: ${item.orden || 0}`);
  });
  
  const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
  const consignacionesAmarillas = allItems.filter(item => !item.isSeparator && item.verifiedRole === 'Gerente');
  
  console.log(`\nðŸŸ¢ SEPARADORES VERDES: ${separadoresVerdes.length}`);
  console.log(`ðŸŸ¡ CONSIGNACIONES AMARILLAS: ${consignacionesAmarillas.length}`);
  
  consignacionesAmarillas.forEach(item => {
    console.log(`  - ${item.id.substring(0, 8)}: ${item.valor}, orden: ${item.orden}`);
  });
}

// FunciÃ³n simple que se ejecuta en todas las operaciones importantes
async function actualizarTotalesVerdes() {
  await debugearDatos(); // Primero depurar
  await recalcularTodosLosSeparadoresVerdes();
}

// Mantener compatibilidad con cÃ³digo existente
async function recalcularTotalSeparadorVerde() {
  await recalcularTodosLosSeparadoresVerdes();
}

async function recalcularSeparadoresAfectados(consignation) {
  await recalcularTodosLosSeparadoresVerdes();
}

// Event listener para convertir referencia a mayÃºsculas
$('referencia').addEventListener('input', function(e) {
  e.target.value = e.target.value.toUpperCase();
});

$('valor').addEventListener('keydown', e=>{ 
  if(e.key==='Enter') {
    e.preventDefault();
    $('referencia').focus(); // Pasar al campo de referencia
  }
});
$('referencia').addEventListener('keydown', e=>{ 
  if(e.key==='Enter') {
    e.preventDefault();
    $('add-consign').click(); // Agregar la consignaciÃ³n
  }
});

// Funcionalidad para deseleccionar radio buttons
let lastSelectedDate = null;
let lastSelectedObs = null;

// FunciÃ³n para validar jerarquÃ­a de verificaciÃ³n
function validateVerificationHierarchy(currentRole, newRole) {
  // Reglas de jerarquÃ­a CORRECTAS:
  // - Blanco (null) â†’ Puede cambiar a Gris (Administrativo) o Amarillo (Gerente) âœ…
  // - Amarillo (Gerente) â†’ Puede cambiar a Gris (Administrativo) âœ…  
  // - Gris (Administrativo) â†’ NO puede cambiar a Amarillo (Gerente) âŒ
  
  if (currentRole === 'Gerente' && newRole === 'Administrativo') {
    return false; // Admin NO puede cambiar Gerente (amarillo) a Admin (gris)
  }
  return true; // Permitido
}

// FunciÃ³n para mostrar indicadores visuales de jerarquÃ­a (versiÃ³n simplificada)
function updateVerificationIndicators() {
  try {
    const rows = document.querySelectorAll('#consigns-body tr');
    
    rows.forEach((row, index) => {
      const data = currentConsignsSnapshot[index];
      if (!data || data.isSeparator) return;
      
      const checkbox = row.querySelector('input[type="checkbox"]');
      if (!checkbox) return;
      
      const canVerify = validateVerificationHierarchy(data.verifiedRole, sessionRole);
      
      if (!canVerify) {
        // Solo cambiar el checkbox, sin agregar elementos adicionales
        checkbox.style.opacity = '0.4';
        checkbox.style.cursor = 'not-allowed';
        checkbox.title = `JerarquÃ­a: Administrador no puede cambiar elementos verificados por Gerente`;
        checkbox.disabled = true;
      } else {
        // Restaurar apariencia normal
        checkbox.style.opacity = '1';
        checkbox.style.cursor = 'pointer';
        checkbox.title = '';
        checkbox.disabled = false;
      }
    });
  } catch (error) {
    console.log('Error en updateVerificationIndicators:', error);
  }
}

// Event listeners para radio buttons de fecha
document.querySelectorAll('input[name="dateOpt"]').forEach(radio => {
  radio.addEventListener('click', function() {
    if (lastSelectedDate === this) {
      this.checked = false;
      lastSelectedDate = null;
    } else {
      lastSelectedDate = this;
      // Limpiar el calendario cuando se selecciona un radio button
      $('date-picker').value = '';
    }
  });
});

// Event listeners para radio buttons de fecha de observaciÃ³n
document.querySelectorAll('input[name="obsOpt"]').forEach(radio => {
  radio.addEventListener('click', function() {
    if (lastSelectedObs === this) {
      this.checked = false;
      lastSelectedObs = null;
    } else {
      lastSelectedObs = this;
      // Limpiar el calendario cuando se selecciona un radio button
      $('obsdate-picker').value = '';
    }
  });
});

// Limpiar selecciÃ³n cuando se usa el date picker
$('date-picker').addEventListener('change', function() {
  document.querySelectorAll('input[name="dateOpt"]').forEach(radio => {
    radio.checked = false;
  });
  lastSelectedDate = null;
});

$('obsdate-picker').addEventListener('change', function() {
  document.querySelectorAll('input[name="obsOpt"]').forEach(radio => {
    radio.checked = false;
  });
  lastSelectedObs = null;
});

// Formateo de nÃºmeros con separadores de miles - MEJORADO
function formatNumberWithSeparators(value) {
  // Remover todo excepto nÃºmeros
  const numericValue = value.replace(/[^\d]/g, '');
  
  if (numericValue === '') return '';
  
  // Validar que no exceda 12 dÃ­gitos
  if (numericValue.length > 12) {
    return formatNumberWithSeparators(numericValue.substring(0, 12));
  }
  
  // Formatear con separadores de miles usando punto
  return new Intl.NumberFormat('es-CO').format(parseInt(numericValue));
}

function getNumericValue(formattedValue) {
  // Remover separadores y devolver solo nÃºmeros
  return formattedValue.replace(/[^\d]/g, '');
}

// Nueva funciÃ³n para validar valor antes de agregar consignaciÃ³n - MEJORADA CON PRECISIÃ“N
function validateValorInput(valor) {
  const numericValue = getNumericValue(valor);
  
  // Validar que no estÃ© vacÃ­o
  if (!numericValue || numericValue === '') {
    throw new Error('El valor es obligatorio');
  }
  
  // Convertir a nÃºmero entero para evitar problemas de punto flotante
  const numberValue = parseInt(numericValue);
  
  // Validar que no sea cero
  if (numberValue <= 0) {
    throw new Error('El valor debe ser mayor a cero');
  }
  
  // Validar que no exceda 12 dÃ­gitos (999,999,999,999)
  if (numericValue.length > 12) {
    throw new Error('El valor no puede exceder 999,999,999,999');
  }
  
  // Validar rango mÃ¡ximo razonable (999 mil millones)
  if (numberValue > 999999999999) {
    throw new Error('El valor excede el lÃ­mite mÃ¡ximo permitido');
  }
  
  return numberValue;
}

/* UTILIDADES DE PRECISIÃ“N NUMÃ‰RICA */

// Convertir valor a centavos para cÃ¡lculos precisos
function toCentavos(pesos) {
  return Math.round(Number(pesos) * 100);
}

// Convertir centavos de vuelta a pesos
function toPesos(centavos) {
  return Math.round(Number(centavos)) / 100;
}

// Sumar valores monetarios con precisiÃ³n
function sumarValoresMonetarios(valores) {
  let totalCentavos = 0;
  for (const valor of valores) {
    totalCentavos += toCentavos(valor);
  }
  return toPesos(totalCentavos);
}

// Validar que un nÃºmero sea un entero vÃ¡lido para cÃ¡lculos monetarios
function validarPrecisionMonetaria(valor) {
  const num = Number(valor);
  
  // Verificar que sea un nÃºmero vÃ¡lido
  if (!Number.isFinite(num)) {
    throw new Error('Valor monetario invÃ¡lido: no es un nÃºmero finito');
  }
  
  // Verificar que no tenga mÃ¡s de 2 decimales (centavos)
  const centavos = Math.round(num * 100);
  const pesosReconstruidos = centavos / 100;
  
  if (Math.abs(num - pesosReconstruidos) > 0.001) {
    console.warn('âš ï¸ Valor monetario con mÃ¡s de 2 decimales, redondeando:', num, 'â†’', pesosReconstruidos);
  }
  
  return pesosReconstruidos;
}

// Event listeners para formateo del campo valor - MEJORADO
$('valor').addEventListener('input', function(e) {
  const cursorPosition = e.target.selectionStart;
  const oldValue = e.target.value;
  const oldLength = oldValue.length;
  
  // Solo permitir nÃºmeros y formatear
  const numericOnly = oldValue.replace(/[^\d]/g, '');
  
  // Limitar a 12 dÃ­gitos mÃ¡ximo
  const limitedValue = numericOnly.substring(0, 12);
  
  // Formatear el valor si no estÃ¡ vacÃ­o
  const formattedValue = limitedValue ? formatNumberWithSeparators(limitedValue) : '';
  e.target.value = formattedValue;
  
  // Ajustar posiciÃ³n del cursor
  const newLength = formattedValue.length;
  const lengthDiff = newLength - oldLength;
  const newCursorPosition = Math.max(0, Math.min(cursorPosition + lengthDiff, newLength));
  
  // Establecer nueva posiciÃ³n del cursor
  setTimeout(() => {
    e.target.setSelectionRange(newCursorPosition, newCursorPosition);
  }, 0);
});

// Validar al hacer focus - mostrar valor sin formato para ediciÃ³n
$('valor').addEventListener('focus', function(e) {
  const numericValue = getNumericValue(e.target.value);
  if (numericValue !== '') {
    e.target.value = numericValue;
    // Seleccionar todo el texto para facilitar ediciÃ³n
    setTimeout(() => {
      e.target.select();
    }, 0);
  }
});

// Restaurar formato y validar al perder focus
$('valor').addEventListener('blur', function(e) {
  if (e.target.value !== '') {
    try {
      const numericValue = getNumericValue(e.target.value);
      if (numericValue) {
        // Validar el valor
        validateValorInput(numericValue);
        // Aplicar formato
        e.target.value = formatNumberWithSeparators(numericValue);
        // Remover cualquier indicador de error
        e.target.style.borderColor = '';
        e.target.style.backgroundColor = '';
      }
    } catch (error) {
      // Mostrar error visualmente
      e.target.style.borderColor = '#f44336';
      e.target.style.backgroundColor = 'rgba(244, 67, 54, 0.1)';
      // Mostrar mensaje de error
      showModal('Error de ValidaciÃ³n', error.message, false);
      // Enfocar de nuevo el campo para correcciÃ³n
      setTimeout(() => {
        e.target.focus();
      }, 100);
    }
  }
});

// FunciÃ³n para obtener los IDs seleccionados usando la memoria local (Nuevo)
function getSelectedConsignIds(){ 
    return Array.from(selectedConsignIds); 
}

$('btn-verify').addEventListener('click', async ()=>{
  const ids=getSelectedConsignIds(); 
  if(ids.length===0) return showModal('AtenciÃ³n', 'Seleccione al menos un movimiento para verificar.', false);
  
  // Obtener los datos de los elementos seleccionados
  const selectedData = currentConsignsSnapshot.filter(c => ids.includes(c.id));
  
  // Validar jerarquÃ­a de verificaciÃ³n
  const invalidItems = [];
  const validItems = [];
  
  selectedData.forEach(item => {
    const currentRole = item.verifiedRole;
    const newRole = sessionRole;
    
    // Reglas de jerarquÃ­a CORRECTAS:
    // - Blanco (null) â†’ Puede cambiar a Gris (Administrativo) o Amarillo (Gerente) âœ…
    // - Amarillo (Gerente) â†’ Puede cambiar a Gris (Administrativo) âœ…  
    // - Gris (Administrativo) â†’ NO puede cambiar a Amarillo (Gerente) âŒ
    
    if (currentRole === 'Gerente' && newRole === 'Administrativo') {
      // Admin NO puede cambiar Gerente (amarillo) a Admin (gris)
      invalidItems.push(item);
    } else {
      // Todos los demÃ¡s casos son vÃ¡lidos
      validItems.push(item);
    }
  });
  
  // Si hay elementos invÃ¡lidos, mostrar mensaje y solo procesar los vÃ¡lidos
  if (invalidItems.length > 0) {
    const message = `âš ï¸ JERARQUÃA DE VERIFICACIÃ“N âš ï¸\n\n` +
      `${invalidItems.length} elemento(s) verificado(s) por Gerente (amarillo) no pueden ser cambiados por Administrador (gris).\n\n` +
      `Solo se verificarÃ¡n ${validItems.length} elemento(s) vÃ¡lido(s) (en blanco).`;
    
    showModal('Advertencia de JerarquÃ­a', message, false);
  }
  
  // Procesar solo los elementos vÃ¡lidos
  if (validItems.length > 0) {
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones'); 
    const batch = db.batch(); 
    
    validItems.forEach(item => {
      batch.update(col.doc(item.id), { verifiedBy: usuario.usuario, verifiedRole: sessionRole });
    });
    
    await batch.commit();
    
    // Mensaje de Ã©xito
    const successMessage = invalidItems.length > 0 
      ? `${validItems.length} movimientos verificados correctamente. ${invalidItems.length} elementos omitidos por jerarquÃ­a.`
      : `${validItems.length} movimientos verificados correctamente.`;
    
    // Forzar actualizaciÃ³n de totales y recÃ¡lculo automÃ¡tico despuÃ©s de verificar
    console.log('âœ… VerificaciÃ³n completada, recalculando separadores afectados...');
    
    // Recalcular separadores afectados por cada consignaciÃ³n verificada
    for (const item of validItems) {
      await actualizarTotalesVerdes(); // Nueva lÃ³gica simple
    }
    
    setTimeout(() => {
      updateSelectedTotals();
      updateTotalGeneral();
    }, 500);
    
    showModal('Ã‰xito', successMessage, false);
  } else if (invalidItems.length > 0) {
    // Solo habÃ­a elementos invÃ¡lidos
    showModal('Error de JerarquÃ­a', 'No se pudo verificar ningÃºn elemento. Los elementos verificados por Gerente (amarillo) no pueden ser cambiados por Administrador (gris).', false);
  }
  
  // Limpia la selecciÃ³n despuÃ©s de la acciÃ³n
  selectedConsignIds.clear();
});

$('btn-unverify').addEventListener('click', async ()=>{
  const ids=getSelectedConsignIds(); if(ids.length===0) return showModal('AtenciÃ³n', 'Seleccione al menos un movimiento para desverificar.', false);
  const selectedData = currentConsignsSnapshot.filter(c => ids.includes(c.id));
  
  if(!await checkSensitiveAction(selectedData)) return;

  const batch = db.batch(); const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
  ids.forEach(id=> batch.update(col.doc(id), { verifiedBy:null, verifiedRole:null })); 
  await batch.commit();
  
  // RecÃ¡lculo automÃ¡tico despuÃ©s de desverificar
  console.log('âŒ DesverificaciÃ³n completada, recalculando separadores afectados...');
  
  // Recalcular separadores afectados por cada consignaciÃ³n desverificada
  for (const item of selectedData) {
    if (!item.isSeparator) {
      await actualizarTotalesVerdes(); // Nueva lÃ³gica simple
    }
  }
  
  setTimeout(() => {
    updateSelectedTotals();
    updateTotalGeneral();
  }, 500);
  
  // Limpia la selecciÃ³n despuÃ©s de la acciÃ³n
  selectedConsignIds.clear();
  showModal('Ã‰xito', `${ids.length} movimientos desverificados.`, false);
});

// FUNCIÃ“N DE ELIMINACIÃ“N CORREGIDA CON RECALCULO GENERAL
$('btn-delete').addEventListener('click', async ()=>{ 
  if(sessionRole!=='Gerente') return showModal('Error', 'Solo Gerente puede eliminar movimientos.', false); 
  const ids=getSelectedConsignIds(); if(ids.length===0) return showModal('AtenciÃ³n', 'Seleccione al menos un movimiento para eliminar.', false);
  const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
  const selectedData = currentConsignsSnapshot.filter(c => ids.includes(c.id));
  
  if(!await checkSensitiveAction(selectedData)) return;

  showModal('ConfirmaciÃ³n', `Â¿Eliminar ${ids.length} items permanentemente?`, true, async () => {
    try {
        // 1. Eliminar los documentos seleccionados
        const deletionBatch = db.batch(); 
        ids.forEach(id=> deletionBatch.delete(col.doc(id))); 
        await deletionBatch.commit();
        
        // --- LÃ“GICA DE RECALCULO DE CORTES AFECTADOS ---
        const affectedGreenSeparatorIds = new Set();
        // Solo las consignaciones verificadas por Gerente que se acaban de borrar
        const deletedVerifiedConsigns = selectedData.filter(c => c.verifiedRole === 'Gerente' && !c.isSeparator);
        
        // 2. Identificar los cortes (separadores verdes) que contenÃ­an el movimiento eliminado
        deletedVerifiedConsigns.forEach(deletedConsign => {
            const deletedDate = deletedConsign.fecha.toDate().getTime();

            // Buscar el Green separator cronolÃ³gicamente mÃ¡s NUEVO que la consignaciÃ³n eliminada.
            // (Este es el que debÃ­a haber cerrado el ciclo, y el que necesita correcciÃ³n de su total)
            const affectedGreenSeparator = currentConsignsSnapshot.find(c => 
                c.type === 'green' && c.fecha.toDate().getTime() > deletedDate
            );
            
            if (affectedGreenSeparator) {
                affectedGreenSeparatorIds.add(affectedGreenSeparator.id);
            }
        });

        if (affectedGreenSeparatorIds.size > 0) {
            
            // 3. Obtener la lista de consignaciones REMANENTES (data fresca post-eliminaciÃ³n)
            // Se usa el orden ascendente (orderBy('fecha')) para un cÃ¡lculo cronolÃ³gico mÃ¡s fÃ¡cil de los perÃ­odos
            const updatedSnapshot = await col.orderBy('fecha').get();
            const updatedConsigns = [];
            updatedSnapshot.forEach(doc => updatedConsigns.push({id: doc.id, ...doc.data()}));

            const updateBatch = db.batch();
            let recalculationCount = 0;

            // 4. Recalcular cada corte afectado
            for (const greenId of affectedGreenSeparatorIds) {
                const affectedGreenSeparator = currentConsignsSnapshot.find(c => c.id === greenId);
                if (!affectedGreenSeparator) continue; 

                // Encontrar el RED separator inmediatamente precedente al corte afectado
                // Como el snapshot local (currentConsignsSnapshot) estÃ¡ en orden descendente, 
                // el Red Separator (1ms mÃ¡s nuevo) estÃ¡ justo ANTES del Green Separator.
                const greenIndex = currentConsignsSnapshot.indexOf(affectedGreenSeparator);
                let precedingRedSeparator = null;
                if (greenIndex > 0) {
                    precedingRedSeparator = currentConsignsSnapshot[greenIndex - 1];
                }
                // Si el precedingRedSeparator no es un red (o no existe) se usa el inicio de los tiempos
                if (!precedingRedSeparator || precedingRedSeparator.type !== 'red') {
                     precedingRedSeparator = null;
                }


                // Definir el inicio del periodo de cÃ¡lculo
                const queryStart = precedingRedSeparator ? precedingRedSeparator.fecha.toDate().getTime() : new Date(0).getTime();
                const queryEnd = affectedGreenSeparator.fecha.toDate().getTime();

                // Sumar las consignaciones restantes verificadas por Gerente en ese periodo
                const remainingConsignsInPeriod = updatedConsigns
                    .filter(c => 
                        !c.isSeparator && 
                        c.verifiedRole === 'Gerente' && 
                        c.fecha.toDate().getTime() > queryStart && 
                        c.fecha.toDate().getTime() < queryEnd
                    );

                const newCutTotal = remainingConsignsInPeriod.reduce((sum, c) => sum + Number(c.valor || 0), 0);
                
                // Aplicar la actualizaciÃ³n al separador verde
                updateBatch.update(col.doc(greenId), { 
                    total: newCutTotal,
                    label: `ðŸš¨ Recalculado ${new Date().toLocaleDateString()}` 
                });
                recalculationCount++;
            }
            
            await updateBatch.commit();
            // Limpia la selecciÃ³n despuÃ©s de la acciÃ³n
            selectedConsignIds.clear();
            
            // RecÃ¡lculo automÃ¡tico despuÃ©s de eliminar (con cortes)
            console.log('ðŸ—‘ï¸ EliminaciÃ³n completada, recalculando separadores automÃ¡ticamente...');
            
            // Usar la nueva lÃ³gica simple
            await actualizarTotalesVerdes();
            
            updateSelectedTotals();
            updateTotalGeneral();
            
            showModal('Â¡AtenciÃ³n!', `EliminaciÃ³n exitosa. Todos los separadores han sido recalculados automÃ¡ticamente.`, false);
        } else {
            // Limpia la selecciÃ³n despuÃ©s de la acciÃ³n
            selectedConsignIds.clear();
            
            // RecÃ¡lculo automÃ¡tico despuÃ©s de eliminar (sin cortes)
            console.log('ðŸ—‘ï¸ EliminaciÃ³n completada, recalculando separadores automÃ¡ticamente...');
            
            // Recalcular separadores afectados por cada consignaciÃ³n eliminada
            for (const item of selectedData) {
              if (!item.isSeparator) {
                await actualizarTotalesVerdes(); // Nueva lÃ³gica simple
              }
            }
            
            updateSelectedTotals();
            updateTotalGeneral();
            
            showModal('Ã‰xito', `${ids.length} items eliminados. Separadores recalculados automÃ¡ticamente.`, false);
        }

    } catch(e) { 
        if(e.message !== "AcciÃ³n cancelada.") showModal('Error', 'Error al eliminar: '+e.message, false);
    }
  });
});

/** FUNCIÃ“N CUADRAR: Solo inserta separadores, no toca el estado de la cuenta */
$('btn-cuadrar').addEventListener('click', async () => {
  if (!selectedAccountId) return showModal('AtenciÃ³n', 'Seleccione una cuenta.', false);
  
  // Buscar consignaciones pendientes desde el Ãºltimo corte
  let pendingItems = [];
  let foundLastCut = false;
  
  // Recorrer desde el final hacia atrÃ¡s (mÃ¡s nuevas primero) para encontrar el Ãºltimo corte
  for (let i = currentConsignsSnapshot.length - 1; i >= 0; i--) {
    const item = currentConsignsSnapshot[i];
    
    if (item.isSeparator && item.type === 'red') {
      foundLastCut = true;
      break; // Encontramos el Ãºltimo corte, paramos aquÃ­
    }
    
    if (!item.isSeparator) {
      pendingItems.unshift(item); // Agregar al principio para mantener orden
    }
  }
  
  if(pendingItems.length === 0) return showModal('AtenciÃ³n', "Nada nuevo para cuadrar. No hay movimientos pendientes desde el Ãºltimo corte.", false);

  const nonYellow = pendingItems.filter(i => i.verifiedRole !== 'Gerente');
  
  // DEBUG: Agregar logs para depurar
  console.log('ðŸ” VALIDACIÃ“N DE CUADRE:');
  console.log('  - Total items pendientes:', pendingItems.length);
  console.log('  - Items sin verificar por Gerente:', nonYellow.length);
  pendingItems.forEach((item, index) => {
    console.log(`  - Item ${index + 1}: verifiedRole="${item.verifiedRole}", valor=${item.valor}, referencia="${item.referencia}"`);
  });
  
  if(nonYellow.length > 0) return showModal('AtenciÃ³n', `Hay ${nonYellow.length} items sin verificar por Gerente. Verifique todos los Ã­tems primero.`, false);

  const total = pendingItems.reduce((acc, curr) => acc + Number(curr.valor || 0), 0);
  
  showModal('ConfirmaciÃ³n', `Â¿Realizar corte?\nTotal a Cuadrar: ${fmtCOP(total)}`, true, async () => {
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    const batch = db.batch();
    
    // Crear fecha en zona horaria de Colombia
    const nowUTC = new Date();
    const colombiaOffset = -5 * 60; // UTC-5 en minutos
    const localOffset = nowUTC.getTimezoneOffset();
    const now = new Date(nowUTC.getTime() + (localOffset + colombiaOffset) * 60000);
    
    // Calcular Ã³rdenes para los separadores
    // Los separadores deben ir en la PARTE SUPERIOR (orden menor)
    // Para que aparezcan arriba, necesitamos Ã³rdenes menores que las consignaciones existentes
    let minOrden = Number.MAX_SAFE_INTEGER;
    currentConsignsSnapshot.forEach(c => {
      if (c.orden !== undefined) {
        minOrden = Math.min(minOrden, c.orden);
      }
    });
    
    // Si no hay consignaciones, usar orden 1 y 2
    if (minOrden === Number.MAX_SAFE_INTEGER) {
      minOrden = 3; // Para que los separadores sean 1 y 2
    }
    
    const ordenSeparadorVerde = minOrden - 2; // Verde va primero (cierre del perÃ­odo anterior)
    const ordenSeparadorRojo = minOrden - 1; // Rojo va despuÃ©s (inicio del nuevo perÃ­odo)
    
    console.log('ðŸ”´ CREANDO CORTE (ARRIBA DE LA TABLA):');
    console.log('  - Orden mÃ­nimo actual:', minOrden);
    console.log('  - Orden separador verde (arriba):', ordenSeparadorVerde);
    console.log('  - Orden separador rojo (arriba):', ordenSeparadorRojo);
    
    // Inserta separador Verde (Total del Corte)
    batch.set(col.doc(), { 
      isSeparator: true, 
      type: 'green', 
      label: now.toLocaleDateString('es-CO'), 
      total: total, 
      fecha: firebase.firestore.Timestamp.fromDate(now),
      orden: ordenSeparadorVerde
    });
    
    // Inserta separador Rojo (Nuevo punto de partida) - DespuÃ©s del verde en orden ascendente
    batch.set(col.doc(), { 
      isSeparator: true, 
      type: 'red', 
      label: now.toLocaleDateString('es-CO'), 
      total: 0, 

/** FUNCIÓN CUADRAR: Solo inserta separadores, no toca el estado de la cuenta */
$('btn-cuadrar').addEventListener('click', async () => {
if (!selectedAccountId) return showModal('Atención', 'Seleccione una cuenta.', false);
  
// Buscar consignaciones pendientes desde el último corte
let pendingItems = [];
let foundLastCut = false;
  
// Recorrer desde el final hacia atrás (más nuevas primero) para encontrar el último corte
for (let i = currentConsignsSnapshot.length - 1; i >= 0; i--) {
  const item = currentConsignsSnapshot[i];
  
  if (item.isSeparator && item.type === 'red') {
    foundLastCut = true;
    break; // Encontramos el último corte, paramos aquí
  }
  
  if (!item.isSeparator) {
    pendingItems.unshift(item); // Agregar al principio para mantener orden
  }
}
  
if(pendingItems.length === 0) return showModal('Atención', "Nada nuevo para cuadrar. No hay movimientos pendientes desde el último corte.", false);

const nonYellow = pendingItems.filter(i => i.verifiedRole !== 'Gerente');
  
// DEBUG: Agregar logs para depurar
console.log(' VALIDACIÓN DE CUADRE:');
console.log('  - Total items pendientes:', pendingItems.length);
console.log('  - Items sin verificar por Gerente:', nonYellow.length);
pendingItems.forEach((item, index) => {
  console.log(`  - Item ${index + 1}: verifiedRole="${item.verifiedRole}", valor=${item.valor}, referencia="${item.referencia}"`);
});
  
if(nonYellow.length > 0) return showModal('Atención', `Hay ${nonYellow.length} items sin verificar por Gerente. Verifique todos los ítems primero.`, false);

const total = pendingItems.reduce((acc, curr) => acc + Number(curr.valor || 0), 0);
  
showModal('Confirmación', `¿Realizar corte?\nTotal a Cuadrar: ${fmtCOP(total)}`, true, async () => {
  // Establecer bandera para evitar interferencias
  window.isProcessingCuadre = true;
  
  const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
  const batch = db.batch();
  
  // Crear fecha en zona horaria de Colombia
  const nowUTC = new Date();
  const colombiaOffset = -5 * 60; // UTC-5 en minutos
  const localOffset = nowUTC.getTimezoneOffset();
  const now = new Date(nowUTC.getTime() + (localOffset + colombiaOffset) * 60000);
  
  // Calcular órdenes para los separadores
  // Los separadores deben ir en la PARTE SUPERIOR (orden menor)
  // Para que aparezcan arriba, necesitamos órdenes menores que las consignaciones existentes
  let minOrden = Number.MAX_SAFE_INTEGER;
  currentConsignsSnapshot.forEach(c => {
    if (c.orden !== undefined) {
      minOrden = Math.min(minOrden, c.orden);
    }
  });
  
  // Si no hay consignaciones, usar orden 1 y 2
  if (minOrden === Number.MAX_SAFE_INTEGER) {
    minOrden = 3; // Para que los separadores sean 1 y 2
  }
  
  const ordenSeparadorVerde = minOrden - 2; // Verde va primero (cierre del período anterior)
  const ordenSeparadorRojo = minOrden - 1; // Rojo va después (inicio del nuevo período)
  
  console.log(' CREANDO CORTE (ARRIBA DE LA TABLA):');
  console.log('  - Orden mínimo actual:', minOrden);
  console.log('  - Orden separador verde (arriba):', ordenSeparadorVerde);
  console.log('  - Orden separador rojo (arriba):', ordenSeparadorRojo);
  
  // Inserta separador Verde (Total del Corte)
  batch.set(col.doc(), { 
    isSeparator: true, 
    type: 'green', 
    label: now.toLocaleDateString('es-CO'), 
    total: total, 
    fecha: firebase.firestore.Timestamp.fromDate(now),
    orden: ordenSeparadorVerde
  });
  
  // Inserta separador Rojo (Nuevo punto de partida) - Después del verde en orden ascendente
  batch.set(col.doc(), { 
    isSeparator: true, 
    type: 'red', 
    label: now.toLocaleDateString('es-CO'), 
    total: 0, 
    fecha: firebase.firestore.Timestamp.fromDate(new Date(now.getTime()+1)),
    orden: ordenSeparadorRojo
  });

  await batch.commit();
  // Limpia la selección después de la acción
  selectedConsignIds.clear();
  
  // Esperar a que Firebase sincronice los nuevos separadores
  await new Promise(resolve => setTimeout(resolve, 1500));
  
  console.log(' Recalculando totales después del cuadre...');
  
  // Recalcular separadores verdes primero
  await actualizarTotalesVerdes();
  
  // Esperar un poco más para que todo se sincronice
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // Actualizar totales de forma coordinada (sin concurrencia)
  console.log(' Actualizando display de totales...');
  
  // Invalidar caché forzar recálculo completo
  invalidateCache(selectedAccountId);
  
  // Actualizar totales de forma secuencial (no concurrente)
  await updateSelectedTotals();
  await updateTotalGeneral();
  
  // Verificar que los totales se actualizaron correctamente y reintentar si es necesario
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  const totalElement = $('total-cuenta');
  const currentDisplay = totalElement ? totalElement.textContent : '$0';
  
  // Si el total sigue en ceros o vacío, reintentar una vez más
  if (!currentDisplay || currentDisplay === '$0' || currentDisplay === '0') {
    console.log('⚠️ Los totales no se actualizaron correctamente, reintentando...');
    invalidateCache(selectedAccountId);
    await updateSelectedTotals();
    await updateTotalGeneral();
  }
  
  // Liberar bandera después de completar el proceso
  window.isProcessingCuadre = false;
  
  showModal('¡Corte realizado con éxito!', false);
});
});

$('btn-sumar').addEventListener('click', ()=>{
  const ids = getSelectedConsignIds();
  let suma = 0;
  ids.forEach(id=>{
    const item = currentConsignsSnapshot.find(c => c.id === id);
    if(item && !item.isSeparator) {
        suma += Number(item.valor || 0);
    }
  });
  showModal('Suma de SelecciÃ³n', `La suma de los Ã­tems seleccionados es: ${fmtCOP(suma)}`, false);
});



/* CALCULOS TOTALES - MEJORADO CON CONCURRENCY-SAFE MANAGER */
// ** Total de Cuenta Actual (Depende de la lista actual en memoria) **
let isUpdatingTotals = false; // Flag para prevenir llamadas concurrentes
let updateTimeout = null; // Timeout para liberar flag automÃ¡ticamente

async function updateSelectedTotals(){ 
  // Prevenir llamadas concurrentes
  if (isUpdatingTotals) {
    console.log('â³ Ya hay una actualizaciÃ³n de totales en progreso, saltando...');
    return;
  }
  
  // ValidaciÃ³n inicial de cuenta seleccionada
  if(!selectedAccountId){ 
    $('total-cuenta').textContent = fmtCOP(0); 
    console.log('âŒ No hay cuenta seleccionada, estableciendo total en 0');
    return; 
  }
  
  // Verificar cachÃ© primero
  const cachedTotal = getCachedTotal(selectedAccountId, 'activePeriod');
  if (cachedTotal !== null) {
    updateTotalDisplay(cachedTotal);
    return;
  }
  
  // Marcar como en progreso con timeout de seguridad
  isUpdatingTotals = true;
  updateTimeout = setTimeout(() => {
    console.log('âš ï¸ Timeout de actualizaciÃ³n de totales, liberando flag');
    isUpdatingTotals = false;
  }, 10000); // 10 segundos de timeout
  
  console.log('=== INICIANDO ACTUALIZACIÃ“N DE TOTALES (CONCURRENCY-SAFE) ===');
  console.log('Cuenta seleccionada:', selectedAccountId);
  
  try {
    // VerificaciÃ³n mÃºltiple de cuenta seleccionada
    if (!selectedAccountId) {
      console.log('âŒ Cuenta seleccionada se perdiÃ³ durante la ejecuciÃ³n');
      $('total-cuenta').textContent = fmtCOP(0);
      return;
    }
    
    console.log('ðŸ”„ Consultando Firebase directamente...');
    
    // Usar consulta optimizada
    const fbDocs = await getConsignationsOptimized(selectedAccountId);
    
    // VerificaciÃ³n post-consulta
    if (!selectedAccountId) {
      console.log('âŒ Cuenta seleccionada cambiÃ³ durante la consulta Firebase');
      return;
    }
    
    console.log(`ðŸ“Š Documentos encontrados en Firebase: ${fbDocs.length}`);
    
    // Calcular total del perÃ­odo activo usando nueva lÃ³gica simplificada
    const totalActual = calculateActivePeriodTotal(fbDocs);
    
    console.log(`ðŸ’° TOTAL CALCULADO PARA PERÃODO ACTIVO: ${totalActual}`);
    
    // Guardar en cachÃ©
    setCachedTotal(selectedAccountId, 'activePeriod', totalActual);
    
    // VerificaciÃ³n final antes de actualizar UI
    if (!selectedAccountId) {
      console.log('âŒ Cuenta seleccionada se perdiÃ³ antes de actualizar UI');
      return;
    }
    
    // Actualizar la UI de forma atÃ³mica
    updateTotalDisplay(totalActual);
    
  } catch(e) {
    console.error('âŒ Error al actualizar totales:', e);
    // Solo actualizar a 0 si aÃºn tenemos la misma cuenta seleccionada
    if (selectedAccountId) {
      $('total-cuenta').textContent = fmtCOP(0);
    }
    console.log('Aplicando total 0 como fallback por error');
  } finally {
    // Limpiar timeout y liberar flag
    if (updateTimeout) {
      clearTimeout(updateTimeout);
      updateTimeout = null;
    }
    isUpdatingTotals = false;
  }
  
  console.log('=== FIN ACTUALIZACIÃ“N DE TOTALES ===');
}

// FunciÃ³n auxiliar para calcular total del perÃ­odo activo - MEJORADA CON PRECISIÃ“N
function calculateActivePeriodTotal(fbDocs) {
  // Encontrar el Ãºltimo separador verde (perÃ­odo mÃ¡s reciente)
  let ultimoSeparadorVerde = null;
  fbDocs.forEach(doc => {
    if (doc.isSeparator && doc.type === 'green') {
      if (!ultimoSeparadorVerde || (doc.orden || 0) < (ultimoSeparadorVerde.orden || 0)) {
        ultimoSeparadorVerde = doc;
      }
    }
  });
  
  let valoresParaSumar = [];
  
  if (ultimoSeparadorVerde) {
    // Hay separadores: sumar consignaciones ENCIMA del Ãºltimo separador verde
    console.log('ðŸ” Calculando perÃ­odo activo desde separador verde (orden:', ultimoSeparadorVerde.orden, ')');
    
    fbDocs.forEach(doc => {
      if (!doc.isSeparator && (doc.orden || 0) < (ultimoSeparadorVerde.orden || 0)) {
        const valorValidado = validarPrecisionMonetaria(doc.valor || 0);
        valoresParaSumar.push(valorValidado);
        console.log(`âœ… Sumando consignaciÃ³n del perÃ­odo activo: ${valorValidado}`);
      }
    });
    
  } else {
    // No hay separadores: sumar todas las consignaciones
    console.log('ðŸ” No hay separadores, sumando todas las consignaciones');
    
    fbDocs.forEach(doc => {
      if (!doc.isSeparator) {
        const valorValidado = validarPrecisionMonetaria(doc.valor || 0);
        valoresParaSumar.push(valorValidado);
        console.log(`âœ… Sumando consignaciÃ³n (sin cortes): ${valorValidado}`);
      }
    });
  }
  
  // Usar suma con precisiÃ³n monetaria
  const totalActual = sumarValoresMonetarios(valoresParaSumar);
  console.log(`ðŸ’° TOTAL CALCULADO CON PRECISIÃ“N: ${totalActual}`);
  
  return totalActual;
}

// FunciÃ³n auxiliar para actualizar la UI de forma atÃ³mica
function updateTotalDisplay(totalActual) {
  const totalElement = $('total-cuenta');
  const formattedTotal = fmtCOP(totalActual);
  
  console.log('ðŸŽ¯ ACTUALIZANDO UI:');
  console.log('  - Elemento encontrado:', !!totalElement);
  console.log('  - Total sin formato:', totalActual);
  console.log('  - Total formateado:', formattedTotal);
  console.log('  - Valor actual en UI:', totalElement ? totalElement.textContent : 'ELEMENTO NO ENCONTRADO');
  
  if (totalElement) {
    // ActualizaciÃ³n atÃ³mica con mÃºltiples mÃ©todos para asegurar compatibilidad
    totalElement.textContent = formattedTotal;
    totalElement.innerHTML = formattedTotal;
    totalElement.innerText = formattedTotal;
    
    // Forzar re-render visual
    totalElement.style.display = 'none';
    totalElement.offsetHeight; // Trigger reflow
    totalElement.style.display = '';
    
    console.log('  - Nuevo valor en UI:', totalElement.textContent);
    console.log('âœ… UI ACTUALIZADA EXITOSAMENTE');
    
    // VerificaciÃ³n post-actualizaciÃ³n
    setTimeout(() => {
      console.log('ðŸ” VERIFICACIÃ“N POST-ACTUALIZACIÃ“N:');
      console.log('  - Valor final en UI:', totalElement.textContent);
    }, 100);
    
  } else {
    console.error('âŒ ERROR: Elemento total-cuenta no encontrado');
  }
}

/* OPTIMIZACIONES DE RENDIMIENTO */

// CachÃ© inteligente para totales calculados
const totalsCache = new Map();
const CACHE_EXPIRY_MS = 30000; // 30 segundos

// FunciÃ³n para obtener clave de cachÃ©
function getCacheKey(accountId, operation) {
  return `${accountId}_${operation}`;
}

// FunciÃ³n para obtener total desde cachÃ©
function getCachedTotal(accountId, operation) {
  const key = getCacheKey(accountId, operation);
  const cached = totalsCache.get(key);
  
  if (cached && (Date.now() - cached.timestamp) < CACHE_EXPIRY_MS) {
    console.log('ðŸ’¾ Usando total desde cachÃ©:', operation, 'â†’', cached.value);
    return cached.value;
  }
  
  return null;
}

// FunciÃ³n para guardar total en cachÃ©
function setCachedTotal(accountId, operation, value) {
  const key = getCacheKey(accountId, operation);
  totalsCache.set(key, {
    value: value,
    timestamp: Date.now()
  });
  console.log('ðŸ’¾ Total guardado en cachÃ©:', operation, 'â†’', value);
}

// FunciÃ³n para invalidar cachÃ©
function invalidateCache(accountId) {
  const keysToDelete = [];
  for (const key of totalsCache.keys()) {
    if (key.startsWith(accountId)) {
      keysToDelete.push(key);
    }
  }
  
  keysToDelete.forEach(key => totalsCache.delete(key));
  console.log('ðŸ—‘ï¸ CachÃ© invalidado para cuenta:', accountId, '(', keysToDelete.length, 'entradas)');
}

// Debouncing para actualizaciones mÃºltiples
let updateDebounceTimeout = null;
const DEBOUNCE_DELAY_MS = 500;

function debouncedUpdateTotals() {
  if (updateDebounceTimeout) {
    clearTimeout(updateDebounceTimeout);
  }
  
  updateDebounceTimeout = setTimeout(() => {
    console.log('â±ï¸ Ejecutando actualizaciÃ³n de totales debounced');
    updateSelectedTotals();
    updateTotalGeneral();
    updateDebounceTimeout = null;
  }, DEBOUNCE_DELAY_MS);
  
  console.log('â±ï¸ ActualizaciÃ³n de totales programada (debounced)');
}

// FunciÃ³n optimizada para consultas Firebase con lÃ­mites
async function getConsignationsOptimized(accountId, limit = null) {
  let query = db.collection('cuentas').doc(accountId).collection('consignaciones')
    .orderBy('orden', 'asc');
  
  if (limit) {
    query = query.limit(limit);
  }
  
  const startTime = Date.now();
  const snapshot = await query.get();
  const endTime = Date.now();
  
  console.log(`âš¡ Consulta Firebase optimizada: ${snapshot.size} docs en ${endTime - startTime}ms`);
  
  const items = [];
  snapshot.forEach(doc => items.push({id: doc.id, ...doc.data()}));
  
  return items;
}

// FunciÃ³n para detectar operaciones pesadas y mostrar indicador
function showCalculationIndicator(show = true) {
  const indicator = document.getElementById('calculation-indicator');
  if (!indicator && show) {
    // Crear indicador si no existe
    const div = document.createElement('div');
    div.id = 'calculation-indicator';
    div.innerHTML = 'ðŸ”„ Recalculando...';
    div.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(76, 175, 80, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      z-index: 1000;
      backdrop-filter: blur(5px);
    `;
    document.body.appendChild(div);
  } else if (indicator) {
    if (show) {
      indicator.style.display = 'block';
    } else {
      indicator.style.display = 'none';
    }
  }
}

/* REAL-TIME CALCULATION ENGINE - MOTOR DE CÃLCULO EN TIEMPO REAL OPTIMIZADO */

// Identificar separadores verdes afectados por un cambio en una consignaciÃ³n
function identifyAffectedSeparators(consignation, allItems) {
  const affectedSeparators = [];
  const consignationOrder = consignation.orden || 0;
  
  console.log('ðŸ” IDENTIFICANDO SEPARADORES AFECTADOS:');
  console.log('  - ConsignaciÃ³n orden:', consignationOrder);
  
  // Encontrar todos los separadores verdes que podrÃ­an incluir esta consignaciÃ³n
  for (const item of allItems) {
    if (item.isSeparator && item.type === 'green') {
      const separatorOrder = item.orden || 0;
      
      // Un separador verde incluye consignaciones que estÃ¡n ANTES de Ã©l (orden menor)
      if (consignationOrder < separatorOrder) {
        // Verificar si hay un separador rojo entre la consignaciÃ³n y el verde
        const redSeparatorBetween = allItems.find(s => 
          s.isSeparator && 
          s.type === 'red' && 
          s.orden > consignationOrder && 
          s.orden < separatorOrder
        );
        
        if (!redSeparatorBetween) {
          // No hay separador rojo entre ellos, este verde incluye la consignaciÃ³n
          affectedSeparators.push(item);
          console.log(`  âœ… Separador verde afectado (orden ${separatorOrder})`);
        } else {
          console.log(`  âŒ Separador verde NO afectado (orden ${separatorOrder}) - hay rojo intermedio`);
        }
      }
    }
  }
  
  console.log(`  ðŸ“Š Total separadores afectados: ${affectedSeparators.length}`);
  return affectedSeparators;
}

// Calcular el total correcto para un separador verde especÃ­fico - MEJORADO CON PRECISIÃ“N
async function calculateSeparatorTotal(separatorId, accountId) {
  console.log('ðŸ§® CALCULANDO TOTAL DE SEPARADOR CON PRECISIÃ“N:', separatorId);
  
  try {
    // Obtener todos los items ordenados
    const snapshot = await db.collection('cuentas').doc(accountId).collection('consignaciones')
      .orderBy('orden', 'asc').get();
    
    const allItems = [];
    snapshot.forEach(doc => allItems.push({id: doc.id, ...doc.data()}));
    
    // Encontrar el separador verde especÃ­fico
    const greenSeparator = allItems.find(item => item.id === separatorId);
    if (!greenSeparator) {
      console.error('âŒ Separador verde no encontrado:', separatorId);
      return 0;
    }
    
    const greenOrder = greenSeparator.orden || 0;
    console.log('  - Separador verde orden:', greenOrder);
    
    // Encontrar el separador rojo anterior (el que tiene orden menor mÃ¡s cercano)
    let previousRedSeparator = null;
    for (const item of allItems) {
      if (item.isSeparator && item.type === 'red' && (item.orden || 0) < greenOrder) {
        if (!previousRedSeparator || (item.orden || 0) > (previousRedSeparator.orden || 0)) {
          previousRedSeparator = item;
        }
      }
    }
    
    const startOrder = previousRedSeparator ? previousRedSeparator.orden : -Infinity;
    console.log('  - Separador rojo anterior orden:', previousRedSeparator?.orden || 'ninguno');
    console.log('  - Rango de cÃ¡lculo: >', startOrder, 'y <', greenOrder);
    
    // Recopilar valores para suma con precisiÃ³n
    const valoresParaSumar = [];
    let consignationCount = 0;
    
    for (const item of allItems) {
      if (!item.isSeparator && 
          item.verifiedRole === 'Gerente' && 
          (item.orden || 0) > startOrder && 
          (item.orden || 0) < greenOrder) {
        
        const valorValidado = validarPrecisionMonetaria(item.valor || 0);
        valoresParaSumar.push(valorValidado);
        consignationCount++;
        console.log(`    âœ… Incluida: ${valorValidado}`);
      }
    }
    
    // Calcular total con precisiÃ³n monetaria
    const total = sumarValoresMonetarios(valoresParaSumar);
    console.log(`  ðŸ’° TOTAL CALCULADO CON PRECISIÃ“N: ${total} (${consignationCount} consignaciones)`);
    
    return total;
    
  } catch (error) {
    console.error('âŒ Error calculando total de separador:', error);
    return 0;
  }
}

// Recalcular mÃºltiples separadores en lote usando Firebase batch - OPTIMIZADO
async function batchRecalculateSeparators(separatorIds, accountId) {
  if (!separatorIds || separatorIds.length === 0) {
    console.log('â„¹ï¸ No hay separadores para recalcular');
    return;
  }
  
  console.log('ðŸ”„ RECALCULANDO SEPARADORES EN LOTE (OPTIMIZADO):', separatorIds.length);
  
  // Mostrar indicador de cÃ¡lculo para operaciones pesadas
  if (separatorIds.length > 3) {
    showCalculationIndicator(true);
  }
  
  try {
    const batch = db.batch();
    const updates = [];
    const startTime = Date.now();
    
    // Calcular nuevo total para cada separador
    for (const separatorId of separatorIds) {
      const newTotal = await calculateSeparatorTotal(separatorId, accountId);
      const separatorRef = db.collection('cuentas').doc(accountId).collection('consignaciones').doc(separatorId);
      
      batch.update(separatorRef, {
        total: newTotal,
        lastRecalculation: firebase.firestore.Timestamp.now(),
        calculationMethod: 'auto'
      });
      
      updates.push({ id: separatorId, total: newTotal });
      console.log(`  ðŸ“ Preparando actualizaciÃ³n: ${separatorId} â†’ ${fmtCOP(newTotal)}`);
    }
    
    // Ejecutar todas las actualizaciones en una sola transacciÃ³n
    await batch.commit();
    
    const endTime = Date.now();
    console.log(`âœ… RECÃLCULO EN LOTE COMPLETADO en ${endTime - startTime}ms`);
    
    updates.forEach(update => {
      console.log(`  âœ… ${update.id}: ${fmtCOP(update.total)}`);
    });
    
    // Invalidar cachÃ© despuÃ©s de recÃ¡lculo
    invalidateCache(accountId);
    
    return updates;
    
  } catch (error) {
    console.error('âŒ Error en recÃ¡lculo en lote:', error);
    throw error;
  } finally {
    // Ocultar indicador de cÃ¡lculo
    showCalculationIndicator(false);
  }
}



// ** Total General (ImplementaciÃ³n mÃ¡s robusta sin CollectionGroup) **
async function updateTotalGeneral(){ 
  try{ 
    // 1. Obtener todas las cuentas
    const accountsSnapshot = await db.collection('cuentas').get();
    let total = 0; 
    
    // 2. Obtener las consignaciones para cada cuenta (en paralelo)
    const consignPromises = accountsSnapshot.docs.map(doc => 
        db.collection('cuentas').doc(doc.id).collection('consignaciones').get()
    );
    
    const allConsignSnapshots = await Promise.all(consignPromises);

    // 3. Sumar todas las consignaciones no-separadoras de todas las cuentas
    allConsignSnapshots.forEach(snap => {
        snap.forEach(d => {
            const data = d.data();
            if(!data.isSeparator) {
                total += Number(data.valor || 0);
            }
        });
    });

    $('total-general').textContent = fmtCOP(total); 
  }catch(e){ 
    console.error("Error al actualizar total general (VERIFIQUE CONSOLA):", e);
    // En caso de fallo, se asegura de mostrar 0 para evitar valores incorrectos o vacÃ­os.
    $('total-general').textContent = fmtCOP(0); 
  } 
}
// Se llama al inicio en subscribeAccounts y luego cada vez que se actualiza una cuenta.
setInterval(updateTotalGeneral,15000); 

/* BUSQUEDA */
const filter = (id) => {
    const q = $(id).value.toLowerCase();
    document.querySelectorAll('#accounts-list .account-item').forEach(it => {
        it.style.display = it.textContent.toLowerCase().includes(q) ? '' : 'none';
    });
};
$('search-name').addEventListener('input', () => filter('search-name'));
$('search-account').addEventListener('input', () => filter('search-account'));

window.addEventListener('load', ()=>{ 
    if(!usuario){ return; } 
    $('modal-options').classList.remove('hidden'); $('manager-pass').value=''; 
});
window.addEventListener('beforeunload', ()=>{ if(consignsUnsub) consignsUnsub(); });

// Funciones para el modal de datos grandes
function showDataModal(title, label, value, icon) {
    document.getElementById('data-modal-title').textContent = title;
    document.getElementById('data-modal-label').textContent = label;
    document.getElementById('data-modal-value').textContent = value;
    document.getElementById('data-modal-icon').textContent = icon;
    document.getElementById('data-modal').style.display = 'block';
}

function closeDataModal() {
    document.getElementById('data-modal').style.display = 'none';
}

// Cerrar modal al hacer clic fuera
window.addEventListener('click', function(event) {
    const dataModal = document.getElementById('data-modal');
    if (event.target === dataModal) {
        closeDataModal();
    }
});

// Cerrar modal con Escape
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        closeDataModal();
    }
});

// Agregar eventos de doble clic a las tarjetas de totales
setTimeout(() => {
    // Total General
    const totalGeneralCard = document.querySelector('.top-totals .card:nth-child(1)');
    if (totalGeneralCard) {
        totalGeneralCard.addEventListener('dblclick', function() {
            const value = document.getElementById('total-general').textContent;
            showDataModal('ðŸ’° TOTAL GENERAL', 'Suma de todas las cuentas', value, 'ðŸ¦');
        });
        totalGeneralCard.style.cursor = 'pointer';
        totalGeneralCard.title = 'Doble clic para ver en grande';
    }

    // Total Cuenta Actual
    const totalCuentaCard = document.querySelector('.top-totals .card:nth-child(2)');
    if (totalCuentaCard) {
        totalCuentaCard.addEventListener('dblclick', function() {
            const value = document.getElementById('total-cuenta').textContent;
            const accountName = selectedAccountName || 'Cuenta Actual';
            showDataModal('ðŸ¦ TOTAL CUENTA ACTUAL', accountName, value, 'ðŸ’³');
        });
        totalCuentaCard.style.cursor = 'pointer';
        totalCuentaCard.title = 'Doble clic para ver en grande';
    }

    // Usuario
    const usuarioCard = document.querySelector('.top-totals .card:nth-child(3)');
    if (usuarioCard) {
        usuarioCard.addEventListener('dblclick', function() {
            const value = document.getElementById('user-info').textContent;
            showDataModal('ðŸ‘¤ USUARIO ACTIVO', 'SesiÃ³n actual', value, 'ðŸ”');
        });
        usuarioCard.style.cursor = 'pointer';
        usuarioCard.title = 'Doble clic para ver en grande';
    }
}, 1000);

// ===== NUEVA LÃ“GICA PARA TOTALES VERDES =====
async function nuevaLogicaTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('âŒ No hay cuenta seleccionada');
    return;
  }
  
  console.log('ðŸ”„ NUEVA LÃ“GICA: Recalculando separadores verdes...');
  
  try {
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`ðŸ“Š Total items: ${allItems.length}`);
    
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`ðŸŸ¢ Separadores verdes: ${separadoresVerdes.length}`);
    
    if (separadoresVerdes.length === 0) return;
    
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`\nðŸŸ¢ Procesando: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      let ordenRojoAnterior = -Infinity;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) < ordenVerde) {
          ordenRojoAnterior = Math.max(ordenRojoAnterior, item.orden || 0);
        }
      }
      
      console.log(`ðŸ”´ Rojo anterior: ${ordenRojoAnterior === -Infinity ? 'NINGUNO' : ordenRojoAnterior}`);
      
      let total = 0;
      let conteo = 0;
      
      for (const item of allItems) {
        if (item.isSeparator) continue;
        if (item.verifiedRole !== 'Gerente') continue;
        
        const ordenItem = item.orden || 0;
        if (ordenItem > ordenRojoAnterior && ordenItem < ordenVerde) {
          total += Number(item.valor || 0);
          conteo++;
        }
      }
      
      console.log(`ðŸŸ¢ Total calculado: ${conteo} consignaciones = ${total}`);
      
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`âœ… Actualizando: ${separadorVerde.total} â†’ ${total}`);
      }
    }
    
    await batch.commit();
    console.log('âœ… RecÃ¡lculo completado');
    await loadConsignaciones();
    
  } catch (error) {
    console.error('âŒ Error:', error);
  }
}

async function probarNuevaLogicaCompleta() {
  console.log('ðŸ§ª PROBANDO NUEVA LÃ“GICA...');
  if (!selectedAccountId) {
    console.log('âŒ Selecciona una cuenta primero');
    return;
  }
  await nuevaLogicaTotalesVerdes();
  console.log('âœ… PRUEBA TERMINADA');
}

// Actualizar funciÃ³n existente para usar la nueva lÃ³gica
async function actualizarTotalesVerdes() {
  await nuevaLogicaTotalesVerdes();
}
// ===== LÃ“GICA CORREGIDA PARA TOTALES VERDES =====
async function logicaCorregidaTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('âŒ No hay cuenta seleccionada');
    return;
  }
  
  console.log('ðŸ”„ LÃ“GICA CORREGIDA: Recalculando separadores verdes...');
  
  try {
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`ðŸ“Š Total items: ${allItems.length}`);
    console.log('ðŸ“‹ Estructura de datos:');
    allItems.forEach((item, index) => {
      if (item.isSeparator) {
        console.log(`${index + 1}. ðŸ”´ðŸŸ¢ SEPARADOR ${item.type.toUpperCase()}: orden ${item.orden}, total: ${item.total || 0}`);
      } else {
        const estado = item.verifiedRole === 'Gerente' ? 'ðŸŸ¡ AMARILLO' : 
                     item.verifiedRole === 'Administrativo' ? 'âšª GRIS' : 'âš« BLANCO';
        console.log(`${index + 1}. ${estado}: ${item.valor}, ref: ${item.referencia}, orden: ${item.orden}`);
      }
    });
    
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`ðŸŸ¢ Separadores verdes: ${separadoresVerdes.length}`);
    
    if (separadoresVerdes.length === 0) return;
    
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`\nðŸŸ¢ Procesando: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      // LÃ“GICA CORREGIDA: Encontrar el separador rojo que estÃ¡ DESPUÃ‰S del verde
      let separadorRojoPosterior = null;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) > ordenVerde) {
          separadorRojoPosterior = item;
          break; // Tomar el primer rojo despuÃ©s del verde
        }
      }
      
      console.log(`ðŸ”´ Separador rojo posterior: ${separadorRojoPosterior ? 
        `${separadorRojoPosterior.id.substring(0, 8)}, orden: ${separadorRojoPosterior.orden}` : 'NINGUNO'}`);
      
      let total = 0;
      let conteo = 0;
      const consignacionesEncontradas = [];
      
      // LÃ“GICA CORREGIDA: Sumar consignaciones que estÃ¡n DESPUÃ‰S del rojo posterior
      for (const item of allItems) {
        if (item.isSeparator) continue;
        if (item.verifiedRole !== 'Gerente') continue;
        
        const ordenItem = item.orden || 0;
        let incluirConsignacion = false;
        
        if (separadorRojoPosterior) {
          // Hay rojo posterior: incluir consignaciones despuÃ©s del rojo
          incluirConsignacion = ordenItem > separadorRojoPosterior.orden;
          console.log(`  ðŸ” Evaluando consignaciÃ³n ${item.id.substring(0, 8)}: orden ${ordenItem} > ${separadorRojoPosterior.orden}? ${incluirConsignacion}`);
        } else {
          // No hay rojo posterior: incluir todas las consignaciones despuÃ©s del verde
          incluirConsignacion = ordenItem > ordenVerde;
          console.log(`  ðŸ” Evaluando consignaciÃ³n ${item.id.substring(0, 8)}: orden ${ordenItem} > ${ordenVerde}? ${incluirConsignacion}`);
        }
        
        if (incluirConsignacion) {
          total += Number(item.valor || 0);
          conteo++;
          consignacionesEncontradas.push({
            id: item.id.substring(0, 8),
            valor: item.valor,
            orden: ordenItem,
            referencia: item.referencia
          });
        }
      }
      
      console.log(`ðŸ“‹ Consignaciones encontradas:`, consignacionesEncontradas);
      console.log(`ðŸŸ¢ Total calculado: ${conteo} consignaciones = ${total}`);
      
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`âœ… Actualizando: ${separadorVerde.total} â†’ ${total}`);
      } else {
        console.log(`â„¹ï¸ Ya correcto: ${total}`);
      }
    }
    
    await batch.commit();
    console.log('âœ… RecÃ¡lculo completado');
    await loadConsignaciones();
    
  } catch (error) {
    console.error('âŒ Error:', error);
  }
}

async function probarLogicaCorregida() {
  console.log('ðŸ§ª PROBANDO LÃ“GICA CORREGIDA...');
  if (!selectedAccountId) {
    console.log('âŒ Selecciona una cuenta primero');
    return;
  }
  await logicaCorregidaTotalesVerdes();
  console.log('âœ… PRUEBA TERMINADA');
}
</script>
</body>
</html>
