<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sistema de Consignaciones - Blindado y Final</title>

  <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg: linear-gradient(135deg, #a8e6cf 0%, #dcedc1 100%);
      --card: rgba(255, 255, 255, 0.95);
      --accent: #4CAF50;
      --accent-hover: #45a049;
      --muted: #555;
      --border: #e8f5e8;
      --danger: #f44336;
      --ok: #4CAF50;
      --admin-gray: #e5e7eb;
      --manager-yellow: rgba(255, 193, 7, 0.2);
      --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      --shadow-hover: 0 12px 40px rgba(0, 0, 0, 0.15);
    }
    *{
      box-sizing:border-box;
      margin: 0;
      padding: 0;
    }
    
    body{
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin:0;
      background: var(--bg);
      color: #2e7d32;
    }
    
    #topbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:5px 10px;
      background: var(--card);
      backdrop-filter: blur(10px);
      border-bottom: 2px solid var(--border);
      box-shadow: var(--shadow);
      position: relative;
      z-index: 100;
    }
    
    .layout{
      display:flex;
      height:calc(100vh - 40px);
    }
    
    .sidebar{
      width:250px;
      padding:8px;
      background: var(--card);
      backdrop-filter: blur(10px);
      border-right: 2px solid var(--border);
      overflow:auto;
      box-shadow: var(--shadow);
    }
    
    .main{
      flex:1;
      padding:8px;
      overflow:auto;
    }
    h2,h3{
      margin:0 0 5px 0;
      color: #2e7d32;
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-size: 1em;
    }

    h3 {
      position: relative;
    }

    h3::after {
      content: '';
      position: absolute;
      bottom: -3px;
      left: 0;
      width: 30px;
      height: 2px;
      background: linear-gradient(90deg, var(--accent), #66BB6A);
      border-radius: 2px;
    }
    
    label{
      display:block;
      font-size:11px;
      color: var(--muted);
      margin-bottom:2px;
      font-weight: 600;
    }
    
    input[type=text], input[type=number], input[type=date], select, textarea, input[type=password]{
      width:100%;
      padding:5px 8px;
      border: 1px solid var(--border);
      border-radius:6px;
      background: rgba(255, 255, 255, 0.9);
      font-size: 12px;
      color: #2e7d32;
    }

    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
    }

    input:hover, select:hover, textarea:hover {
      border-color: #66BB6A;
    }
    
    textarea{resize:vertical}
    
    .btn{
      background: linear-gradient(135deg, var(--accent), #66BB6A);
      color:white;
      border:none;
      padding:6px 12px;
      border-radius:6px;
      cursor:pointer;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.2px;
      position: relative;
      overflow: hidden;
    }

    .btn:hover {
      background: linear-gradient(135deg, var(--accent-hover), #5cb85c);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.3);
    }
    
    .btn.ghost{
      background: rgba(255, 255, 255, 0.9);
      color: var(--accent);
      border: 2px solid var(--accent);
    }

    .btn.ghost:hover {
      background: var(--accent);
      color: white;
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.3);
    }
    
    .btn.danger{
      background: linear-gradient(135deg, var(--danger), #ef5350);
    }

    .btn.danger:hover {
      background: linear-gradient(135deg, #d32f2f, #e53935);
      box-shadow: 0 8px 25px rgba(244, 67, 54, 0.3);
    }
    
    .btn.success{
      background: linear-gradient(135deg, var(--ok), #66BB6A);
    }

    .btn.success:hover {
      background: linear-gradient(135deg, var(--accent-hover), #5cb85c);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.3);
    }
    
    .panel{
      background: var(--card);
      backdrop-filter: blur(10px);
      padding:8px;
      border-radius:8px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      margin-bottom:8px;
    }

    .panel:hover {
      box-shadow: var(--shadow-hover);
    }
    
    .account-item{
      padding:5px;
      border-radius:6px;
      border: 1px solid var(--border);
      margin-bottom:4px;
      cursor:pointer;
      background: rgba(255, 255, 255, 0.9);
      position: relative;
      backdrop-filter: blur(5px);
      font-size: 12px;
    }

    .account-item:hover {
      border-color: var(--accent);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.15);
    }
    
    .account-item.selected{
      border-left: 6px solid var(--accent);
      background: rgba(76, 175, 80, 0.1);
      box-shadow: 0 8px 25px rgba(76, 175, 80, 0.2);
    }
    
    .account-item .del-btn {
      position: absolute; 
      top: 12px; 
      right: 12px; 
      color: var(--danger); 
      font-size: 18px; 
      display: none; 
      padding: 6px;
      border-radius: 8px;
    }
    
    .account-item .del-btn:hover { 
      background: rgba(244, 67, 54, 0.1);
    }

    .flex-row{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap: wrap;
    }
    
    table{
      width:100%;
      border-collapse:collapse;
      font-size:14px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: var(--shadow);
      table-layout: fixed;
    }
    
    th,td{
      padding:4px 6px;
      border: 1px solid var(--border);
      background:transparent;
      text-align: center;
      font-size: 11px;
    }

    th {
      background: linear-gradient(135deg, var(--accent), #66BB6A);
      color: white;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.2px;
      font-size: 10px;
    }

    /* Filas sin verificar - fondo blanco */
    tr:nth-child(even) {
      background: transparent;
    }

    tr:hover {
      background: rgba(76, 175, 80, 0.08);
    }
    
    /* Filas verificadas por administrador - gris intenso */
    tr.verified-admin{
      background: var(--admin-gray) !important;
      border-left: 4px solid #6b7280;
    }
    
    tr.verified-admin:hover{
      background: #d1d5db !important;
    }
    
    /* Filas verificadas por gerente - amarillo */
    tr.verified-gerente{
      background: var(--manager-yellow) !important;
      border-left: 4px solid #FFC107;
    }
    
    tr.verified-gerente:hover{
      background: rgba(255, 193, 7, 0.3) !important;
    }
    
    /* Separadores */
    tr.separator{
      font-weight:700;
      text-align:center;
      font-size: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    tr.sep-green{
      background: linear-gradient(135deg, #d1fae5, #a7f3d0)!important; 
      color: #065f46;
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.2);
    }
    
    tr.sep-red{
      background: linear-gradient(135deg, #fee2e2, #fecaca)!important; 
      color: #991b1b;
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.2);
    }
    
    /* Foco teclado */
    tr.keyboard-focus { 
      outline: 3px solid var(--accent); 
      z-index: 10; 
      position: relative;
      box-shadow: 0 0 0 6px rgba(76, 175, 80, 0.2);
    }

    .muted{
      color:var(--muted);
      font-size:14px;
      font-style: italic;
    }
    
    .top-totals{
      display:flex;
      gap:5px;
      align-items:center;
      flex-wrap: wrap;
    }
    
    .top-totals .card{
      padding:3px 6px;
      border-radius:6px;
      border: 1px solid var(--border);
      background: var(--card);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }

    .top-totals .card:hover {
      box-shadow: var(--shadow-hover);
    }
    
    .small{
      font-size:9px;
      color: var(--muted);
      font-weight: 500;
    }
    
    .modal{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(5px);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:999;
    }
    
    .modal .card{
      width:750px;
      max-width:96%;
      padding:25px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    .hidden{display:none}
    
    .gear{
      cursor:pointer;
      padding:8px;
      border-radius:10px;
      border: 2px solid var(--border);
      background: var(--card);
      font-size: 16px;
    }

    .gear:hover {
      border-color: var(--accent);
      background: rgba(76, 175, 80, 0.1);
    }
    
    /* Nuevo modal gen√©rico */
    #generic-modal .card{
      width:500px!important; 
      max-width:96%; 
      padding:25px; 
      position:relative;
      border-radius: 20px;
      overflow: hidden;
    }
    
    #modal-title{
      color: var(--accent); 
      margin-bottom:20px;
      font-size: 1.4em;
      font-weight: 600;
      text-align: center;
    }
    
    #modal-body{
      margin-bottom:20px;
      line-height: 1.6;
      color: #2e7d32;
    }
    
    #modal-password-input{
      margin-top:10px;
    }

    /* ESTILO DIN√ÅMICO DE ADVERTENCIA MODERNIZADO */
    .warning-icon {
        font-size: 36px;
        color: var(--danger);
        margin-right: 15px;
    }
    
    .warning-title-container {
        display: flex;
        align-items: center;
        margin-bottom: 20px;
        padding: 15px 0;
        border-bottom: 2px solid var(--border);
        background: rgba(244, 67, 54, 0.05);
        border-radius: 10px;
        padding: 15px;
    }
    
    .warning-message {
        font-weight: 500;
        line-height: 1.6;
        padding-top: 10px;
        color: #2e7d32;
        background: rgba(76, 175, 80, 0.05);
        padding: 15px;
        border-radius: 10px;
        border-left: 4px solid var(--accent);
    }

    /* Modal de datos grandes */
    #data-modal {
      display: none;
      position: fixed;
      z-index: 1001;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(8px);
    }

    #data-modal .modal-content {
      background: linear-gradient(135deg, #a8e6cf 0%, #dcedc1 100%);
      margin: 5% auto;
      padding: 0;
      border-radius: 20px;
      width: 80%;
      max-width: 600px;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }

    #data-modal .modal-header {
      background: linear-gradient(135deg, #4CAF50, #66BB6A);
      color: white;
      padding: 25px;
      text-align: center;
      position: relative;
    }

    #data-modal .modal-header h2 {
      margin: 0;
      font-size: 2em;
      font-weight: 700;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    #data-modal .modal-header .close {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 35px;
      font-weight: bold;
      cursor: pointer;
      color: white;
    }

    #data-modal .modal-header .close:hover {
      opacity: 0.8;
    }

    #data-modal .modal-body {
      padding: 40px;
      text-align: center;
      background: rgba(255, 255, 255, 0.95);
    }

    #data-modal .data-value {
      font-size: 4em;
      font-weight: 900;
      color: #2e7d32;
      text-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      margin: 20px 0;
      font-family: 'Courier New', monospace;
      letter-spacing: 2px;
    }

    #data-modal .data-label {
      font-size: 1.3em;
      color: #555;
      font-weight: 600;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #data-modal .data-icon {
      font-size: 3em;
      margin-bottom: 20px;
      opacity: 0.8;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .layout {
        flex-direction: column;
        height: auto;
      }

      .sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 2px solid var(--border);
      }

      .top-totals {
        flex-direction: column;
        gap: 10px;
      }

      .flex-row {
        flex-direction: column;
        gap: 8px;
      }

      .modal .card {
        width: 95%;
        padding: 20px;
      }

      table {
        font-size: 12px;
      }

      th, td {
        padding: 8px 4px;
      }

      #data-modal .modal-content {
        width: 95%;
        margin: 10% auto;
      }

      #data-modal .data-value {
        font-size: 2.5em;
      }

      #data-modal .modal-body {
        padding: 25px;
      }
    }
  </style>
</head>
<body>

  <div id="topbar">
    <div style="display:flex;gap:6px;align-items:center">
      <strong style="font-size: 1em; color: #2e7d32; text-shadow: 0 2px 4px rgba(0,0,0,0.1);">üí∞ Sistema de Consignaciones</strong>
      <div class="small" style="background: rgba(76, 175, 80, 0.1); padding: 1px 5px; border-radius: 10px; color: #2e7d32; font-weight: 600;">Gerencia</div>
    </div>

    <div class="top-totals">
      <div class="card small">
        <div class="muted">üíµ Total general</div>
        <div id="total-general" style="font-weight: 700; color: #2e7d32; font-size: 0.8em;">0</div>
      </div>
      <div class="card small">
        <div class="muted">üè¶ Total cuenta actual</div>
        <div id="total-cuenta" style="font-weight: 700; color: #2e7d32; font-size: 0.8em;">0</div>
      </div>
      <div class="card small">
        <div class="muted">üë§ Usuario</div>
        <div id="user-info" style="font-weight: 600; color: #2e7d32; font-size: 0.8em;">...</div>
      </div>
      <button id="btn-back" class="btn ghost">‚¨ÖÔ∏è Atr√°s</button>
      <button id="open-options" class="btn ghost">‚öôÔ∏è Opciones</button>
      <button id="logout" class="btn ghost">üö™ Salir</button>
    </div>
  </div>

  <div class="layout">
    <div class="sidebar">
      <h3>üîç Buscar / Cuentas</h3>
      <label>üè∑Ô∏è Buscar por nombre</label>
      <input id="search-name" type="text" placeholder="Nombre de cuenta...">
      <label style="margin-top:8px">üî¢ Buscar por n√∫mero</label>
      <input id="search-account" type="text" placeholder="N√∫mero de cuenta...">

      <div style="margin-top:6px" class="panel">
        <h4 style="margin-bottom:5px; color: #2e7d32; font-weight: 600; font-size: 0.9em;">‚ûï Nueva cuenta</h4>
        <label>üìù Nombre</label>
        <input id="new-account-name" type="text" placeholder="Nombre">
        <label style="margin-top:4px">üî¢ N√∫mero</label>
        <input id="new-account-number" type="text" placeholder="N√∫mero">
        <div style="margin-top:5px" class="flex-row">
          <button id="add-account" class="btn" style="flex:1">‚úÖ Agregar</button>
        </div>
      </div>

      <div>
        <div class="muted" style="margin-bottom:4px; font-weight: 600; color: #2e7d32; font-size: 10px;">üìã Lista de Cuentas</div>
        <div id="accounts-list" style="max-height:50vh;overflow:auto;padding-right:5px;"></div>
      </div>
    </div>

    <div class="main">
      <div class="panel">
        <h3>üí∞ Agregar consignaci√≥n</h3>
        <div id="selected-account-info" class="muted" style="margin-bottom:5px; padding: 4px; background: rgba(76, 175, 80, 0.1); border-radius: 4px; border-left: 2px solid var(--accent); font-size: 10px;">Ninguna cuenta seleccionada</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <div style="flex:1;min-width:200px;">
            <label>üìÖ FECHA DE CONSIGNACI√ìN</label>
            <div style="display:flex;gap:5px;align-items:center;flex-wrap:wrap;margin-bottom:4px;">
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="dateOpt" value="today"> üìÖ Hoy</label>
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="dateOpt" value="yesterday"> üìÖ Ayer</label>
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="dateOpt" value="daybefore"> üìÖ Antier</label>
              <label style="margin-left:10px;font-weight:600;">üìù Manual:</label>
            </div>
            <input id="date-picker" type="date">
          </div>
          <div style="flex:1;min-width:200px;">
            <label>üëÅÔ∏è FECHA DE OBSERVACI√ìN</label>
            <div style="display:flex;gap:5px;align-items:center;flex-wrap:wrap;margin-bottom:4px;">
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="obsOpt" value="today"> üìÖ Hoy</label>
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="obsOpt" value="yesterday"> üìÖ Ayer</label>
              <label style="display:flex;align-items:center;gap:5px;"><input type="radio" name="obsOpt" value="daybefore"> üìÖ Antier</label>
              <label style="margin-left:10px;font-weight:600;">üìù Manual:</label>
            </div>
            <input id="obsdate-picker" type="date">
          </div>
        </div>
        <div style="margin-top:8px;display:flex;gap:6px;align-items:end;flex-wrap:wrap;">
          <div style="flex:1;min-width:120px;">
            <label>üíµ VALOR (COP)</label>
            <input id="valor" type="text" placeholder="Ingrese el valor..." style="font-size:12px;font-weight:600;" maxlength="15">
          </div>
          <div style="flex:1;min-width:120px;">
            <label>üìù REFERENCIA</label>
            <input id="referencia" type="text" placeholder="Ingrese la referencia..." style="font-size:12px;font-weight:600;text-transform:uppercase;" maxlength="50">
          </div>
          <div style="min-width:140px;">
            <button id="add-consign" class="btn" style="width:100%;padding:5px;font-size:10px;">‚úÖ Agregar Consignaci√≥n</button>
          </div>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center; flex-wrap:wrap; gap:5px;">
          <h3 style="margin:0">üìä Movimientos</h3>
          <div style="display:flex; gap:4px; flex-wrap:wrap;">
            <button id="btn-export-excel" class="btn success">üì• Descargar Cuenta</button>
            <button id="btn-manual-adjustments" class="btn" style="background: linear-gradient(135deg, #ff9800, #ffb74d); color: white;">‚öôÔ∏è Ajustes</button>
            <button id="btn-export-master" class="btn success" style="display:none; background:linear-gradient(135deg, #7c3aed, #8b5cf6); color:white;">üì• Descargar Maestra (G)</button>

            <div style="width:2px; background:var(--border); margin:0 8px; border-radius:1px;"></div>
            <button id="btn-verify" class="btn">‚úÖ Verificado</button>
            <button id="btn-unverify" class="btn ghost">‚ùå Desverificar</button>
            <button id="btn-delete" class="btn danger" style="display:none">üóëÔ∏è Eliminar</button>
            <button id="btn-sumar" class="btn ghost">‚ûï Sumar</button>
            <button id="btn-cuadrar" class="btn ghost" style="display:none; border:2px solid var(--accent); color:var(--accent); font-weight:600;">‚úÖ Cuadrar (Corte)</button>
          </div>
        </div>

        <div style="margin-top:6px;max-height:58vh;overflow:auto;border-radius:6px;width:100%;" tabindex="0" id="table-container"></div>
          <table>
            <thead>
              <tr>
                <th>‚òëÔ∏è Sel</th>
                <th>üìÖ FECHA</th>
                <th>üíµ VALOR</th>
                <th>ÔøΩ REF</th>
                <th>ÔøΩ Ô∏è FECHA OBS</th>
                <th>üìã ESTADO</th>
              </tr>
            </thead>
            <tbody id="consigns-body"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <div id="modal-options" class="modal hidden">
    <div class="panel card" style="width:750px;max-width:96%">
      <h3 style="text-align:center; color:#2e7d32; margin-bottom:25px;">‚öôÔ∏è Opciones de Acceso</h3>
      <div style="margin-top:20px; display:flex; gap:20px; justify-content:center;">
        <label style="display:flex; align-items:center; gap:8px; padding:10px 20px; border:2px solid var(--border); border-radius:10px; cursor:pointer;">
          <input type="radio" name="sessionRole" value="Administrativo" checked> 
          <span style="font-weight:600;">üë§ Administrativo</span>
        </label>
        <label style="display:flex; align-items:center; gap:8px; padding:10px 20px; border:2px solid var(--border); border-radius:10px; cursor:pointer;">
          <input type="radio" name="sessionRole" value="Gerente"> 
          <span style="font-weight:600;">üëë Gerente</span>
        </label>
      </div>
      <div id="manager-pass-area" class="hidden" style="margin-top:20px">
        <label>üîê Clave Gerente</label>
        <input id="manager-pass" type="password" placeholder="Ingrese la clave de gerente">
      </div>
      <div style="margin-top:20px;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:15px;">
        <div style="display:flex;align-items:center;gap:10px;">
          <span class="gear" id="gear-change" title="Cambiar clave">‚öôÔ∏è</span>
          <small class="muted" style="font-weight:500;">Configurar clave</small>
        </div>
        <div style="display:flex;gap:10px;">
          <button id="options-continue" class="btn">‚úÖ Continuar</button>
          <button id="options-cancel" class="btn ghost">‚ùå Cancelar</button>
        </div>
      </div>
      <div id="gear-panel" class="hidden" style="margin-top:20px; padding:15px; background:rgba(76,175,80,0.05); border-radius:10px; border:2px solid var(--border);">
        <label>üîë Nueva clave Gerente</label>
        <input id="new-manager-pass" type="text" placeholder="Ingrese nueva clave">
        <div style="margin-top:15px;display:flex;gap:10px;justify-content:flex-end">
          <button id="save-manager-pass" class="btn">üíæ Guardar</button>
          <button id="cancel-gear" class="btn ghost">‚ùå Cerrar</button>
        </div>
      </div>
    </div>
  </div>

  <div id="generic-modal" class="modal hidden">
    <div class="panel card">
        <h4 id="modal-title" style="margin-top:0;"></h4>
        <div id="modal-body"></div>
        <div id="modal-password-area" class="hidden" style="margin-top:20px">
            <label>üîê CLAVE DE GERENTE</label>
            <input id="modal-password-input" type="password" placeholder="Ingrese la clave de gerente">
        </div>
        <div style="margin-top:25px;display:flex;gap:12px;justify-content:flex-end">
            <button id="modal-cancel-btn" class="btn ghost hidden">‚ùå Cancelar</button>
            <button id="modal-ok-btn" class="btn">‚úÖ Aceptar</button>
        </div>
    </div>
  </div>

  <!-- Modal de Datos Grandes -->
  <div id="data-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="data-modal-title">Informaci√≥n</h2>
        <span class="close" onclick="closeDataModal()">&times;</span>
      </div>
      <div class="modal-body">
        <div id="data-modal-icon" class="data-icon">üí∞</div>
        <div id="data-modal-label" class="data-label">Total</div>
        <div id="data-modal-value" class="data-value">0</div>
      </div>
    </div>
  </div>

  <!-- Modal de Ajustes Manuales -->
  <div id="manual-adjustments-modal" class="modal hidden">
    <div class="panel card" style="width:900px;max-width:96%;max-height:90vh;overflow:auto;">
      <h3 style="text-align:center; color:#ff9800; margin-bottom:25px; display:flex; align-items:center; justify-content:center; gap:10px;">
        ‚öôÔ∏è Ajustes Manuales Extraordinarios
        <span style="font-size:0.7em; background:rgba(255,152,0,0.1); padding:2px 8px; border-radius:15px; color:#e65100;">Solo Gerencia</span>
      </h3>
      
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:20px; margin-bottom:20px;">
        
        <!-- Panel Izquierdo: Modificar Totales Verdes -->
        <div class="panel" style="background: rgba(76, 175, 80, 0.05); border: 2px solid #4CAF50;">
          <h4 style="color:#4CAF50; margin-bottom:15px; display:flex; align-items:center; gap:8px;">
            üü¢ Modificar Totales Verdes
          </h4>
          
          <div style="margin-bottom:15px;">
            <label>Seleccionar Separador Verde</label>
            <select id="green-separator-select" style="width:100%;">
              <option value="">-- Seleccione un separador verde --</option>
            </select>
          </div>
          
          <div style="margin-bottom:15px;">
            <label>Nuevo Total (COP)</label>
            <input id="new-green-total" type="text" placeholder="Ingrese el nuevo total..." style="font-weight:600;">
          </div>
          
          <div style="margin-bottom:15px;">
            <label>Motivo del Ajuste</label>
            <textarea id="green-adjustment-reason" placeholder="Explique por qu√© se modifica este total..." rows="3" style="resize:vertical;"></textarea>
          </div>
          
          <button id="btn-update-green-total" class="btn" style="width:100%; background:#4CAF50;">
            ‚úÖ Actualizar Total Verde
          </button>
        </div>

        <!-- Panel Derecho: Agregar Consignaci√≥n Extraordinaria -->
        <div class="panel" style="background: rgba(33, 150, 243, 0.05); border: 2px solid #2196F3;">
          <h4 style="color:#2196F3; margin-bottom:15px; display:flex; align-items:center; gap:8px;">
            ‚ûï Consignaci√≥n Extraordinaria
          </h4>
          
          <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:15px;">
            <div>
              <label>üìÖ Fecha Consignaci√≥n</label>
              <input id="extra-consign-date" type="date">
            </div>
            <div>
              <label>üëÅÔ∏è Fecha Observaci√≥n</label>
              <input id="extra-obs-date" type="date">
            </div>
          </div>
          
          <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:15px;">
            <div>
              <label>üíµ Valor (COP)</label>
              <input id="extra-valor" type="text" placeholder="Valor..." style="font-weight:600;">
            </div>
            <div>
              <label>üìù Referencia</label>
              <input id="extra-referencia" type="text" placeholder="Referencia..." style="text-transform:uppercase; font-weight:600;">
            </div>
          </div>
          
          <div style="margin-bottom:15px;">
            <label>üîç Estado Inicial</label>
            <select id="extra-verified-role">
              <option value="">Sin verificar</option>
              <option value="Administrativo">Verificado por Administrativo</option>
              <option value="Gerente">Verificado por Gerente</option>
            </select>
          </div>
          
          <div style="margin-bottom:15px;">
            <label>üìã Motivo de la Consignaci√≥n</label>
            <textarea id="extra-consign-reason" placeholder="Explique por qu√© se agrega esta consignaci√≥n extraordinaria..." rows="3" style="resize:vertical;"></textarea>
          </div>
          
          <button id="btn-add-extra-consign" class="btn" style="width:100%; background:#2196F3;">
            ‚ûï Agregar Consignaci√≥n
          </button>
        </div>
      </div>

      <!-- Panel Inferior: Historial de Ajustes -->
      <div class="panel" style="background: rgba(156, 39, 176, 0.05); border: 2px solid #9C27B0;">
        <h4 style="color:#9C27B0; margin-bottom:15px; display:flex; align-items:center; gap:8px;">
          üìã Historial de Ajustes Recientes
        </h4>
        <div id="adjustments-history" style="max-height:200px; overflow:auto; font-size:12px;">
          <div class="muted" style="text-align:center; padding:20px;">
            No hay ajustes registrados para esta cuenta
          </div>
        </div>
      </div>

      <!-- Botones de Control -->
      <div style="margin-top:25px; display:flex; gap:15px; justify-content:flex-end;">
        <button id="manual-adjustments-close" class="btn ghost">‚ùå Cerrar</button>
        <button id="btn-recalculate-all" class="btn" style="background: linear-gradient(135deg, #ff9800, #ffb74d);">
          üîÑ Recalcular Todo
        </button>
      </div>
    </div>
  </div>

<script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.10.0/firebase-firestore-compat.js"></script>
<script>
/* CONFIGURACI√ìN FIREBASE */
const firebaseConfig = {
  apiKey:"AIzaSyChvezwN6DrYXdnBvGLxnjhi4I9xUaxKfU",
  authDomain:"lazapateria-c4157.firebaseapp.com",
  projectId:"lazapateria-c4157",
  storageBucket:"lazapateria-c4157.firebasestorage.app",
  messagingSenderId:"300241769138",
  appId:"1:300241769138:web:8ca1847de3c4fb5042afab"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

/* ESTADO GLOBAL */
const usuario = JSON.parse(localStorage.getItem('datosUsuario') || 'null');
if(!usuario){ showModal('Error', 'No hay sesi√≥n activa.', false, ()=>location.href='index.html'); }
if(usuario.permisos !== 'Administrador'){ showModal('Error', 'Acceso denegado.', false, ()=>location.href='index.html'); }

$('user-info').textContent = usuario.usuario;
$('logout').onclick = ()=>{ localStorage.removeItem('datosUsuario'); location.href='index.html'; };
$('btn-back').onclick = ()=>{ location.href='paneldecuentas.html'; };

let sessionRole = 'Administrativo';
let managerPass = '0000'; 
const settingsRef = db.collection('settings').doc('managerPassword');

function loadManagerPass() {
    settingsRef.onSnapshot(doc => {
        if (doc.exists && doc.data().password) {
            managerPass = doc.data().password;
        } else {
            // Si el documento no existe, lo creamos con una clave por defecto
            if (!doc.exists) {
                settingsRef.set({ password: '0000' }).catch(e => console.error("Error creando clave por defecto:", e));
            }
            managerPass = '0000'; 
        }
    }, error => {
        console.error("Error al cargar la clave de gerente:", error);
    });
}
loadManagerPass();

let selectedAccountId = null;
let selectedAccountName = "SinNombre";
let currentConsignsSnapshot = []; 
let selectedConsignIds = new Set(); // Almacenamiento local de IDs seleccionados (para persistencia en UI)

/* UTILIDADES */
function $(id){ return document.getElementById(id); }
function fmtCOP(n){ return new Intl.NumberFormat('es-CO').format(Number(n||0)); }

// Funci√≥n para verificar si una referencia ya existe en cualquier cuenta
async function checkReferenciaExists(referencia) {
  if (!referencia || referencia.trim() === '') return { exists: false };
  
  try {
    // Buscar en todas las cuentas
    const cuentasSnapshot = await db.collection('cuentas').get();
    
    for (const cuentaDoc of cuentasSnapshot.docs) {
      const consignacionesSnapshot = await db.collection('cuentas')
        .doc(cuentaDoc.id)
        .collection('consignaciones')
        .where('referencia', '==', referencia.trim())
        .get();
      
      if (!consignacionesSnapshot.empty) {
        const cuentaData = cuentaDoc.data();
        return { 
          exists: true, 
          cuentaId: cuentaDoc.id,
          cuentaNombre: cuentaData.name || 'Cuenta sin nombre'
        };
      }
    }
    
    return { exists: false };
  } catch (error) {
    console.error('Error verificando referencia:', error);
    throw new Error('Error al verificar la referencia: ' + error.message);
  }
}
function parseDateRadio(name, pickerId){ 
  const opts = document.getElementsByName(name); 
  let sel = null; 
  for(const r of opts) if(r.checked) sel = r.value; 
  
  // Crear fechas en zona horaria de Colombia (UTC-5)
  const now = new Date();
  const colombiaOffset = -5 * 60; // UTC-5 en minutos
  const localOffset = now.getTimezoneOffset();
  const colombiaTime = new Date(now.getTime() + (localOffset + colombiaOffset) * 60000);
  
  if(sel === 'today') return colombiaTime; 
  if(sel === 'yesterday'){ 
    const d = new Date(colombiaTime); 
    d.setDate(d.getDate()-1); 
    return d; 
  } 
  if(sel === 'daybefore'){ 
    const d = new Date(colombiaTime); 
    d.setDate(d.getDate()-2); 
    return d; 
  } 
  
  // Si no hay radio button seleccionado, usar el date picker
  const v = $(pickerId).value; 
  if(v) {
    // Crear fecha local correctamente para Colombia
    const parts = v.split('-');
    const selectedDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    // Ajustar a hora de Colombia (mediod√≠a para evitar problemas de zona horaria)
    selectedDate.setHours(12, 0, 0, 0);
    return selectedDate;
  }
  
  return null; 
}

/* FUNCIONES DE MODAL GEN√âRICO */
function showModal(title, message, isConfirm, onOk, onCancel){
    $('modal-title').textContent = title;
    $('modal-body').innerHTML = message;
    $('modal-password-area').classList.add('hidden');
    $('modal-password-input').value = '';

    $('modal-cancel-btn').textContent = "Cancelar";
    $('modal-cancel-btn').classList.toggle('hidden', !isConfirm);
    $('modal-ok-btn').textContent = "Aceptar";
    $('modal-ok-btn').onclick = () => { $('generic-modal').classList.add('hidden'); if(onOk) onOk(); };
    $('modal-cancel-btn').onclick = () => { $('generic-modal').classList.add('hidden'); if(onCancel) onCancel(); };

    $('generic-modal').classList.remove('hidden');
}

function showPasswordModal(title, message){
    return new Promise((resolve, reject) => {
        $('modal-title').textContent = title;
        $('modal-body').textContent = message;
        $('modal-password-area').classList.remove('hidden');
        $('modal-password-input').value = '';
        $('modal-password-input').focus();
        
        $('modal-cancel-btn').textContent = "Cancelar";
        $('modal-cancel-btn').classList.remove('hidden');
        $('modal-ok-btn').textContent = "Aceptar";

        const checkPass = () => {
            const pass = $('modal-password-input').value;
            if (pass === managerPass) {
                $('generic-modal').classList.add('hidden');
                resolve(true);
            } else {
                showModal('Error de Seguridad', 'Clave incorrecta. Intente de nuevo.', false);
                $('modal-password-input').value = '';
                $('modal-password-input').focus();
            }
        };

        const handleCancel = () => {
            $('generic-modal').classList.add('hidden');
            reject(new Error("Acci√≥n cancelada."));
        };

        $('modal-ok-btn').onclick = checkPass;
        $('modal-cancel-btn').onclick = handleCancel;
        
        // Permite usar Enter en el input de contrase√±a
        $('modal-password-input').onkeydown = (e) => {
            if(e.key === 'Enter') { e.preventDefault(); checkPass(); }
        };

        $('generic-modal').classList.remove('hidden');
    }).catch(e => {
        if(e.message !== "Acci√≥n cancelada.") {
            showModal('Error', e.message, false);
        }
        throw e; // Re-throw to propagate rejection
    });
}

/** Muestra advertencia din√°mica (Cierre/Cuadre) y pregunta si continuar */
function showSuperWarning(title, message, onContinue) {
    return new Promise((resolve) => {
        $('modal-title').innerHTML = `
            <div class="warning-title-container">
                <span class="warning-icon">üö®</span>
                <span style="font-size: 1.2em; font-weight: bold; color: var(--danger);">${title}</span>
            </div>
        `;
        $('modal-body').innerHTML = `<p class="warning-message">${message}</p>`;
        $('modal-password-area').classList.add('hidden');
        
        $('modal-cancel-btn').textContent = "Cancelar Acci√≥n";
        $('modal-cancel-btn').classList.remove('hidden');
        
        $('modal-ok-btn').textContent = "S√≠, Continuar Agregando";
        $('modal-ok-btn').classList.remove('danger');
        
        $('modal-ok-btn').onclick = () => { 
            $('generic-modal').classList.add('hidden'); 
            resolve(true);
        };
        $('modal-cancel-btn').onclick = () => { 
            $('generic-modal').classList.add('hidden'); 
            resolve(false);
        };

        $('generic-modal').classList.remove('hidden');
    });
}

/** Funci√≥n para Inserci√≥n Retroactiva (Doble Clic) - DESHABILITADA
 * Usar el modal de ajustes manuales en su lugar
 */
/*
async function handleDoubleClick(clickedConsign, index) {
    if (sessionRole !== 'Gerente') {
        showModal('Acceso Denegado', 'Solo el **Gerente** puede insertar movimientos retroactivos.', false);
        return;
    }
    
    if (clickedConsign.isSeparator || !clickedConsign.verifiedRole) {
         showModal('Atenci√≥n', 'Solo puede insertar antes de consignaciones verificadas.', false);
         return;
    }
    
    // 3. Preparar datos
    const clickedDate = clickedConsign.fecha.toDate();
    const clickedTimestamp = clickedDate.getTime();
    // Obtener fecha actual en zona horaria de Colombia
    const now = new Date();
    const colombiaOffset = -5 * 60; // UTC-5 en minutos
    const localOffset = now.getTimezoneOffset();
    const colombiaTime = new Date(now.getTime() + (localOffset + colombiaOffset) * 60000);
    const today = colombiaTime.toISOString().substring(0, 10);
    const clickedDateStr = clickedDate.toLocaleDateString('es-CO');

    // 4. Configurar el Modal Din√°mico con inputs de Fecha y Observaci√≥n
    $('modal-title').innerHTML = `
        <div class="warning-title-container">
            <span class="warning-icon" style="color: var(--accent);">üìù</span> 
            <span style="font-size: 1.2em; font-weight: bold; color: var(--accent);">Inserci√≥n Retroactiva</span>
        </div>
    `;
    $('modal-body').innerHTML = `
        <p class="warning-message">
            El nuevo movimiento se insertar√° con la fecha y valor que especifique, aparecer√° **justo encima** de la consignaci√≥n del **${clickedDateStr}** y se marcar√° como Verificado (Gerente).
        </p>
        <div style="display:flex; gap:10px;">
            <div style="flex:1">
                <label style="font-size:13px; color:var(--muted); margin-bottom:6px;">FECHA CONSIGNACI√ìN:</label>
                <input type="date" id="modal-retro-fecha" required value="${today}" style="width: 100%;">
            </div>
            <div style="flex:1">
                <label style="font-size:13px; color:var(--muted); margin-bottom:6px;">FECHA DE OBSERVACI√ìN (Opcional):</label>
                <input type="date" id="modal-retro-obsdate" style="width: 100%;">
            </div>
        </div>
        <div style="margin-top:12px;">
            <label style="font-size:13px; color:var(--muted); margin-bottom:6px;">VALOR (COP) a insertar:</label>
            <input type="number" id="modal-retro-valor" placeholder="0.00" style="padding: 8px; border: 1px solid var(--border); border-radius: 6px; width: 100%;">
        </div>
        <div style="margin-top:12px;">
            <label style="font-size:13px; color:var(--muted); margin-bottom:6px;">REFERENCIA:</label>
            <input type="text" id="modal-retro-referencia" placeholder="Ingrese la referencia..." style="padding: 8px; border: 1px solid var(--border); border-radius: 6px; width: 100%; text-transform: uppercase;" maxlength="50">
        </div>
    `;
    
    $('modal-password-area').classList.add('hidden');
    $('modal-cancel-btn').textContent = "Cancelar";
    $('modal-cancel-btn').classList.remove('hidden');
    $('modal-ok-btn').textContent = "Insertar";

    // 5. L√≥gica de Aceptar
    const insertAction = async () => {
        const valorInput = document.getElementById('modal-retro-valor');
        const referenciaInput = document.getElementById('modal-retro-referencia');
        const fechaInput = document.getElementById('modal-retro-fecha');
        const obsdateInput = document.getElementById('modal-retro-obsdate');
        
        const valor = Number(valorInput.value);
        const referencia = referenciaInput.value.trim();
        const fechaStr = fechaInput.value;
        const obsdateStr = obsdateInput.value;

        if (isNaN(valor) || valor <= 0) {
            showModal('Error', 'Valor inv√°lido o no ingresado. Intente de nuevo.', false);
            return handleDoubleClick(clickedConsign, index); 
        }
        if (!referencia) {
            showModal('Error', 'La referencia es obligatoria. Intente de nuevo.', false);
            return handleDoubleClick(clickedConsign, index);
        }
        if (!fechaStr) {
            showModal('Error', 'Debe seleccionar una fecha para la consignaci√≥n.', false);
            return handleDoubleClick(clickedConsign, index);
        }

        // Verificar que la referencia no exista
        try {
            const referenciaCheck = await checkReferenciaExists(referencia);
            if (referenciaCheck.exists) {
                showModal('Error', `La referencia "${referencia}" ya fue utilizada en la cuenta "${referenciaCheck.cuentaNombre}".`, false);
                return handleDoubleClick(clickedConsign, index);
            }
        } catch (error) {
            showModal('Error', error.message, false);
            return handleDoubleClick(clickedConsign, index);
        }

        // Crear fechas correctamente para Colombia
        const fechaParts = fechaStr.split('-');
        const userFecha = new Date(parseInt(fechaParts[0]), parseInt(fechaParts[1]) - 1, parseInt(fechaParts[2]), 12, 0, 0, 0);
        
        let userObsdate = null;
        if (obsdateStr) {
            const obsParts = obsdateStr.split('-');
            userObsdate = new Date(parseInt(obsParts[0]), parseInt(obsParts[1]) - 1, parseInt(obsParts[2]), 12, 0, 0, 0);
        }
        
        // RETROACTIVA: Con cortes arriba, insertar encima de la fila clickeada
        // Encontrar la posici√≥n de la consignaci√≥n clickeada
        const clickedIndex = currentConsignsSnapshot.findIndex(c => c.id === clickedConsign.id);
        let nuevoOrden;
        
        if (clickedIndex > 0) {
          // Hay una fila encima, insertar entre esa fila y la clickeada
          const filaEncima = currentConsignsSnapshot[clickedIndex - 1];
          const filaClickeada = currentConsignsSnapshot[clickedIndex];
          
          const ordenEncima = filaEncima.orden || 0;
          const ordenClickeada = filaClickeada.orden || 0;
          
          // Usar el promedio entre los dos √≥rdenes (con decimales para precisi√≥n)
          nuevoOrden = (ordenEncima + ordenClickeada) / 2;
        } else {
          // Es la primera fila visible, insertar justo despu√©s del √∫ltimo corte rojo
          // Buscar el √∫ltimo separador rojo
          let ultimoCorteRojo = null;
          currentConsignsSnapshot.forEach(item => {
            if (item.isSeparator && item.type === 'red') {
              if (!ultimoCorteRojo || (item.orden || 0) < (ultimoCorteRojo.orden || 0)) {
                ultimoCorteRojo = item;
              }
            }
          });
          
          if (ultimoCorteRojo) {
            // Insertar justo despu√©s del corte rojo
            nuevoOrden = ultimoCorteRojo.orden + 0.1;
          } else {
            // No hay cortes, usar orden menor que la primera consignaci√≥n
            const ordenClickeada = clickedConsign.orden || 0;
            nuevoOrden = ordenClickeada - 0.1;
          }
        }
        
        console.log('üîÑ INSERCI√ìN RETROACTIVA (ENCIMA DE FILA):');
        console.log('  - √çndice clickeado:', clickedIndex);
        console.log('  - Orden clickeado:', clickedConsign.orden);
        console.log('  - Nuevo orden calculado:', nuevoOrden);
        console.log('  - Fecha usuario:', userFecha);
        console.log('  - Referencia:', referencia);
        
        try {
            await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').add({ 
                fecha: firebase.firestore.Timestamp.fromDate(userFecha), // Fecha seleccionada por el usuario
                obsdate: userObsdate ? firebase.firestore.Timestamp.fromDate(userObsdate) : null,
                valor: valor, 
                referencia: referencia.toUpperCase(), // Convertir a may√∫sculas
                verifiedBy: usuario.usuario, 
                verifiedRole: 'Gerente',
                orden: nuevoOrden // Campo dedicado para ordenamiento manual
            });
            
            // REC√ÅLCULO AUTOM√ÅTICO DESPU√âS DE INSERCI√ìN RETROACTIVA
            const nuevaConsignacion = {
              orden: nuevoOrden,
              valor: valor,
              verifiedRole: 'Gerente' // Inserci√≥n retroactiva se marca como verificada por Gerente
            };
            await actualizarTotalesVerdes(); // Nueva l√≥gica simple
            
            // Esperar un momento para que se actualice Firebase y luego actualizar la UI
            setTimeout(() => {
              updateSelectedTotals();
            }, 1000);
            
            console.log('‚úÖ Consignaci√≥n retroactiva agregada exitosamente con orden:', nuevoOrden);
            
        } catch(e) { 
            showModal('Error', 'Error al insertar consignaci√≥n: '+e.message, false); 
        } finally {
            $('generic-modal').classList.add('hidden');
        }
    };

    $('modal-ok-btn').onclick = insertAction;
    $('modal-cancel-btn').onclick = () => {
        $('generic-modal').classList.add('hidden');
    };
    
    $('generic-modal').classList.remove('hidden');
    document.getElementById('modal-retro-valor').focus();
    
    // Event listener para convertir referencia a may√∫sculas en el modal
    document.getElementById('modal-retro-referencia').addEventListener('input', function(e) {
        e.target.value = e.target.value.toUpperCase();
    });
}
*/

/* MODAL DE OPCIONES Y ROLES */
$('open-options').addEventListener('click', ()=> {
  $('modal-options').classList.remove('hidden');
  document.querySelector('input[name="sessionRole"][value="Administrativo"]').checked = true;
  $('manager-pass-area').classList.add('hidden');
  $('manager-pass').value = '';
  $('gear-panel').classList.add('hidden');
});

document.querySelectorAll('input[name="sessionRole"]').forEach(r=>{
  r.addEventListener('change', (e)=>{
    if(e.target.value === 'Gerente') $('manager-pass-area').classList.remove('hidden');
    else $('manager-pass-area').classList.add('hidden');
  });
});

$('options-cancel').addEventListener('click', ()=> $('modal-options').classList.add('hidden'));
$('gear-change').addEventListener('click', ()=> $('gear-panel').classList.toggle('hidden'));
$('cancel-gear').addEventListener('click', ()=> $('gear-panel').classList.add('hidden'));

$('save-manager-pass').addEventListener('click', async ()=>{
  const p = $('new-manager-pass').value.trim(); 
  if(!p){ showModal('Atenci√≥n', 'Ingrese nueva clave.', false); return; }
  
  try {
    // Guardar la nueva clave en Firebase
    await settingsRef.set({ password: p }, { merge: true }); 
    managerPass = p; // Actualiza el estado local inmediatamente
    showModal('√âxito', 'Clave actualizada en el sistema.', false); 
    $('gear-panel').classList.add('hidden');
  } catch(e) {
    showModal('Error', 'Error al guardar la clave: ' + e.message, false);
  }
});

$('options-continue').addEventListener('click', ()=>{
  const chosen = document.querySelector('input[name="sessionRole"]:checked').value;
  if(chosen === 'Gerente'){
    if($('manager-pass').value !== managerPass){ showModal('Error', 'Clave incorrecta.', false); return; }
    sessionRole = 'Gerente';
  } else sessionRole = 'Administrativo';

  const isMgr = (sessionRole === 'Gerente');
  $('btn-delete').style.display = isMgr ? 'inline-block' : 'none';
  $('btn-cuadrar').style.display = isMgr ? 'inline-block' : 'none';
  $('btn-export-master').style.display = isMgr ? 'inline-block' : 'none';
  document.querySelectorAll('.del-btn').forEach(b => b.style.display = isMgr ? 'block' : 'none');
  
  // Habilita/Deshabilita los toggles de cierre de cuenta
  document.querySelectorAll('.close-account-toggle').forEach(t => t.disabled = !isMgr);

  $('modal-options').classList.add('hidden');
  showModal('Acceso', 'Rol activo: ' + sessionRole, false);
  
  // Actualizar indicadores de jerarqu√≠a cuando cambia el rol
  setTimeout(() => {
    updateVerificationIndicators();
  }, 200);
});

/* SEGURIDAD EXTRA: Proteger cambios en items verificados */
async function checkSensitiveAction(selectedData) {
  const lockedItems = selectedData.filter(i => i.verifiedRole || i.isSeparator);
  
  if (lockedItems.length > 0) {
    try {
        await showPasswordModal(
            "‚ö†Ô∏è ACCI√ìN RESTRINGIDA ‚ö†Ô∏è", 
            "Est√° intentando modificar/eliminar registros VERIFICADOS o CORTES. Ingrese la CLAVE DE GERENTE para continuar:"
        );
        return true;
    } catch (e) {
        return false;
    }
  }
  return true; 
}

/* GESTI√ìN DE CUENTAS (Incluye l√≥gica de cierre y re-apertura con clave) */
function subscribeAccounts(){
  db.collection('cuentas').orderBy('name').onSnapshot(snapshot=>{
    const container = $('accounts-list'); container.innerHTML = '';
    
    let firstAccount = null;
    let accountsData = [];
    snapshot.forEach(doc => accountsData.push({ id: doc.id, ...doc.data() }));

    // Si no hay ninguna cuenta seleccionada, seleccionamos la primera
    if(!selectedAccountId && accountsData.length > 0){
        firstAccount = accountsData[0];
        selectedAccountId = firstAccount.id; 
        selectedAccountName = firstAccount.name;
    }

    // Renderizar cuentas
    accountsData.forEach(a=>{
      const isClosed = a.closed || false; 
      const isMgr = (sessionRole === 'Gerente');

      const div = document.createElement('div'); 
      // *** FIX 1: Aplicar el resalte visual correctamente ***
      div.className = 'account-item' + (selectedAccountId === a.id ? ' selected' : '');
      div.innerHTML = `
        <div style="font-weight:600; padding-right:20px;">${a.name} ${isClosed ? ' (üîí CERRADA)' : ''}</div>
        <div class="muted">${a.number || ''}</div>
        <label style="margin-top:4px; display: block; font-size:12px;">
            <input type="checkbox" data-id="${a.id}" class="close-account-toggle" ${isClosed ? 'checked' : ''} ${isMgr ? '' : 'disabled'}> 
            ${isClosed ? 'Cuenta Cerrada' : 'Marcar para Cerrar'}
        </label>
      `;
      
      const delBtn = document.createElement('span');
      delBtn.className = 'del-btn';
      delBtn.textContent = 'üóëÔ∏è';
      delBtn.title = "Eliminar cuenta";
      if(isMgr) delBtn.style.display = 'block';
      delBtn.onclick = (e) => { e.stopPropagation(); deleteAccount(a.id, a.name); };
      div.appendChild(delBtn);

      div.onclick = ()=>{ 
        selectedAccountId = a.id; 
        selectedAccountName = a.name;
        
        // LIMPIAR LA SELECCI√ìN AL CAMBIAR DE CUENTA
        selectedConsignIds.clear(); 
        document.querySelectorAll('#consigns-body input[type="checkbox"]').forEach(chk => chk.checked = false);
        activeRowIndex = -1; // Limpiar √≠ndice activo/ancla
        anchorRowIndex = -1;
        
        // La actualizaci√≥n de la UI se maneja mejor forzando el resalto localmente 
        // y dejando que la pr√≥xima snapshot de cuentas actualice todo el sidebar.
        document.querySelectorAll('#accounts-list .account-item').forEach(el => el.classList.remove('selected'));
        div.classList.add('selected');

        const isClosedState = a.closed || false;
        $('selected-account-info').textContent = `Cuenta: ${a.name} ‚Äî ${a.number || ''}${isClosedState ? ' (üîí CERRADA)' : ''}`; 
        
        // Recalcular totales de separadores verdes al cambiar de cuenta
        setTimeout(async () => {
          await actualizarTotalesVerdes(); // Nueva l√≥gica simple
        }, 500);
        
        updateSelectedTotals(); 
        renderConsigns(); 
      };
      container.appendChild(div);
    });

    // *** FIX 2: Asegurar que el t√≠tulo se actualice en la carga inicial si se seleccion√≥ la primera cuenta ***
    if(firstAccount){ 
        const isClosed = firstAccount.closed || false;
        $('selected-account-info').textContent = `Cuenta: ${selectedAccountName} ‚Äî ${firstAccount.number || ''}${isClosed ? ' (üîí CERRADA)' : ''}`; 
        renderConsigns(); 
        updateSelectedTotals();
        
        // Recalcular totales al cargar la primera cuenta
        setTimeout(async () => {
          await actualizarTotalesVerdes(); // Nueva l√≥gica simple
        }, 1000);
    }
    // Aseguramos que el total general se actualice al cargar las cuentas por primera vez
    updateTotalGeneral(); 
  });
}
subscribeAccounts();

// Listener para el Toggle de Cierre de Cuenta
document.addEventListener('change', async (e) => {
    if (e.target.classList.contains('close-account-toggle')) {
        const accountId = e.target.dataset.id;
        const newState = e.target.checked;
        
        // Obtener el nombre de la cuenta para el modal de confirmaci√≥n
        const accountDoc = await db.collection('cuentas').doc(accountId).get();
        const accountName = accountDoc.data()?.name || 'Seleccionada';

        try {
            if (newState) {
                // Requiere clave para CERRAR
                await showPasswordModal("Confirmaci√≥n de Cierre", `¬øDesea CERRAR la cuenta "${accountName}" permanentemente? Esto evitar√° nuevas consignaciones, a menos que se fuerce la acci√≥n.`);
            } else {
                // REQUISITO NUEVO: Requiere clave para REABRIR (quitar el cerrado)
                await showPasswordModal("Confirmaci√≥n de Apertura", `¬øDesea REABRIR la cuenta "${accountName}"? Esto permitir√° nuevas consignaciones. Ingrese CLAVE DE GERENTE.`);
            }
            
            await db.collection('cuentas').doc(accountId).update({ closed: newState });
        } catch (error) {
            e.target.checked = !newState; // Revertir estado en la UI si falla o cancela
            if (error.message !== "Acci√≥n cancelada.") {
                showModal('Error', "Error al actualizar el estado de la cuenta: " + error.message, false);
            }
        }
    }
});

async function deleteAccount(id, name){
    if(sessionRole !== 'Gerente') return showModal('Error', "Solo Gerente puede eliminar cuentas.", false);
    
    showModal('Confirmaci√≥n', `¬øEliminar cuenta "${name}" permanentemente?`, true, async () => {
        try {
            await showPasswordModal(
                "‚ö†Ô∏è PELIGRO ‚ö†Ô∏è",
                `Va a eliminar la cuenta "${name}" y todo su historial. Ingrese CLAVE DE GERENTE para confirmar:`
            );

            await db.collection('cuentas').doc(id).delete();
            if(selectedAccountId === id) { selectedAccountId=null; $('consigns-body').innerHTML=''; $('selected-account-info').textContent='...'; }
            showModal('√âxito', "Cuenta eliminada.", false);
        } catch(e) { 
            if(e.message !== "Acci√≥n cancelada.") showModal('Error', "Error: " + e.message, false);
        }
    });
}

/** L√≥gica para agregar cuentas nuevas */
$('add-account').addEventListener('click', async ()=>{
  const name = $('new-account-name').value.trim();
  const number = $('new-account-number').value.trim();
  
  if(!name){
    return showModal('Atenci√≥n', 'El nombre de la cuenta es obligatorio.', false);
  }
  
  if(!number){
    return showModal('Atenci√≥n', 'El n√∫mero de cuenta es obligatorio.', false);
  }
  
  try {
    // Verificar si ya existe una cuenta con el mismo n√∫mero
    const existingAccountQuery = await db.collection('cuentas')
      .where('number', '==', number)
      .get();
    
    if (!existingAccountQuery.empty) {
      const existingAccount = existingAccountQuery.docs[0].data();
      return showModal('Error', `Ya existe una cuenta con el n√∫mero "${number}". Nombre: "${existingAccount.name}".`, false);
    }
    
    await db.collection('cuentas').add({
      name: name,
      number: number,
      closed: false // Default to open
    });
    
    // Success: Clear fields and notify user
    $('new-account-name').value = '';
    $('new-account-number').value = '';
    showModal('√âxito', 'Cuenta agregada con √©xito. Ya puede seleccionarla de la lista.', false); 
  } catch(e) {
    showModal('Error', 'Error al agregar la cuenta: ' + e.message, false);
  }
});


/* RENDER CONSIGNACIONES */
let consignsUnsub = null;
function renderConsigns(){ 
  if(consignsUnsub) consignsUnsub(); 
  const tbody = $('consigns-body'); tbody.innerHTML = '';
  currentConsignsSnapshot = [];

  if(!selectedAccountId) return;

  // Obtener todas las consignaciones y ordenar manualmente para manejar migraci√≥n
  consignsUnsub = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').onSnapshot(async snapshot=>{
    tbody.innerHTML = '';
    currentConsignsSnapshot = [];
    
    // 1. FILTRAR LA SELECCI√ìN: Eliminar de la "memoria" IDs que ya no existen en el snapshot
    const newSnapshotIds = new Set(snapshot.docs.map(doc => doc.id));
    selectedConsignIds = new Set([...selectedConsignIds].filter(id => newSnapshotIds.has(id)));
    
    // 2. MIGRACI√ìN: Asignar orden a consignaciones que no lo tienen
    const batch = db.batch();
    let needsMigration = false;
    let maxOrdenExistente = 0;
    
    // Primero, encontrar el orden m√°ximo existente
    snapshot.docs.forEach(doc => {
      const data = doc.data();
      if (data.orden !== undefined) {
        maxOrdenExistente = Math.max(maxOrdenExistente, data.orden);
      }
    });
    
    // Luego, asignar orden a los que no lo tienen (m√°s antiguos primero)
    const docsWithoutOrder = snapshot.docs.filter(doc => doc.data().orden === undefined);
    docsWithoutOrder.sort((a, b) => {
      const fechaA = a.data().fecha?.toDate() || new Date(0);
      const fechaB = b.data().fecha?.toDate() || new Date(0);
      return fechaA.getTime() - fechaB.getTime(); // M√°s antiguos primero
    });
    
    docsWithoutOrder.forEach((doc, index) => {
      const nuevoOrden = maxOrdenExistente + index + 1;
      batch.update(doc.ref, { orden: nuevoOrden });
      needsMigration = true;
    });
    
    if (needsMigration) {
      console.log('üîÑ Migrando consignaciones sin campo orden...');
      await batch.commit();
      return; // El snapshot se actualizar√° autom√°ticamente
    }
    
    // 3. PROCESAR Y ORDENAR DATOS
    snapshot.forEach(doc => currentConsignsSnapshot.push({id: doc.id, ...doc.data()}));
    
    // Ordenar por campo orden (ascendente = orden de ingreso)
    currentConsignsSnapshot.sort((a, b) => {
      const ordenA = a.orden || 0;
      const ordenB = b.orden || 0;
      return ordenA - ordenB; // Ascendente - mantiene orden de ingreso
    });

    currentConsignsSnapshot.forEach((c, index)=>{
      
      const isSelected = selectedConsignIds.has(c.id); // <-- Verificar el estado en la "memoria"
      const checkedAttr = isSelected ? 'checked' : ''; // <-- Atributo 'checked'

      if(c.isSeparator){
        const tr=document.createElement('tr');
        tr.classList.add('separator');
        if(c.type==='green') tr.classList.add('sep-green');
        if(c.type==='red') tr.classList.add('sep-red');
        let labelText = `--- ${c.label} ---`;
        if(c.type === 'green') labelText = `üí∞ TOTAL: ${fmtCOP(c.total)}`;
        if(c.type === 'red') labelText = `üõë CORTE (${c.label})`;
        tr.innerHTML = `<td><input type="checkbox" data-id="${c.id}" data-idx="${index}" data-separator="true" ${checkedAttr}></td><td colspan="4">${labelText}</td><td></td>`;
        tbody.appendChild(tr);
        return;
      }

      const tr = document.createElement('tr');
      tr.setAttribute('data-index', index);
      if(c.verifiedRole === 'Administrativo') tr.classList.add('verified-admin');
      if(c.verifiedRole === 'Gerente') tr.classList.add('verified-gerente');
      
      // Usar fecha normal (ya no necesitamos fechaOriginal o fechaUsuario)
      const fechaText = c.fecha && c.fecha.toDate ? new Date(c.fecha.toDate()).toLocaleDateString() : '';
      const obsText = c.obsdate && c.obsdate.toDate ? new Date(c.obsdate.toDate()).toLocaleDateString() : '';
      
      tr.innerHTML = `
        <td style="width:56px; text-align:center;"><input type="checkbox" data-id="${c.id}" data-idx="${index}" ${checkedAttr}></td>
        <td style="width:160px">${fechaText}</td>
        <td style="width:140px">${fmtCOP(c.valor)}</td>
        <td style="width:100px; font-size:10px;">${c.referencia || ''}</td>
        <td style="width:160px">${obsText}</td>
        <td style="width:160px">${c.verifiedRole ? (c.verifiedRole === 'Gerente' ? 'Verificado (Amarillo)' : 'Verificado (Gris)') : 'Pendiente'}</td>
      `;
      
      // *** MODIFICACI√ìN CRUCIAL AQU√ç ***
      tr.addEventListener('click', (e)=>{
        if(e.target.type !== 'checkbox') {
            activeRowIndex = index;
            anchorRowIndex = index; // <-- FIX: Establecer el ancla al hacer clic en la fila
            
            // Comportamiento est√°ndar: Un clic simple en la fila limpia la selecci√≥n previa
            if(!e.shiftKey && !e.ctrlKey && !e.metaKey) {
                selectedConsignIds.clear();
                document.querySelectorAll('#consigns-body input[type="checkbox"]').forEach(chk => chk.checked = false);
            }

            highlightRow(index);
        }
      });
      // FUNCIONALIDAD DE DOBLE CLICK REMOVIDA - Usar modal de ajustes manuales
      // tr.addEventListener('dblclick', (e) => handleDoubleClick(c, index));

      tbody.appendChild(tr);
    });
    
    // Actualizar totales autom√°ticamente (con diagn√≥stico y protecci√≥n)
    console.log('üîÑ ACTUALIZANDO TOTALES DESPU√âS DE RENDERIZAR');
    console.log('  - Estado isProcessingCuadre:', window.isProcessingCuadre);
    
    // Solo actualizar si no hay un cuadre en proceso
    if (!window.isProcessingCuadre) {
      updateSelectedTotals(); 
      updateTotalGeneral();
      
      // Verificar que los totales se actualizaron correctamente
      setTimeout(() => {
        const totalElement = $('total-cuenta');
        const currentDisplay = totalElement ? totalElement.textContent : '$0';
        
        console.log('üîç VERIFICACI√ìN POST-ACTUALIZACI√ìN:');
        console.log('  - Total en UI:', currentDisplay);
        
        // Si el total est√° en ceros o vac√≠o, mostrar alerta
        if (!currentDisplay || currentDisplay === '$0' || currentDisplay === '0') {
          console.log('‚ö†Ô∏è DETECTADO: Total en ceros despu√©s de actualizaci√≥n');
          console.log('  - Posibles causas:');
          console.log('    1. updateSelectedTotals() o updateTotalGeneral() devolvieron 0');
          console.log('    2. Problema en la l√≥gica de c√°lculo');
          console.log('    3. Interferencia con otra actualizaci√≥n');
          console.log('    4. onSnapshot sobreescribiendo datos despu√©s del cuadre');
          
          // Intentar recalcular una vez m√°s
          console.log('üîÑ REINTENTO AUTOM√ÅTICO...');
          invalidateCache(selectedAccountId);
          updateSelectedTotals();
          updateTotalGeneral();
          
          setTimeout(() => {
            const retryDisplay = totalElement ? totalElement.textContent : '$0';
            console.log('üîç VERIFICACI√ìN POST-REINTENTO:');
            console.log('  - Total despu√©s de reintento:', retryDisplay);
            
            if (!retryDisplay || retryDisplay === '$0' || retryDisplay === '0') {
              console.log('‚ùå ERROR CR√çTICO: El total sigue en ceros despu√©s de reintento');
              console.log('  - Esto indica un problema sist√©mico en el c√°lculo de totales');
              
              // PROBLEMA RESUELTO: Ya no mostrar advertencia
              // El sistema de c√°lculo de totales ha sido corregido
              console.log('‚úÖ Sistema de c√°lculo corregido - No se muestra advertencia');
            } else {
              console.log('‚úÖ RECUPERACI√ìN EXITOSA: Total ahora se muestra correctamente');
            }
          }, 1000);
        }
      }, 500);
    }
    
    // *** PROTECCI√ìN ANTI-SOBREESCRITURA ***
    // Prevenir que el onSnapshot actualice los totales si hay un cuadre en proceso
    // Nota: No modificamos el onSnapshot directamente, sino que protegemos las actualizaciones
    console.log('üõ°Ô∏è PROTECCI√ìN ACTIVA: Sistema listo para proteger contra sobreescribir totales');
    
    // Actualizar indicadores de jerarqu√≠a despu√©s de renderizar
    setTimeout(() => {
      if (typeof updateVerificationIndicators === 'function') {
        updateVerificationIndicators();
      }
    }, 300);
  });
}

/* L√ìGICA DE TECLADO Y SELECCI√ìN */
let activeRowIndex = -1;
let anchorRowIndex = -1;
function getRows(){ return Array.from(document.querySelectorAll('#consigns-body tr')); }
function highlightRow(idx){
    const rows = getRows();
    rows.forEach(r => r.classList.remove('keyboard-focus'));
    if(idx >= 0 && idx < rows.length){
        rows[idx].classList.add('keyboard-focus');
        rows[idx].scrollIntoView({block:'nearest'});
    }
}

// SINCRONIZA LA SELECCI√ìN DEL CHECKBOX CON LA MEMORIA LOCAL
$('consigns-body').addEventListener('change', (e)=>{
    if(e.target.type === 'checkbox'){
        const id = e.target.dataset.id;
        const idx = parseInt(e.target.dataset.idx);
        
        // ACTUALIZA EL SET GLOBAL DE SELECCI√ìN (MEMORIA LOCAL)
        if(e.target.checked) {
            selectedConsignIds.add(id);
        } else {
            selectedConsignIds.delete(id);
        }
        
        if(!lastShiftState) anchorRowIndex = idx; // Se actualiza el ancla si NO se usa Shift
    }
});

let lastShiftState = false;
document.addEventListener('keydown', e => { if(e.key === 'Shift') lastShiftState = true; });
document.addEventListener('keyup', e => { if(e.key === 'Shift') lastShiftState = false; });

document.addEventListener('keydown', e => {
    if(e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA') return;
    const rows = getRows();
    if(rows.length === 0) return;
    if(['ArrowUp','ArrowDown'].includes(e.key)){
        e.preventDefault();
        
        // Inicializa o corrige el √≠ndice activo/ancla
        if(activeRowIndex === -1) { 
            activeRowIndex = 0; 
            anchorRowIndex = 0; 
        }
        
        let newIndex = activeRowIndex;
        if(e.key === 'ArrowDown') newIndex++;
        if(e.key === 'ArrowUp') newIndex--;
        newIndex = Math.max(0, Math.min(newIndex, rows.length - 1));
        
        if(e.shiftKey){
            // L√≥gica de selecci√≥n de rango (Shift + Flechas)
            
            // Calcula el rango entre el ancla y la nueva posici√≥n
            const start = Math.min(anchorRowIndex, newIndex);
            const end = Math.max(anchorRowIndex, newIndex);
            
            // Limpia la selecci√≥n actual para re-aplicar el nuevo rango
            selectedConsignIds.clear(); 
            
            rows.forEach((r, i) => {
                const chk = r.querySelector('input[type="checkbox"]');
                if(!chk) return;
                
                // Selecciona solo los elementos dentro del nuevo rango
                if(i >= start && i <= end){
                    chk.checked = true;
                    selectedConsignIds.add(chk.dataset.id); 
                } else {
                    chk.checked = false; // Deselecciona los que quedan fuera
                }
            });
            
        } else {
            // Sin Shift: se mueve el cursor y se establece un nuevo ancla
            anchorRowIndex = newIndex;
            // Opcional: limpiar la selecci√≥n si no se usa Shift (ya manejado en click, pero aqu√≠ garantiza que solo se mueva el foco)
            selectedConsignIds.clear(); 
            document.querySelectorAll('#consigns-body input[type="checkbox"]').forEach(chk => chk.checked = false);
        }
        
        activeRowIndex = newIndex;
        highlightRow(activeRowIndex);
    }
    
    // Toggle Checkbox con barra espaciadora
    if(e.key === ' '){
        e.preventDefault();
        if(activeRowIndex >= 0 && activeRowIndex < rows.length){
            const chk = rows[activeRowIndex].querySelector('input[type="checkbox"]');
            if(chk) {
                // Toggla el estado del checkbox
                chk.checked = !chk.checked;
                
                // SINCRONIZA EL ESTADO CON EL SET
                if(chk.checked) {
                    selectedConsignIds.add(chk.dataset.id);
                } else {
                    selectedConsignIds.delete(chk.dataset.id);
                }
                
                // Actualiza el ancla si no se us√≥ Shift (aunque ya est√° en el change listener, lo ponemos aqu√≠ por si acaso)
                if(!e.shiftKey) {
                    anchorRowIndex = activeRowIndex;
                }
            }
        }
    }
});

/* BOTONES DE EXPORTACI√ìN (Con formato de fecha corregido) */
const longDateFormat = '[$-es-ES]d\ \d\e\ mmmm\ \d\e\ aaaa'; 
const shortDateFormat = 'DD/MM/YYYY'; 

function applyExcelDateFormats(ws) {
    if (!ws['!ref']) return;
    const range = XLSX.utils.decode_range(ws['!ref']);
    
    for (let R = range.s.r + 1; R <= range.e.r; ++R) { 
        const cell_fecha_addr = XLSX.utils.encode_cell({ r: R, c: 0 }); // FECHA
        const cell_valor_addr = XLSX.utils.encode_cell({ r: R, c: 1 }); // VALOR
        const cell_ref_addr = XLSX.utils.encode_cell({ r: R, c: 2 }); // REFERENCIA
        const cell_obs_addr = XLSX.utils.encode_cell({ r: R, c: 3 }); // OBSERVACIONES

        // FECHA: Formato de fecha LARGO
        if (ws[cell_fecha_addr] && ws[cell_fecha_addr].t === 'n') {
            ws[cell_fecha_addr].z = longDateFormat; 
        }
        // OBSERVACIONES: Formato de fecha CORTO (dd/mm/yyyy)
        if (ws[cell_obs_addr] && ws[cell_obs_addr].t === 'n') {
            ws[cell_obs_addr].z = shortDateFormat; 
        }
        
        // Formato de moneda
        if (ws[cell_valor_addr]) {
            ws[cell_valor_addr].z = '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"??_);_(@_)';
        }
    }
    // Ajuste de anchos 
    ws['!cols'] = [{wch: 25}, {wch: 15}, {wch: 15}, {wch: 25}, {wch: 20}];
}

// Funci√≥n de exportaci√≥n de cuenta seleccionada
$('btn-export-excel').addEventListener('click', () => {
  if(!selectedAccountId || currentConsignsSnapshot.length === 0) return showModal('Atenci√≥n', "No hay datos para exportar.", false);

  const dataForExcel = currentConsignsSnapshot
    .filter(c => !c.isSeparator)
    .map(c => {
      // Es crucial pasar los objetos Date para que el formato de Excel funcione
      // Usar fechaOriginal si existe, sino usar fecha normal
      const fechaParaExportar = c.fechaOriginal || c.fecha;
      const fechaDate = fechaParaExportar && fechaParaExportar.toDate ? fechaParaExportar.toDate() : null;
      const obsDate = c.obsdate && c.obsdate.toDate ? c.obsdate.toDate() : null;
      
      const estado = !c.verifiedRole 
          ? 'Pendiente' 
          : c.verifiedRole === 'Administrativo' 
            ? 'Verificado (Gris)' 
            : 'Verificado (Amarillo)';

      return {
        FECHA: fechaDate, 
        VALOR: Number(c.valor || 0),
        REFERENCIA: c.referencia || '',
        OBSERVACIONES: obsDate,
        'ESTADO/COLOR': estado 
      };
    });

  if(dataForExcel.length === 0) return showModal('Atenci√≥n', "No hay movimientos v√°lidos (solo separadores).", false);

  const wb = XLSX.utils.book_new();
  // El orden de la exportaci√≥n es el mismo que el del snapshot (ascendente = orden de ingreso)
  const ws = XLSX.utils.json_to_sheet(dataForExcel, { header: ["FECHA", "VALOR", "REFERENCIA", "OBSERVACIONES", "ESTADO/COLOR"] }); 

  applyExcelDateFormats(ws);
  
  XLSX.utils.book_append_sheet(wb, ws, selectedAccountName.substring(0, 31)); 
  XLSX.writeFile(wb, `Consignaciones_${selectedAccountName.replace(/\s+/g,'_')}.xlsx`);
});

// Funci√≥n de exportaci√≥n de maestra
$('btn-export-master').addEventListener('click', async () => {
  if (sessionRole !== 'Gerente') return;
  
  try {
    await showPasswordModal(
        "‚ö†Ô∏è DESCARGA DE MAESTRA ‚ö†Ô∏è",
        "Esta acci√≥n descarga toda la informaci√≥n del sistema. Ingrese la CLAVE DE GERENTE para continuar:"
    );

    const accountsSnapshot = await db.collection('cuentas').get();
    const wb = XLSX.utils.book_new();

    for (const doc of accountsSnapshot.docs) {
      const account = { id: doc.id, ...doc.data() };
      const accountName = account.name.substring(0, 31).replace(/[\/\?\[\]\*\\\: ]/g, '_'); 

      // Las consignaciones se ordenan cronol√≥gicamente para la maestra (por convenci√≥n de archivo hist√≥rico)
      const consignsSnapshot = await db.collection('cuentas').doc(account.id).collection('consignaciones').orderBy('fecha').get();

      const dataForExcel = consignsSnapshot.docs
        .map(d => d.data())
        .filter(c => !c.isSeparator)
        .map(c => {
          // Usar fechaOriginal si existe, sino usar fecha normal
          const fechaParaExportar = c.fechaOriginal || c.fecha;
          const fechaDate = fechaParaExportar && fechaParaExportar.toDate ? fechaParaExportar.toDate() : null;
          const obsDate = c.obsdate && c.obsdate.toDate ? c.obsdate.toDate() : null;
          
          const estado = !c.verifiedRole 
              ? 'Pendiente' 
              : c.verifiedRole === 'Administrativo' 
                ? 'Verificado (Gris)' 
                : 'Verificado (Amarillo)';

          return {
            FECHA: fechaDate, 
            VALOR: Number(c.valor || 0),
            REFERENCIA: c.referencia || '',
            OBSERVACIONES: obsDate,
            'ESTADO/COLOR': estado 
          };
        });

      if (dataForExcel.length === 0) continue; 

      const ws = XLSX.utils.json_to_sheet(dataForExcel, { header: ["FECHA", "VALOR", "REFERENCIA", "OBSERVACIONES", "ESTADO/COLOR"] }); 

      applyExcelDateFormats(ws);

      XLSX.utils.book_append_sheet(wb, ws, accountName);
    }
    
    if (wb.SheetNames.length > 0) {
      XLSX.writeFile(wb, `Maestra_Consignaciones_${new Date().toLocaleDateString().replace(/\//g,'-')}.xlsx`);
    } else {
      showModal('Atenci√≥n', "No se encontraron movimientos en ninguna cuenta para exportar.", false);
    }
  } catch (e) {
    if(e.message !== "Acci√≥n cancelada.") showModal('Error', "Ocurri√≥ un error al intentar exportar la maestra: " + e.message, false);
  }
});


/* OPERACIONES DE DATOS (Sin modal de √©xito) */
$('add-consign').addEventListener('click', async ()=>{
  if(!selectedAccountId) return showModal('Atenci√≥n', 'Seleccione una cuenta.', false);
  
  // 1. Validar datos con nueva validaci√≥n mejorada
  const fecha = parseDateRadio('dateOpt','date-picker'); 
  const obsdate = parseDateRadio('obsOpt','obsdate-picker'); 
  const referencia = $('referencia').value.trim();
  
  if(!fecha) return showModal('Atenci√≥n', 'Fecha inv√°lida.', false);
  if(!referencia) return showModal('Atenci√≥n', 'La referencia es obligatoria.', false);
  
  // Validar valor usando la nueva funci√≥n de validaci√≥n
  let valor;
  try {
    valor = validateValorInput($('valor').value);
  } catch (error) {
    $('valor').focus();
    return showModal('Error de Validaci√≥n', error.message, false);
  }
  
  // 2. Verificar que la referencia no exista
  try {
    const referenciaCheck = await checkReferenciaExists(referencia);
    if (referenciaCheck.exists) {
      return showModal('Error', `La referencia "${referencia}" ya fue utilizada en la cuenta "${referenciaCheck.cuentaNombre}".`, false);
    }
  } catch (error) {
    return showModal('Error', error.message, false);
  }

  // --- L√ìGICA DE ADVERTENCIA DIN√ÅMICA ---
  
  const accountDoc = await db.collection('cuentas').doc(selectedAccountId).get();
  const isClosed = accountDoc.data()?.closed || false;
  
  let proceed = true;

  if (isClosed) {
    proceed = await showSuperWarning(
      "CUENTA CERRADA DETECTADA", 
      `La cuenta "${selectedAccountName}" ha sido marcada como CERRADA. Agregar una consignaci√≥n puede indicar un error.`,
      null
    );
  } 
  
  if (!proceed) {
      return; // Detiene la acci√≥n si el usuario selecciona "Cancelar Acci√≥n"
  }
  
  // --- FIN DE L√ìGICA DE ADVERTENCIA ---

  // 3. Ejecutar adici√≥n
  try{ 
    // CONSIGNACIONES NORMALES: Con cortes en la parte superior
    // Buscar el separador rojo m√°s reciente (que estar√° en la parte superior)
    let ultimoCorteRojo = null;
    let ordenParaNuevaConsignacion = 0;
    
    // Buscar el separador rojo con el orden m√°s PEQUE√ëO (m√°s reciente, ya que est√°n arriba)
    for (const item of currentConsignsSnapshot) {
      if (item.isSeparator && item.type === 'red') {
        if (!ultimoCorteRojo || (item.orden || 0) < (ultimoCorteRojo.orden || 0)) {
          ultimoCorteRojo = item;
        }
      }
    }
    
    if (ultimoCorteRojo) {
      // HAY UN CORTE: Las nuevas consignaciones deben ir ENCIMA del separador verde
      // Buscar el separador verde m√°s reciente (el que tiene menor orden, ya que est√°n arriba)
      let separadorVerdeMasReciente = null;
      currentConsignsSnapshot.forEach(c => {
        if (c.isSeparator && c.type === 'green') {
          if (!separadorVerdeMasReciente || (c.orden || 0) < (separadorVerdeMasReciente.orden || 0)) {
            separadorVerdeMasReciente = c;
          }
        }
      });
      
      if (separadorVerdeMasReciente) {
        // Insertar ENCIMA del separador verde (orden menor)
        ordenParaNuevaConsignacion = separadorVerdeMasReciente.orden - 0.1;
      } else {
        // No hay separador verde, insertar despu√©s del rojo
        ordenParaNuevaConsignacion = ultimoCorteRojo.orden + 0.1;
      }
      
      console.log('üÜï CONSIGNACI√ìN ENCIMA DEL SEPARADOR VERDE:');
      console.log('  - Orden corte rojo:', ultimoCorteRojo.orden);
      console.log('  - Orden separador verde:', separadorVerdeMasReciente?.orden);
      console.log('  - Nuevo orden (ENCIMA del verde):', ordenParaNuevaConsignacion);
      
    } else {
      // NO HAY CORTES: Agregar al final de la lista (orden m√°ximo + 1)
      let maxOrden = 0;
      currentConsignsSnapshot.forEach(c => {
        if (!c.isSeparator && c.orden !== undefined) {
          maxOrden = Math.max(maxOrden, c.orden);
        }
      });
      
      ordenParaNuevaConsignacion = maxOrden + 1;
      
      console.log('üÜï CONSIGNACI√ìN SIN CORTES (AL FINAL):');
      console.log('  - Orden actual m√°ximo:', maxOrden);
      console.log('  - Nuevo orden:', ordenParaNuevaConsignacion);
    }
    console.log('  - Fecha seleccionada:', fecha.toISOString());
    console.log('  - Referencia:', referencia);
    
    await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').add({ 
        fecha: firebase.firestore.Timestamp.fromDate(fecha), // Fecha seleccionada por el usuario (para mostrar)
        obsdate: obsdate? firebase.firestore.Timestamp.fromDate(obsdate): null, 
        valor, 
        referencia: referencia.toUpperCase(), // Convertir a may√∫sculas
        verifiedBy:null, 
        verifiedRole:null,
        orden: ordenParaNuevaConsignacion // Campo dedicado para ordenamiento manual
    }); 
    
    // RECALCULAR SEPARADORES AFECTADOS AUTOM√ÅTICAMENTE
    const nuevaConsignacion = { 
      orden: ordenParaNuevaConsignacion,
      valor: valor,
      verifiedRole: null // Nueva consignaci√≥n sin verificar
    };
    await actualizarTotalesVerdes(); // Nueva l√≥gica simple
    
    // Esperar un momento para que se actualice Firebase y luego actualizar la UI
    setTimeout(() => {
      updateSelectedTotals();
    }, 1000);
    
    $('valor').value=''; 
    $('referencia').value=''; // Limpiar el campo de referencia
    $('valor').focus(); // Enfocar el campo valor para la siguiente consignaci√≥n
    
    console.log('‚úÖ Consignaci√≥n agregada exitosamente con orden:', ordenParaNuevaConsignacion);
    
  }catch(e){ showModal('Error', 'Error al agregar consignaci√≥n: '+e.message, false); }
});

/* MANEJO ROBUSTO DE ERRORES Y RECOVERY STRATEGIES */

// Estrategias de recuperaci√≥n para c√°lculos fallidos
const errorRecoveryStrategies = {
  // Contador de errores por cuenta
  errorCounts: new Map(),
  
  // √öltimo valor conocido v√°lido por cuenta
  lastKnownValues: new Map(),
  
  // Registrar error y decidir estrategia
  handleCalculationError(accountId, operation, error) {
    const key = `${accountId}_${operation}`;
    const currentCount = this.errorCounts.get(key) || 0;
    this.errorCounts.set(key, currentCount + 1);
    
    console.error(`‚ùå Error en ${operation} (intento ${currentCount + 1}):`, error);
    
    // Estrategia basada en n√∫mero de errores
    if (currentCount < 2) {
      console.log('üîÑ Reintentando operaci√≥n...');
      return 'retry';
    } else if (currentCount < 5) {
      console.log('‚è≥ Usando √∫ltimo valor conocido...');
      return 'useLastKnown';
    } else {
      console.log('üö® Demasiados errores, rec√°lculo completo...');
      return 'fullRecalculation';
    }
  },
  
  // Guardar √∫ltimo valor conocido v√°lido
  saveLastKnownValue(accountId, operation, value) {
    const key = `${accountId}_${operation}`;
    this.lastKnownValues.set(key, {
      value: value,
      timestamp: Date.now()
    });
    // Resetear contador de errores en √©xito
    this.errorCounts.delete(key);
  },
  
  // Obtener √∫ltimo valor conocido v√°lido
  getLastKnownValue(accountId, operation) {
    const key = `${accountId}_${operation}`;
    const stored = this.lastKnownValues.get(key);
    
    if (stored && (Date.now() - stored.timestamp) < 300000) { // 5 minutos
      console.log('üìö Usando √∫ltimo valor conocido v√°lido:', stored.value);
      return stored.value;
    }
    
    return null;
  }
};

// Funci√≥n para detectar inconsistencias en c√°lculos
function detectCalculationInconsistency(separator, calculatedTotal) {
  const storedTotal = separator.total || 0;
  const tolerance = 1; // 1 peso de tolerancia
  
  const difference = Math.abs(storedTotal - calculatedTotal);
  
  if (difference > tolerance) {
    console.warn('‚ö†Ô∏è INCONSISTENCIA DETECTADA:');
    console.warn(`  - Separador ID: ${separator.id}`);
    console.warn(`  - Total almacenado: ${fmtCOP(storedTotal)}`);
    console.warn(`  - Total calculado: ${fmtCOP(calculatedTotal)}`);
    console.warn(`  - Diferencia: ${fmtCOP(difference)}`);
    
    return {
      hasInconsistency: true,
      difference: difference,
      storedTotal: storedTotal,
      calculatedTotal: calculatedTotal
    };
  }
  
  return { hasInconsistency: false };
}

// Funci√≥n para logging detallado de debugging
function logCalculationDebug(operation, data) {
  const timestamp = new Date().toISOString();
  const debugInfo = {
    timestamp: timestamp,
    operation: operation,
    accountId: selectedAccountId,
    data: data
  };
  
  console.group(`üêõ DEBUG: ${operation} - ${timestamp}`);
  console.log('Account ID:', debugInfo.accountId);
  console.log('Data:', debugInfo.data);
  console.groupEnd();
  
  // Guardar en localStorage para debugging persistente
  const debugLog = JSON.parse(localStorage.getItem('calculationDebugLog') || '[]');
  debugLog.push(debugInfo);
  
  // Mantener solo los √∫ltimos 50 logs
  if (debugLog.length > 50) {
    debugLog.splice(0, debugLog.length - 50);
  }
  
  localStorage.setItem('calculationDebugLog', JSON.stringify(debugLog));
}

// Funci√≥n para rec√°lculo completo como fallback
async function performFullRecalculation(accountId) {
  console.log('üîÑ INICIANDO REC√ÅLCULO COMPLETO COMO FALLBACK...');
  
  try {
    showCalculationIndicator(true);
    
    // Invalidar todo el cach√©
    invalidateCache(accountId);
    
    // Obtener todos los datos frescos
    const allItems = await getConsignationsOptimized(accountId);
    
    // Encontrar todos los separadores verdes
    const greenSeparators = allItems.filter(item => item.isSeparator && item.type === 'green');
    
    if (greenSeparators.length === 0) {
      console.log('‚ÑπÔ∏è No hay separadores verdes para recalcular');
      return;
    }
    
    console.log(`üîÑ Recalculando ${greenSeparators.length} separadores verdes...`);
    
    // Recalcular todos los separadores
    const separatorIds = greenSeparators.map(s => s.id);
    await batchRecalculateSeparators(separatorIds, accountId);
    
    // Actualizar totales de UI
    await updateSelectedTotals();
    
    console.log('‚úÖ REC√ÅLCULO COMPLETO EXITOSO');
    
  } catch (error) {
    console.error('‚ùå Error en rec√°lculo completo:', error);
    
    // √öltimo recurso: mostrar mensaje al usuario
    showModal('Error de Sistema', 
      'Hubo un problema con los c√°lculos. Por favor, recarga la p√°gina y contacta al administrador si el problema persiste.', 
      false);
  } finally {
    showCalculationIndicator(false);
  }
}
// ===== L√ìGICA CORREGIDA PARA TOTALES VERDES =====
async function actualizarTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('‚ùå No hay cuenta seleccionada');
    return;
  }
  
  console.log('üîÑ L√ìGICA CORREGIDA: Recalculando todos los separadores verdes...');
  
  try {
    // 1. Obtener todos los datos de Firebase
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    
    // 2. Ordenar por orden ascendente
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`üìä Total items encontrados: ${allItems.length}`);
    
    // 3. Encontrar todos los separadores verdes
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`üü¢ Separadores verdes encontrados: ${separadoresVerdes.length}`);
    
    if (separadoresVerdes.length === 0) {
      console.log('‚ÑπÔ∏è No hay separadores verdes para actualizar');
      return;
    }
    
    // 4. Para cada separador verde, calcular su total
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`\nüü¢ PROCESANDO SEPARADOR: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      // 5. Encontrar el separador rojo anterior m√°s cercano
      let ordenRojoAnterior = --Infinity;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) < ordenVerde) {
          ordenRojoAnterior = Math.max(ordenRojoAnterior, item.orden || 0);
        }
      }
      
      console.log(`üî¥ Separador rojo anterior: ${ordenRojoAnterior === --Infinity ? 'NINGUNO' : ordenRojoAnterior}`);
      console.log(`üìè Rango de c√°lculo: ${ordenRojoAnterior === --Infinity ? '-‚àû' : ordenRojoAnterior} < consignaci√≥n < ${ordenVerde}`);
      
      // 6. Sumar consignaciones amarillas (Gerente) en el per√≠odo
      let total = 0;
      let conteo = 0;
      const consignacionesEncontradas = [];
      
      for (const item of allItems) {
        // Solo consignaciones (no separadores)
        if (item.isSeparator) continue;
        
        // Solo las verificadas por Gerente (amarillas)
        if (item.verifiedRole !== 'Gerente') continue;
        
        // Solo las que est√°n en el per√≠odo (despu√©s del rojo anterior y antes del verde)
        const ordenItem = item.orden || 0;
        
        // L√ìGICA CORREGIDA: Manejar separadores con orden negativo
        let incluirConsignacion = false;
        
        if (ordenVerde < 0) {
          // Separador verde con orden negativo (despu√©s del cuadre)
          // Las consignaciones activas son las que tienen orden POSITIVO
          incluirConsignacion = ordenItem > 0;
        } else {
          // Separador verde con orden positivo (antes del cuadre)
          // Las consignaciones activas est√°n entre el rojo anterior y el verde
          incluirConsignacion = ordenItem > ordenRojoAnterior && ordenItem < ordenVerde;
        }
        
        if (incluirConsignacion) {
          total += Number(item.valor || 0);
          conteo++;
          consignacionesEncontradas.push({
            id: item.id.substring(0, 8),
            valor: item.valor,
            orden: ordenItem,
            referencia: item.referencia
          });
        }
      }
      
      console.log(`üìã Consignaciones encontradas:`, consignacionesEncontradas);
      console.log(`üü¢ Separador ${separadorVerde.id.substring(0, 8)}: ${conteo} consignaciones = $${total}`);
      
      // 7. Actualizar en Firebase si cambi√≥
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`‚úÖ Actualizando: ${separadorVerde.total} ‚Üí ${total}`);
      } else {
        console.log(`‚ÑπÔ∏è Ya correcto: ${total}`);
      }
    }
    
    // 8. Guardar todos los cambios
    await batch.commit();
    console.log('‚úÖ NUEVA L√ìGICA: Rec√°lculo completado exitosamente');
    
    // 9. Actualizar la UI
    // La UI se actualizar√° autom√°ticamente a trav√©s del onSnapshot existente
    
  } catch (error) {
    console.error('‚ùå Error en nueva l√≥gica:', error);
  }
}

// Funci√≥n de depuraci√≥n simple y clara
async function debugearDatos() {
  if (!selectedAccountId) {
    console.log('‚ùå No hay cuenta seleccionada');
    return;
  }
  
  console.log('üîç DEPURANDO DATOS...');
  
  const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
  const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
  
  console.log(`üìã TODOS LOS ITEMS:`);
  allItems.forEach((item, index) => {
    const tipo = item.isSeparator ? `Separador: ${item.type}` : 'NO';
    const verificado = item.verifiedRole || 'NO';
    console.log(`${index + 1}. ID: ${item.id.substring(0, 8)}, Separador: ${tipo}, Verificado: ${verificado}, Valor: ${item.valor || 0}, Orden: ${item.orden}`);
  });
  
  // Estad√≠sticas
  const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
  const consignacionesAmarillas = allItems.filter(item => !item.isSeparator && item.verifiedRole === 'Gerente');
  
  console.log(`üü¢ SEPARADORES VERDES: ${separadoresVerdes.length}`);
  console.log(`üü° CONSIGNACIONES AMARILLAS: ${consignacionesAmarillas.length}`);
  
  consignacionesAmarillas.forEach(cons => {
    console.log(`  - ${cons.id.substring(0, 8)}: ${cons.valor}, orden: ${cons.orden}`);
  });
}

// ===== L√ìGICA CORREGIDA PARA TOTALES VERDES =====
async function logicaCorregidaTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('‚ùå No hay cuenta seleccionada');
    return;
  }
  
  console.log('üîÑ L√ìGICA CORREGIDA: Recalculando todos los separadores verdes...');
  
  try {
    // 1. Obtener todos los datos de Firebase
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    
    // 2. Ordenar por orden ascendente
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`üü¢ Procesando ${separadoresVerdes.length} separadores verdes`);
    
    // 3. Encontrar todos los separadores verdes
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    
    if (separadoresVerdes.length === 0) {
      console.log('‚ÑπÔ∏è No hay separadores verdes para actualizar');
      return;
    }
    
    // 4. Para cada separador verde, calcular su total
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`üü¢ PROCESANDO: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      // 5. Encontrar el separador rojo anterior m√°s cercano (CORREGIDO)
      let ordenRojoAnterior = -Infinity;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) < ordenVerde) {
          ordenRojoAnterior = Math.min(ordenRojoAnterior, item.orden || 0);
        }
      }
      
      console.log(`üî¥ Separador rojo anterior: ${ordenRojoAnterior === -Infinity ? 'NINGUNO' : ordenRojoAnterior}`);
      
      // 6. Sumar consignaciones amarillas (Gerente) en el per√≠odo
      let total = 0;
      const consignacionesEncontradas = [];
      
      for (const item of allItems) {
        // Solo consignaciones (no separadores)
        if (item.isSeparator) continue;
        
        // Solo las verificadas por Gerente (amarillas)
        if (item.verifiedRole !== 'Gerente') continue;
        
        // Solo las que est√°n en el per√≠odo (despu√©s del rojo anterior y antes del verde)
        const ordenItem = item.orden || 0;
        
        // L√ìGICA CORREGIDA: Manejar separadores con orden negativo
        let incluirConsignacion = false;
        
        if (ordenVerde < 0) {
          // Separador verde con orden negativo (despu√©s del cuadre)
          // Las consignaciones activas son las que tienen orden POSITIVO
          incluirConsignacion = ordenItem > 0;
        } else {
          // Separador verde con orden positivo (antes del cuadre)
          // Las consignaciones activas est√°n entre el rojo anterior y el verde
          incluirConsignacion = ordenItem > ordenRojoAnterior && ordenItem < ordenVerde;
        }
        
        if (incluirConsignacion) {
          total += Number(item.valor || 0);
          consignacionesEncontradas.push({
            id: item.id.substring(0, 8),
            valor: item.valor,
            orden: ordenItem
          });
        }
      }
      
      console.log(`üìä Consignaciones encontradas:`, consignacionesEncontradas);
      console.log(`üí∞ Total calculado: ${total}`);
      
      // 7. Actualizar en Firebase si cambi√≥
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`‚úÖ Actualizando: ${separadorVerde.total} ‚Üí ${total}`);
      } else {
        console.log(`‚ÑπÔ∏è Ya correcto: ${total}`);
      }
    }
    
    // 8. Guardar todos los cambios
    await batch.commit();
    console.log('‚úÖ L√ìGICA CORREGIDA: Completado exitosamente');
    
    // 9. Actualizar la UI
    // La UI se actualizar√° autom√°ticamente a trav√©s del onSnapshot existente
    
  } catch (error) {
    console.error('‚ùå Error en l√≥gica corregida:', error);
  }
}

// Funci√≥n de prueba para la l√≥gica corregida
async function probarLogicaCorregida() {
  console.log('üß™ PROBANDO L√ìGICA CORREGIDA...');
  
  if (!selectedAccountId) {
    console.log('‚ùå Selecciona una cuenta primero');
    return;
  }
  
  console.log('1Ô∏è‚É£ Depurando datos actuales...');
  await debugearDatos();
  
  console.log('\n2Ô∏è‚É£ Ejecutando l√≥gica corregida...');
  await logicaCorregidaTotalesVerdes();
  
  console.log('\n3Ô∏è‚É£ Verificando resultados...');
  await debugearDatos();
  
  console.log('‚úÖ PRUEBA COMPLETADA');
}

// Funci√≥n de depuraci√≥n simple y clara
async function debugearDatos() {
  if (!selectedAccountId) {
    console.log('‚ùå No hay cuenta seleccionada');
    return;
  }
  
  console.log('üîç DEPURANDO DATOS...');
  
  const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
  const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
  
  console.log(`üìã TOTAL DE ITEMS: ${allItems.length}`);
  
  // Mostrar estructura ordenada
  console.log('\nüìã ESTRUCTURA COMPLETA (ordenada):');
  allItems.forEach((item, index) => {
    if (item.isSeparator) {
      console.log(`${index + 1}. üî¥üü¢ SEPARADOR ${item.type.toUpperCase()}: orden ${item.orden}, total: ${item.total || 0}`);
    } else {
      const estado = item.verifiedRole === 'Gerente' ? 'üü° AMARILLO' : 
                   item.verifiedRole === 'Administrativo' ? '‚ö™ GRIS' : '‚ö´ BLANCO';
      console.log(`${index + 1}. ${estado}: $${item.valor}, ref: ${item.referencia}, orden: ${item.orden}`);
    }
  });
  
  // Estad√≠sticas
  const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
  const separadoresRojos = allItems.filter(item => item.isSeparator && item.type === 'red');
  const consignacionesAmarillas = allItems.filter(item => !item.isSeparator && item.verifiedRole === 'Gerente');
  
  console.log(`\nüìä ESTAD√çSTICAS:`);
  console.log(`üü¢ Separadores verdes: ${separadoresVerdes.length}`);
  console.log(`üî¥ Separadores rojos: ${separadoresRojos.length}`);
  console.log(`üü° Consignaciones amarillas: ${consignacionesAmarillas.length}`);
  
  // Mostrar totales actuales de separadores verdes
  console.log(`\nüí∞ TOTALES ACTUALES DE SEPARADORES VERDES:`);
  separadoresVerdes.forEach(sep => {
    console.log(`  - ${sep.id.substring(0, 8)}: $${sep.total || 0} (orden: ${sep.orden})`);
  });
}

// Funci√≥n de prueba para verificar que todo funciona
async function probarNuevaLogica() {
  console.log('üß™ PROBANDO NUEVA L√ìGICA...');
  
  if (!selectedAccountId) {
    console.log('‚ùå Selecciona una cuenta primero');
    return;
  }
  
  console.log('1Ô∏è‚É£ Depurando datos actuales...');
  await debugearDatos();
  
  console.log('\n2Ô∏è‚É£ Actualizando totales verdes...');
  await actualizarTotalesVerdes();
  
  console.log('\n3Ô∏è‚É£ Verificando resultados...');
  await debugearDatos();
  
  console.log('‚úÖ PRUEBA COMPLETADA');
}

// Actualizar funci√≥n principal para usar l√≥gica corregida
async function actualizarTotalesVerdes() {
  await calcularTotalesVerdesCorregido();
}

// ===== FUNCI√ìN DEFINITIVA CORREGIDA =====
async function calcularTotalesVerdesCorregido() {
  if (!selectedAccountId) {
    console.log('‚ùå No hay cuenta seleccionada');
    return;
  }
  
  console.log('üîÑ FUNCI√ìN DEFINITIVA CORREGIDA: Recalculando separadores verdes...');
  
  try {
    // 1. Obtener todos los datos de Firebase
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    
    // 2. Ordenar por orden ascendente
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`üü¢ Procesando ${allItems.length} items`);
    
    // 3. Encontrar todos los separadores verdes
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`üü¢ Procesando ${separadoresVerdes.length} separadores verdes`);
    
    if (separadoresVerdes.length === 0) {
      console.log('‚ÑπÔ∏è No hay separadores verdes para actualizar');
      return;
    }
    
    // 4. Para cada separador verde, calcular su total
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`üü¢ PROCESANDO: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      // 5. Encontrar el separador rojo anterior m√°s cercano (CORREGIDO)
      let ordenRojoAnterior = -Infinity;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) < ordenVerde) {
          ordenRojoAnterior = Math.min(ordenRojoAnterior, item.orden || 0);
        }
      }
      
      console.log(`üî¥ Separador rojo anterior: ${ordenRojoAnterior === -Infinity ? 'NINGUNO' : ordenRojoAnterior}`);
      
      // 6. Sumar consignaciones amarillas (Gerente) en el per√≠odo
      let total = 0;
      const consignacionesEncontradas = [];
      
      for (const item of allItems) {
        // Solo consignaciones (no separadores)
        if (item.isSeparator) continue;
        
        // Solo las verificadas por Gerente (amarillas)
        if (item.verifiedRole !== 'Gerente') continue;
        
        // Solo las que est√°n en el per√≠odo (despu√©s del rojo anterior y antes del verde)
        const ordenItem = item.orden || 0;
        
        // L√ìGICA CORREGIDA: Manejar separadores con orden negativo
        let incluirConsignacion = false;
        
        if (ordenVerde < 0) {
          // Separador verde con orden negativo (despu√©s del cuadre)
          // Las consignaciones activas son las que tienen orden POSITIVO
          incluirConsignacion = ordenItem > 0;
        } else {
          // Separador verde con orden positivo (antes del cuadre)
          // Las consignaciones activas est√°n entre el rojo anterior y el verde
          incluirConsignacion = ordenItem > ordenRojoAnterior && ordenItem < ordenVerde;
        }
        
        if (incluirConsignacion) {
          total += Number(item.valor || 0);
          consignacionesEncontradas.push({
            id: item.id.substring(0, 8),
            valor: item.valor,
            orden: ordenItem
          });
        }
      }
      
      console.log(`üìä Consignaciones encontradas:`, consignacionesEncontradas);
      console.log(`üí∞ Total calculado: ${total}`);
      
      // 7. Actualizar en Firebase si cambi√≥
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`‚úÖ Actualizando: ${separadorVerde.total} ‚Üí ${total}`);
      } else {
        console.log(`‚ÑπÔ∏è Ya correcto: ${total}`);
      }
    }
    
    // 8. Guardar todos los cambios
    await batch.commit();
    console.log('‚úÖ FUNCI√ìN DEFINITIVA CORREGIDA: Completado exitosamente');
    
    // 9. Actualizar la UI (recargar los datos)
    console.log('üîÑ Recargando datos para actualizar UI...');
    // La UI se actualizar√° autom√°ticamente a trav√©s del onSnapshot existente
    
  } catch (error) {
    console.error('‚ùå Error en funci√≥n definitiva corregida:', error);
  }
}

// Mantener compatibilidad con c√≥digo existente
async function recalcularTotalSeparadorVerde() {
  await calcularTotalesVerdesCorregido();
}

async function recalcularTodosLosSeparadoresVerdes() {
  await calcularTotalesVerdesCorregido();
}

async function recalcularSeparadoresAfectados(consignation) {
  await calcularTotalesVerdesCorregido();
}

// Event listener para convertir referencia a may√∫sculas
$('referencia').addEventListener('input', function(e) {
  e.target.value = e.target.value.toUpperCase();
});

$('valor').addEventListener('keydown', e=>{ 
  if(e.key==='Enter') {
    e.preventDefault();
    $('referencia').focus(); // Pasar al campo de referencia
  }
});

// Funci√≥n global para probar desde consola
window.probarLogicaCorregida = probarLogicaCorregida;
window.debugearDatos = debugearDatos;
window.logicaCorregidaTotalesVerdes = logicaCorregidaTotalesVerdes;
window.calcularTotalesVerdesCorregido = calcularTotalesVerdesCorregido;

// ===== MODAL DE AJUSTES MANUALES =====

// Abrir modal de ajustes manuales
$('btn-manual-adjustments').onclick = async () => {
  try {
    // Verificar permisos de gerente
    await showPasswordModal('üîê Acceso Restringido', 'Los ajustes manuales requieren autorizaci√≥n de gerencia.');
    
    // Cargar separadores verdes disponibles
    await loadGreenSeparatorsForAdjustment();
    
    // Cargar historial de ajustes
    await loadAdjustmentsHistory();
    
    // Mostrar modal
    $('manual-adjustments-modal').classList.remove('hidden');
    
  } catch (error) {
    console.log('Acceso denegado a ajustes manuales');
  }
};

// Cerrar modal de ajustes
$('manual-adjustments-close').onclick = () => {
  $('manual-adjustments-modal').classList.add('hidden');
  clearAdjustmentForms();
};

// Cargar separadores verdes para el selector
async function loadGreenSeparatorsForAdjustment() {
  if (!selectedAccountId) return;
  
  try {
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    
    const greenSeparators = allItems
      .filter(item => item.isSeparator && item.type === 'green')
      .sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    const select = $('green-separator-select');
    select.innerHTML = '<option value="">-- Seleccione un separador verde --</option>';
    
    greenSeparators.forEach(sep => {
      const option = document.createElement('option');
      option.value = sep.id;
      option.textContent = `Separador Verde (Orden: ${sep.orden || 0}) - Total Actual: ${fmtCOP(sep.total || 0)}`;
      select.appendChild(option);
    });
    
  } catch (error) {
    console.error('Error cargando separadores verdes:', error);
  }
}

// Actualizar total verde
$('btn-update-green-total').onclick = async () => {
  const separatorId = $('green-separator-select').value;
  const newTotal = $('new-green-total').value.replace(/[^\d]/g, '');
  const reason = $('green-adjustment-reason').value.trim();
  
  if (!separatorId) {
    showModal('Error', 'Debe seleccionar un separador verde.', false);
    return;
  }
  
  if (!newTotal || newTotal === '0') {
    showModal('Error', 'Debe ingresar un total v√°lido.', false);
    return;
  }
  
  if (!reason) {
    showModal('Error', 'Debe explicar el motivo del ajuste.', false);
    return;
  }
  
  try {
    // Actualizar el total en Firebase
    await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones')
      .doc(separatorId).update({
        total: Number(newTotal),
        lastManualAdjustment: {
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          user: usuario.usuario,
          previousTotal: 0, // Se podr√≠a obtener el valor anterior
          newTotal: Number(newTotal),
          reason: reason
        }
      });
    
    // Registrar en historial
    await registerAdjustment('green_total_update', {
      separatorId: separatorId,
      newTotal: Number(newTotal),
      reason: reason
    });
    
    showModal('‚úÖ √âxito', 'Total verde actualizado correctamente.', false);
    
    // Limpiar formulario y recargar
    clearAdjustmentForms();
    // La UI se actualizar√° autom√°ticamente a trav√©s del onSnapshot existente
    await loadAdjustmentsHistory();
    
  } catch (error) {
    console.error('Error actualizando total verde:', error);
    showModal('Error', 'Error al actualizar el total: ' + error.message, false);
  }
};

// Agregar consignaci√≥n extraordinaria
$('btn-add-extra-consign').onclick = async () => {
  const consignDate = $('extra-consign-date').value;
  const obsDate = $('extra-obs-date').value;
  const valor = $('extra-valor').value.replace(/[^\d]/g, '');
  const referencia = $('extra-referencia').value.trim().toUpperCase();
  const verifiedRole = $('extra-verified-role').value;
  const reason = $('extra-consign-reason').value.trim();
  
  if (!consignDate || !obsDate) {
    showModal('Error', 'Debe ingresar ambas fechas.', false);
    return;
  }
  
  if (!valor || valor === '0') {
    showModal('Error', 'Debe ingresar un valor v√°lido.', false);
    return;
  }
  
  if (!referencia) {
    showModal('Error', 'Debe ingresar una referencia.', false);
    return;
  }
  
  if (!reason) {
    showModal('Error', 'Debe explicar el motivo de esta consignaci√≥n extraordinaria.', false);
    return;
  }
  
  try {
    // Verificar si la referencia ya existe
    const refCheck = await checkReferenciaExists(referencia);
    if (refCheck.exists) {
      showModal('Error', `La referencia "${referencia}" ya existe en la cuenta: ${refCheck.cuentaNombre}`, false);
      return;
    }
    
    // Obtener el siguiente orden
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const maxOrder = Math.max(...snapshot.docs.map(doc => doc.data().orden || 0), 0);
    
    // Crear la consignaci√≥n
    const newConsign = {
      fecha: new Date(consignDate + 'T12:00:00'),
      fechaObservacion: new Date(obsDate + 'T12:00:00'),
      valor: Number(valor),
      referencia: referencia,
      verifiedRole: verifiedRole || null,
      verifiedBy: verifiedRole ? usuario.usuario : null,
      verifiedAt: verifiedRole ? firebase.firestore.FieldValue.serverTimestamp() : null,
      orden: maxOrder + 1,
      isExtraordinary: true,
      extraordinaryReason: reason,
      createdBy: usuario.usuario,
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    };
    
    await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').add(newConsign);
    
    // Registrar en historial
    await registerAdjustment('extraordinary_consign', {
      valor: Number(valor),
      referencia: referencia,
      verifiedRole: verifiedRole,
      reason: reason
    });
    
    showModal('‚úÖ √âxito', 'Consignaci√≥n extraordinaria agregada correctamente.', false);
    
    // Limpiar formulario y recargar
    clearAdjustmentForms();
    // La UI se actualizar√° autom√°ticamente a trav√©s del onSnapshot existente
    await loadAdjustmentsHistory();
    
  } catch (error) {
    console.error('Error agregando consignaci√≥n extraordinaria:', error);
    showModal('Error', 'Error al agregar la consignaci√≥n: ' + error.message, false);
  }
};

// Recalcular todo
$('btn-recalculate-all').onclick = async () => {
  try {
    showModal('üîÑ Recalculando', 'Recalculando todos los totales...', false);
    await calcularTotalesVerdesCorregido();
    // La UI se actualizar√° autom√°ticamente a trav√©s del onSnapshot existente
    showModal('‚úÖ Completado', 'Todos los totales han sido recalculados.', false);
  } catch (error) {
    console.error('Error recalculando:', error);
    showModal('Error', 'Error al recalcular: ' + error.message, false);
  }
};

// Registrar ajuste en historial
async function registerAdjustment(type, data) {
  if (!selectedAccountId) return;
  
  try {
    await db.collection('cuentas').doc(selectedAccountId).collection('adjustments').add({
      type: type,
      data: data,
      user: usuario.usuario,
      timestamp: firebase.firestore.FieldValue.serverTimestamp(),
      accountId: selectedAccountId
    });
  } catch (error) {
    console.error('Error registrando ajuste:', error);
  }
}

// Cargar historial de ajustes
async function loadAdjustmentsHistory() {
  if (!selectedAccountId) return;
  
  try {
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('adjustments')
      .orderBy('timestamp', 'desc')
      .limit(10)
      .get();
    
    const historyDiv = $('adjustments-history');
    
    if (snapshot.empty) {
      historyDiv.innerHTML = '<div class="muted" style="text-align:center; padding:20px;">No hay ajustes registrados para esta cuenta</div>';
      return;
    }
    
    let html = '';
    snapshot.docs.forEach(doc => {
      const adj = doc.data();
      const date = adj.timestamp ? adj.timestamp.toDate().toLocaleString('es-CO') : 'Fecha no disponible';
      
      let description = '';
      if (adj.type === 'green_total_update') {
        description = `üü¢ Total verde actualizado a ${fmtCOP(adj.data.newTotal)} - ${adj.data.reason}`;
      } else if (adj.type === 'extraordinary_consign') {
        description = `‚ûï Consignaci√≥n extraordinaria: ${fmtCOP(adj.data.valor)} (${adj.data.referencia}) - ${adj.data.reason}`;
      } else if (adj.type === 'cuadre_realizado') {
        description = `‚úÖ Cuadre realizado: ${fmtCOP(adj.data.totalCuadrado)} (${adj.data.itemsIncluidos} items)`;
      }
      
      html += `
        <div style="padding:8px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:start;">
          <div style="flex:1;">
            <div style="font-weight:600; color:#333;">${description}</div>
            <div class="small muted">Por: ${adj.user} - ${date}</div>
          </div>
        </div>
      `;
    });
    
    historyDiv.innerHTML = html;
    
  } catch (error) {
    console.error('Error cargando historial:', error);
    $('adjustments-history').innerHTML = '<div class="muted" style="text-align:center; padding:20px; color:red;">Error cargando historial</div>';
  }
}

// Limpiar formularios de ajustes
function clearAdjustmentForms() {
  $('green-separator-select').value = '';
  $('new-green-total').value = '';
  $('green-adjustment-reason').value = '';
  
  $('extra-consign-date').value = '';
  $('extra-obs-date').value = '';
  $('extra-valor').value = '';
  $('extra-referencia').value = '';
  $('extra-verified-role').value = '';
  $('extra-consign-reason').value = '';
}

// Formatear input de valores en tiempo real
$('new-green-total').addEventListener('input', function(e) {
  let value = e.target.value.replace(/[^\d]/g, '');
  if (value) {
    e.target.value = fmtCOP(value);
  }
});

$('extra-valor').addEventListener('input', function(e) {
  let value = e.target.value.replace(/[^\d]/g, '');
  if (value) {
    e.target.value = fmtCOP(value);
  }
});

$('extra-referencia').addEventListener('input', function(e) {
  e.target.value = e.target.value.toUpperCase();
});
$('referencia').addEventListener('keydown', e=>{ 
  if(e.key==='Enter') {
    e.preventDefault();
    $('add-consign').click(); // Agregar la consignaci√≥n
  }
});

// Funcionalidad para deseleccionar radio buttons
let lastSelectedDate = null;
let lastSelectedObs = null;

// Funci√≥n para validar jerarqu√≠a de verificaci√≥n
function validateVerificationHierarchy(currentRole, newRole) {
  // Reglas de jerarqu√≠a CORRECTAS:
  // - Blanco (null) ‚Üí Puede cambiar a Gris (Administrativo) o Amarillo (Gerente) ‚úÖ
  // - Amarillo (Gerente) ‚Üí Puede cambiar a Gris (Administrativo) ‚úÖ  
  // - Gris (Administrativo) ‚Üí NO puede cambiar a Amarillo (Gerente) ‚ùå
  
  if (currentRole === 'Gerente' && newRole === 'Administrativo') {
    return false; // Admin NO puede cambiar Gerente (amarillo) a Admin (gris)
  }
  return true; // Permitido
}

// Funci√≥n para mostrar indicadores visuales de jerarqu√≠a (versi√≥n simplificada)
function updateVerificationIndicators() {
  try {
    const rows = document.querySelectorAll('#consigns-body tr');
    
    rows.forEach((row, index) => {
      const data = currentConsignsSnapshot[index];
      if (!data || data.isSeparator) return;
      
      const checkbox = row.querySelector('input[type="checkbox"]');
      if (!checkbox) return;
      
      const canVerify = validateVerificationHierarchy(data.verifiedRole, sessionRole);
      
      if (!canVerify) {
        // Solo cambiar el checkbox, sin agregar elementos adicionales
        checkbox.style.opacity = '0.4';
        checkbox.style.cursor = 'not-allowed';
        checkbox.title = `Jerarqu√≠a: Administrador no puede cambiar elementos verificados por Gerente`;
        checkbox.disabled = true;
      } else {
        // Restaurar apariencia normal
        checkbox.style.opacity = '1';
        checkbox.style.cursor = 'pointer';
        checkbox.title = '';
        checkbox.disabled = false;
      }
    });
  } catch (error) {
    console.log('Error en updateVerificationIndicators:', error);
  }
}

// Event listeners para radio buttons de fecha
document.querySelectorAll('input[name="dateOpt"]').forEach(radio => {
  radio.addEventListener('click', function() {
    if (lastSelectedDate === this) {
      this.checked = false;
      lastSelectedDate = null;
    } else {
      lastSelectedDate = this;
      // Limpiar el calendario cuando se selecciona un radio button
      $('date-picker').value = '';
    }
  });
});

// Event listeners para radio buttons de fecha de observaci√≥n
document.querySelectorAll('input[name="obsOpt"]').forEach(radio => {
  radio.addEventListener('click', function() {
    if (lastSelectedObs === this) {
      this.checked = false;
      lastSelectedObs = null;
    } else {
      lastSelectedObs = this;
      // Limpiar el calendario cuando se selecciona un radio button
      $('obsdate-picker').value = '';
    }
  });
});

// Limpiar selecci√≥n cuando se usa el date picker
$('date-picker').addEventListener('change', function() {
  document.querySelectorAll('input[name="dateOpt"]').forEach(radio => {
    radio.checked = false;
  });
  lastSelectedDate = null;
});

$('obsdate-picker').addEventListener('change', function() {
  document.querySelectorAll('input[name="obsOpt"]').forEach(radio => {
    radio.checked = false;
  });
  lastSelectedObs = null;
});

// Formateo de n√∫meros con separadores de miles - MEJORADO
function formatNumberWithSeparators(value) {
  // Remover todo excepto n√∫meros
  const numericValue = value.replace(/[^\d]/g, '');
  
  if (numericValue === '') return '';
  
  // Validar que no exceda 12 d√≠gitos
  if (numericValue.length > 12) {
    return formatNumberWithSeparators(numericValue.substring(0, 12));
  }
  
  // Formatear con separadores de miles usando punto
  return new Intl.NumberFormat('es-CO').format(parseInt(numericValue));
}

function getNumericValue(formattedValue) {
  // Remover separadores y devolver solo n√∫meros
  return formattedValue.replace(/[^\d]/g, '');
}

// Nueva funci√≥n para validar valor antes de agregar consignaci√≥n - MEJORADA CON PRECISI√ìN
function validateValorInput(valor) {
  const numericValue = getNumericValue(valor);
  
  // Validar que no est√© vac√≠o
  if (!numericValue || numericValue === '') {
    throw new Error('El valor es obligatorio');
  }
  
  // Convertir a n√∫mero entero para evitar problemas de punto flotante
  const numberValue = parseInt(numericValue);
  
  // Validar que no sea cero
  if (numberValue <= 0) {
    throw new Error('El valor debe ser mayor a cero');
  }
  
  // Validar que no exceda 12 d√≠gitos (999,999,999,999)
  if (numericValue.length > 12) {
    throw new Error('El valor no puede exceder 999,999,999,999');
  }
  
  // Validar rango m√°ximo razonable (999 mil millones)
  if (numberValue > 999999999999) {
    throw new Error('El valor excede el l√≠mite m√°ximo permitido');
  }
  
  return numberValue;
}

/* UTILIDADES DE PRECISI√ìN NUM√âRICA */

// Convertir valor a centavos para c√°lculos precisos
function toCentavos(pesos) {
  return Math.round(Number(pesos) * 100);
}

// Convertir centavos de vuelta a pesos
function toPesos(centavos) {
  return Math.round(Number(centavos)) / 100;
}

// Sumar valores monetarios con precisi√≥n
function sumarValoresMonetarios(valores) {
  let totalCentavos = 0;
  for (const valor of valores) {
    totalCentavos += toCentavos(valor);
  }
  return toPesos(totalCentavos);
}

// Validar que un n√∫mero sea un entero v√°lido para c√°lculos monetarios
function validarPrecisionMonetaria(valor) {
  const num = Number(valor);
  
  // Verificar que sea un n√∫mero v√°lido
  if (!Number.isFinite(num)) {
    throw new Error('Valor monetario inv√°lido: no es un n√∫mero finito');
  }
  
  // Verificar que no tenga m√°s de 2 decimales (centavos)
  const centavos = Math.round(num * 100);
  const pesosReconstruidos = centavos / 100;
  
  if (Math.abs(num - pesosReconstruidos) > 0.001) {
    console.warn('‚ö†Ô∏è Valor monetario con m√°s de 2 decimales, redondeando:', num, '‚Üí', pesosReconstruidos);
  }
  
  return pesosReconstruidos;
}

// Event listeners para formateo del campo valor - MEJORADO
$('valor').addEventListener('input', function(e) {
  const cursorPosition = e.target.selectionStart;
  const oldValue = e.target.value;
  const oldLength = oldValue.length;
  
  // Solo permitir n√∫meros y formatear
  const numericOnly = oldValue.replace(/[^\d]/g, '');
  
  // Limitar a 12 d√≠gitos m√°ximo
  const limitedValue = numericOnly.substring(0, 12);
  
  // Formatear el valor si no est√° vac√≠o
  const formattedValue = limitedValue ? formatNumberWithSeparators(limitedValue) : '';
  e.target.value = formattedValue;
  
  // Ajustar posici√≥n del cursor
  const newLength = formattedValue.length;
  const lengthDiff = newLength - oldLength;
  const newCursorPosition = Math.max(0, Math.min(cursorPosition + lengthDiff, newLength));
  
  // Establecer nueva posici√≥n del cursor
  setTimeout(() => {
    e.target.setSelectionRange(newCursorPosition, newCursorPosition);
  }, 0);
});

// Validar al hacer focus - mostrar valor sin formato para edici√≥n
$('valor').addEventListener('focus', function(e) {
  const numericValue = getNumericValue(e.target.value);
  if (numericValue !== '') {
    e.target.value = numericValue;
    // Seleccionar todo el texto para facilitar edici√≥n
    setTimeout(() => {
      e.target.select();
    }, 0);
  }
});

// Restaurar formato y validar al perder focus
$('valor').addEventListener('blur', function(e) {
  if (e.target.value !== '') {
    try {
      const numericValue = getNumericValue(e.target.value);
      if (numericValue) {
        // Validar el valor
        validateValorInput(numericValue);
        // Aplicar formato
        e.target.value = formatNumberWithSeparators(numericValue);
        // Remover cualquier indicador de error
        e.target.style.borderColor = '';
        e.target.style.backgroundColor = '';
      }
    } catch (error) {
      // Mostrar error visualmente
      e.target.style.borderColor = '#f44336';
      e.target.style.backgroundColor = 'rgba(244, 67, 54, 0.1)';
      // Mostrar mensaje de error
      showModal('Error de Validaci√≥n', error.message, false);
      // Enfocar de nuevo el campo para correcci√≥n
      setTimeout(() => {
        e.target.focus();
      }, 100);
    }
  }
});

// Funci√≥n para obtener los IDs seleccionados usando la memoria local (Nuevo)
function getSelectedConsignIds(){ 
    return Array.from(selectedConsignIds); 
}

$('btn-verify').addEventListener('click', async ()=>{
  const ids=getSelectedConsignIds(); 
  if(ids.length===0) return showModal('Atenci√≥n', 'Seleccione al menos un movimiento para verificar.', false);
  
  // Obtener los datos de los elementos seleccionados
  const selectedData = currentConsignsSnapshot.filter(c => ids.includes(c.id));
  
  // Validar jerarqu√≠a de verificaci√≥n
  const invalidItems = [];
  const validItems = [];
  
  selectedData.forEach(item => {
    const currentRole = item.verifiedRole;
    const newRole = sessionRole;
    
    // Reglas de jerarqu√≠a CORRECTAS:
    // - Blanco (null) ‚Üí Puede cambiar a Gris (Administrativo) o Amarillo (Gerente) ‚úÖ
    // - Amarillo (Gerente) ‚Üí Puede cambiar a Gris (Administrativo) ‚úÖ  
    // - Gris (Administrativo) ‚Üí NO puede cambiar a Amarillo (Gerente) ‚ùå
    
    if (currentRole === 'Gerente' && newRole === 'Administrativo') {
      // Admin NO puede cambiar Gerente (amarillo) a Admin (gris)
      invalidItems.push(item);
    } else {
      // Todos los dem√°s casos son v√°lidos
      validItems.push(item);
    }
  });
  
  // Si hay elementos inv√°lidos, mostrar mensaje y solo procesar los v√°lidos
  if (invalidItems.length > 0) {
    const message = `‚ö†Ô∏è JERARQU√çA DE VERIFICACI√ìN ‚ö†Ô∏è\n\n` +
      `${invalidItems.length} elemento(s) verificado(s) por Gerente (amarillo) no pueden ser cambiados por Administrador (gris).\n\n` +
      `Solo se verificar√°n ${validItems.length} elemento(s) v√°lido(s) (en blanco).`;
    
    showModal('Advertencia de Jerarqu√≠a', message, false);
  }
  
  // Procesar solo los elementos v√°lidos
  if (validItems.length > 0) {
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones'); 
    const batch = db.batch(); 
    
    validItems.forEach(item => {
      batch.update(col.doc(item.id), { verifiedBy: usuario.usuario, verifiedRole: sessionRole });
    });
    
    await batch.commit();
    
    // Mensaje de √©xito
    const successMessage = invalidItems.length > 0 
      ? `${validItems.length} movimientos verificados correctamente. ${invalidItems.length} elementos omitidos por jerarqu√≠a.`
      : `${validItems.length} movimientos verificados correctamente.`;
    
    // Forzar actualizaci√≥n de totales y rec√°lculo autom√°tico despu√©s de verificar
    console.log('‚úÖ Verificaci√≥n completada, recalculando separadores afectados...');
    
    // Recalcular separadores afectados por cada consignaci√≥n verificada
    for (const item of validItems) {
      await actualizarTotalesVerdes(); // Nueva l√≥gica simple
    }
    
    setTimeout(() => {
      updateSelectedTotals();
      updateTotalGeneral();
    }, 500);
    
    showModal('√âxito', successMessage, false);
  } else if (invalidItems.length > 0) {
    // Solo hab√≠a elementos inv√°lidos
    showModal('Error de Jerarqu√≠a', 'No se pudo verificar ning√∫n elemento. Los elementos verificados por Gerente (amarillo) no pueden ser cambiados por Administrador (gris).', false);
  }
  
  // Limpia la selecci√≥n despu√©s de la acci√≥n
  selectedConsignIds.clear();
});

$('btn-unverify').addEventListener('click', async ()=>{
  const ids=getSelectedConsignIds(); if(ids.length===0) return showModal('Atenci√≥n', 'Seleccione al menos un movimiento para desverificar.', false);
  const selectedData = currentConsignsSnapshot.filter(c => ids.includes(c.id));
  
  if(!await checkSensitiveAction(selectedData)) return;

  const batch = db.batch(); const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
  ids.forEach(id=> batch.update(col.doc(id), { verifiedBy:null, verifiedRole:null })); 
  await batch.commit();
  
  // Rec√°lculo autom√°tico despu√©s de desverificar
  console.log('‚ùå Desverificaci√≥n completada, recalculando separadores afectados...');
  
  // Recalcular separadores afectados por cada consignaci√≥n desverificada
  for (const item of selectedData) {
    if (!item.isSeparator) {
      await actualizarTotalesVerdes(); // Nueva l√≥gica simple
    }
  }
  
  setTimeout(() => {
    updateSelectedTotals();
    updateTotalGeneral();
  }, 500);
  
  // Limpia la selecci√≥n despu√©s de la acci√≥n
  selectedConsignIds.clear();
  showModal('√âxito', `${ids.length} movimientos desverificados.`, false);
});

// FUNCI√ìN DE ELIMINACI√ìN CORREGIDA CON RECALCULO GENERAL
$('btn-delete').addEventListener('click', async ()=>{ 
  if(sessionRole!=='Gerente') return showModal('Error', 'Solo Gerente puede eliminar movimientos.', false); 
  const ids=getSelectedConsignIds(); if(ids.length===0) return showModal('Atenci√≥n', 'Seleccione al menos un movimiento para eliminar.', false);
  const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
  const selectedData = currentConsignsSnapshot.filter(c => ids.includes(c.id));
  
  if(!await checkSensitiveAction(selectedData)) return;

  showModal('Confirmaci√≥n', `¬øEliminar ${ids.length} items permanentemente?`, true, async () => {
    try {
        // 1. Eliminar los documentos seleccionados
        const deletionBatch = db.batch(); 
        ids.forEach(id=> deletionBatch.delete(col.doc(id))); 
        await deletionBatch.commit();
        
        // --- L√ìGICA DE RECALCULO DE CORTES AFECTADOS ---
        const affectedGreenSeparatorIds = new Set();
        // Solo las consignaciones verificadas por Gerente que se acaban de borrar
        const deletedVerifiedConsigns = selectedData.filter(c => c.verifiedRole === 'Gerente' && !c.isSeparator);
        
        // 2. Identificar los cortes (separadores verdes) que conten√≠an el movimiento eliminado
        deletedVerifiedConsigns.forEach(deletedConsign => {
            const deletedDate = deletedConsign.fecha.toDate().getTime();

            // Buscar el Green separator cronol√≥gicamente m√°s NUEVO que la consignaci√≥n eliminada.
            // (Este es el que deb√≠a haber cerrado el ciclo, y el que necesita correcci√≥n de su total)
            const affectedGreenSeparator = currentConsignsSnapshot.find(c => 
                c.type === 'green' && c.fecha.toDate().getTime() > deletedDate
            );
            
            if (affectedGreenSeparator) {
                affectedGreenSeparatorIds.add(affectedGreenSeparator.id);
            }
        });

        if (affectedGreenSeparatorIds.size > 0) {
            
            // 3. Obtener la lista de consignaciones REMANENTES (data fresca post-eliminaci√≥n)
            // Se usa el orden ascendente (orderBy('fecha')) para un c√°lculo cronol√≥gico m√°s f√°cil de los per√≠odos
            const updatedSnapshot = await col.orderBy('fecha').get();
            const updatedConsigns = [];
            updatedSnapshot.forEach(doc => updatedConsigns.push({id: doc.id, ...doc.data()}));

            const updateBatch = db.batch();
            let recalculationCount = 0;

            // 4. Recalcular cada corte afectado
            for (const greenId of affectedGreenSeparatorIds) {
                const affectedGreenSeparator = currentConsignsSnapshot.find(c => c.id === greenId);
                if (!affectedGreenSeparator) continue; 

                // Encontrar el RED separator inmediatamente precedente al corte afectado
                // Como el snapshot local (currentConsignsSnapshot) est√° en orden descendente, 
                // el Red Separator (1ms m√°s nuevo) est√° justo ANTES del Green Separator.
                const greenIndex = currentConsignsSnapshot.indexOf(affectedGreenSeparator);
                let precedingRedSeparator = null;
                if (greenIndex > 0) {
                    precedingRedSeparator = currentConsignsSnapshot[greenIndex - 1];
                }
                // Si el precedingRedSeparator no es un red (o no existe) se usa el inicio de los tiempos
                if (!precedingRedSeparator || precedingRedSeparator.type !== 'red') {
                     precedingRedSeparator = null;
                }


                // Definir el inicio del periodo de c√°lculo
                const queryStart = precedingRedSeparator ? precedingRedSeparator.fecha.toDate().getTime() : new Date(0).getTime();
                const queryEnd = affectedGreenSeparator.fecha.toDate().getTime();

                // Sumar las consignaciones restantes verificadas por Gerente en ese periodo
                const remainingConsignsInPeriod = updatedConsigns
                    .filter(c => 
                        !c.isSeparator && 
                        c.verifiedRole === 'Gerente' && 
                        c.fecha.toDate().getTime() > queryStart && 
                        c.fecha.toDate().getTime() < queryEnd
                    );

                const newCutTotal = remainingConsignsInPeriod.reduce((sum, c) => sum + Number(c.valor || 0), 0);
                
                // Aplicar la actualizaci√≥n al separador verde
                updateBatch.update(col.doc(greenId), { 
                    total: newCutTotal,
                    label: `üö® Recalculado ${new Date().toLocaleDateString()}` 
                });
                recalculationCount++;
            }
            
            await updateBatch.commit();
            // Limpia la selecci√≥n despu√©s de la acci√≥n
            selectedConsignIds.clear();
            
            // Rec√°lculo autom√°tico despu√©s de eliminar (con cortes)
            console.log('üóëÔ∏è Eliminaci√≥n completada, recalculando separadores autom√°ticamente...');
            
            // Usar la nueva l√≥gica simple
            await actualizarTotalesVerdes();
            
            updateSelectedTotals();
            updateTotalGeneral();
            
            showModal('¬°Atenci√≥n!', `Eliminaci√≥n exitosa. Todos los separadores han sido recalculados autom√°ticamente.`, false);
        } else {
            // Limpia la selecci√≥n despu√©s de la acci√≥n
            selectedConsignIds.clear();
            
            // Rec√°lculo autom√°tico despu√©s de eliminar (sin cortes)
            console.log('üóëÔ∏è Eliminaci√≥n completada, recalculando separadores autom√°ticamente...');
            
            // Recalcular separadores afectados por cada consignaci√≥n eliminada
            for (const item of selectedData) {
              if (!item.isSeparator) {
                await actualizarTotalesVerdes(); // Nueva l√≥gica simple
              }
            }
            
            updateSelectedTotals();
            updateTotalGeneral();
            
            showModal('√âxito', `${ids.length} items eliminados. Separadores recalculados autom√°ticamente.`, false);
        }

    } catch(e) { 
        if(e.message !== "Acci√≥n cancelada.") showModal('Error', 'Error al eliminar: '+e.message, false);
    }
  });
});

/** FUNCI√ìN CUADRAR: Calcula total y guarda en base de datos */
$('btn-cuadrar').addEventListener('click', async () => {
  console.log('üî¥ BOT√ìN CUADRAR PRESIONADO - Iniciando diagn√≥stico...');
  console.log('  - Cuenta seleccionada:', selectedAccountId);
  console.log('  - currentConsignsSnapshot.length:', currentConsignsSnapshot?.length || 0);
  
  if (!selectedAccountId) {
    console.log('‚ùå ERROR: No hay cuenta seleccionada');
    return showModal('Atenci√≥n', 'Seleccione una cuenta.', false);
  }
  
  // DETECCI√ìN AUTOM√ÅTICA: Encontrar consignaciones despu√©s del √∫ltimo verde
  let itemsParaCuadrar = [];
  let ultimoSeparadorVerde = null;
  
  // Buscar el √∫ltimo separador verde
  for (let i = currentConsignsSnapshot.length - 1; i >= 0; i--) {
    const item = currentConsignsSnapshot[i];
    if (item.isSeparator && item.type === 'green') {
      ultimoSeparadorVerde = item;
      break;
    }
  }
  
  // Si no hay separador verde, tomar todas las consignaciones
  if (!ultimoSeparadorVerde) {
    itemsParaCuadrar = currentConsignsSnapshot.filter(item => !item.isSeparator);
  } else {
    // Tomar consignaciones despu√©s del √∫ltimo verde
    const ordenVerde = ultimoSeparadorVerde.orden || 0;
    itemsParaCuadrar = currentConsignsSnapshot.filter(item => {
      if (item.isSeparator) return false;
      const ordenItem = item.orden || 0;
      return ordenItem > ordenVerde;
    });
  }
  
  console.log('üìã AN√ÅLISIS AUTOM√ÅTICO:');
  console.log('  - √öltimo separador verde:', ultimoSeparadorVerde ? ultimoSeparadorVerde.id.substring(0, 8) : 'NINGUNO');
  console.log('  - Items para cuadrar encontrados:', itemsParaCuadrar.length);
  
  if(itemsParaCuadrar.length === 0) {
    console.log('‚ùå ERROR: No hay items para cuadrar');
    return showModal('Atenci√≥n', "No hay consignaciones nuevas para cuadrar. Todas est√°n procesadas.", false);
  }

  // VALIDACI√ìN CR√çTICA: Verificar que todas est√©n en amarillo (Gerente)
  const nonYellow = itemsParaCuadrar.filter(i => i.verifiedRole !== 'Gerente');
  const yellowItems = itemsParaCuadrar.filter(i => i.verifiedRole === 'Gerente');
  
  // DEBUG: Mostrar estado de cada item
  console.log('üîç VALIDACI√ìN DE VERIFICACI√ìN:');
  itemsParaCuadrar.forEach((item, index) => {
    const estado = item.verifiedRole === 'Gerente' ? 'üü° AMARILLO' : 
                 item.verifiedRole === 'Administrativo' ? '‚ö™ GRIS' : '‚ö´ BLANCO';
    console.log(`  - Item ${index + 1}: ${estado} - valor=${item.valor}, ref=${item.referencia}`);
  });
  
  console.log(`  - Items en amarillo (‚úÖ): ${yellowItems.length}`);
  console.log(`  - Items sin amarillo (‚ùå): ${nonYellow.length}`);
  
  if(nonYellow.length > 0) {
    console.log('‚ùå ERROR: Hay items sin verificar por Gerente');
    const mensajeAdvertencia = `‚ö†Ô∏è NO SE PUEDE CUADRAR A√öN\n\n` +
      `Hay ${nonYellow.length} consignaciones sin verificar por Gerente:\n` +
      `‚Ä¢ Items en amarillo (verificados): ${yellowItems.length}\n` +
      `‚Ä¢ Items sin amarillo (pendientes): ${nonYellow.length}\n\n` +
      `Por favor, verifique todas las consignaciones (p√≥ngalas en amarillo) antes de poder cuadrar.`;
    
    return showModal('‚ö†Ô∏è Verificaci√≥n Requerida', mensajeAdvertencia, false);
  }

  // CALCULAR TOTAL: Solo items verificados por Gerente
  const totalCalculado = yellowItems
    .reduce((acc, curr) => acc + Number(curr.valor || 0), 0);
  
  console.log('üí∞ TOTAL CALCULADO PARA CUADRE:', totalCalculado);
  
  showModal('Confirmaci√≥n', `¬øRealizar corte?\nTotal a Cuadrar: ${fmtCOP(totalCalculado)}\n(Solo consignaciones verificadas por Gerente)`, true, async () => {
    // *** PROTECCI√ìN CR√çTICA: Establecer bandera de cuadre en proceso ***
    window.isProcessingCuadre = true;
    console.log('üõ°Ô∏è CUADRE INICIADO: Protecci√≥n activada contra interferencias');
    
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    const batch = db.batch();
    
    // Crear fecha en zona horaria de Colombia
    const nowUTC = new Date();
    const colombiaOffset = -5 * 60; // UTC-5 en minutos
    const localOffset = nowUTC.getTimezoneOffset();
    const now = new Date(nowUTC.getTime() + (localOffset + colombiaOffset) * 60000);
    
    // Calcular √≥rdenes para los separadores
    // Los separadores deben ir en la PARTE SUPERIOR (orden menor)
    // Para que aparezcan arriba, necesitamos √≥rdenes menores que las consignaciones existentes
    let minOrden = Number.MAX_SAFE_INTEGER;
    currentConsignsSnapshot.forEach(c => {
      if (c.orden !== undefined) {
        minOrden = Math.min(minOrden, c.orden);
      }
    });
    
    // Si no hay consignaciones, usar orden 1 y 2
    if (minOrden === Number.MAX_SAFE_INTEGER) {
      minOrden = 3; // Para que los separadores sean 1 y 2
    }
    
    const ordenSeparadorVerde = minOrden - 2; // Verde va primero (cierre del per√≠odo anterior)
    const ordenSeparadorRojo = minOrden - 1; // Rojo va despu√©s (inicio del nuevo per√≠odo)
    
    console.log('üî¥ CREANDO CORTE (ARRIBA DE LA TABLA):');
    console.log('  - Orden m√≠nimo actual:', minOrden);
    console.log('  - Orden separador verde (arriba):', ordenSeparadorVerde);
    console.log('  - Orden separador rojo (arriba):', ordenSeparadorRojo);
    console.log('  - Total guardado en separador verde:', totalCalculado);
    
    // Inserta separador Verde (Total del Corte) - GUARDA EL TOTAL CALCULADO
    batch.set(col.doc(), { 
      isSeparator: true, 
      type: 'green', 
      label: now.toLocaleDateString('es-CO'), 
      total: totalCalculado, // AQU√ç SE GUARDA EL TOTAL CALCULADO
      fecha: firebase.firestore.Timestamp.fromDate(now),
      orden: ordenSeparadorVerde,
      cuadreInfo: {
        itemsIncluidos: itemsParaCuadrar.length,
        itemsVerificados: itemsParaCuadrar.filter(i => i.verifiedRole === 'Gerente').length,
        totalCalculado: totalCalculado,
        fechaCuadre: firebase.firestore.FieldValue.serverTimestamp(),
        usuarioCuadre: usuario.usuario
      }
    });
    
    // Inserta separador Rojo (Nuevo punto de partida) - Despu√©s del verde en orden ascendente
    batch.set(col.doc(), { 
      isSeparator: true, 
      type: 'red', 
      label: now.toLocaleDateString('es-CO'), 
      total: 0, 
      fecha: firebase.firestore.Timestamp.fromDate(new Date(now.getTime()+1)),
      orden: ordenSeparadorRojo
    });

    await batch.commit();
    
    // Registrar el cuadre en el historial de ajustes
    await registerAdjustment('cuadre_realizado', {
      totalCuadrado: totalCalculado,
      itemsIncluidos: pendingItems.length,
      fechaCuadre: now.toISOString()
    });
    
    // Limpia la selecci√≥n despu√©s de la acci√≥n
    selectedConsignIds.clear();
    
    // Forzar recarga de la tabla despu√©s de un peque√±o delay para asegurar sincronizaci√≥n
    setTimeout(async () => {
      console.log('üîÑ Forzando recarga de tabla despu√©s del cuadre...');
      // Actualizar totales verdes con nueva l√≥gica
      await calcularTotalesVerdesCorregido();
      // El onSnapshot se disparar√° autom√°ticamente, pero forzamos actualizaci√≥n de totales
      updateSelectedTotals();
      updateTotalGeneral();
      
      // *** LIBERAR PROTECCI√ìN: Permitir actualizaciones normales ***
      window.isProcessingCuadre = false;
      console.log('‚úÖ CUADRE COMPLETADO: Protecci√≥n desactivada, sistema operativo');
      
      showModal('√âxito', `¬°Corte realizado con √©xito!\nTotal cuadrado: ${fmtCOP(totalCalculado)}`, false);
    }, 1000);
  });
});

$('btn-sumar').addEventListener('click', ()=>{
  const ids = getSelectedConsignIds();
  let suma = 0;
  ids.forEach(id=>{
    const item = currentConsignsSnapshot.find(c => c.id === id);
    if(item && !item.isSeparator) {
        suma += Number(item.valor || 0);
    }
  });
  showModal('Suma de Selecci√≥n', `La suma de los √≠tems seleccionados es: ${fmtCOP(suma)}`, false);
});



/* CALCULOS TOTALES - MEJORADO CON CONCURRENCY-SAFE MANAGER */
// ** Total de Cuenta Actual (Depende de la lista actual en memoria) **
let isUpdatingTotals = false; // Flag para prevenir llamadas concurrentes
let updateTimeout = null; // Timeout para liberar flag autom√°ticamente

async function updateSelectedTotals(){ 
  // Prevenir llamadas concurrentes
  if (isUpdatingTotals) {
    console.log('‚è≥ Ya hay una actualizaci√≥n de totales en progreso, saltando...');
    return;
  }
  
  // Validaci√≥n inicial de cuenta seleccionada
  if(!selectedAccountId){ 
    $('total-cuenta').textContent = fmtCOP(0); 
    console.log('‚ùå No hay cuenta seleccionada, estableciendo total en 0');
    return; 
  }
  
  // Verificar cach√© primero
  const cachedTotal = getCachedTotal(selectedAccountId, 'activePeriod');
  if (cachedTotal !== null) {
    updateTotalDisplay(cachedTotal);
    return;
  }
  
  // Marcar como en progreso con timeout de seguridad
  isUpdatingTotals = true;
  updateTimeout = setTimeout(() => {
    console.log('‚ö†Ô∏è Timeout de actualizaci√≥n de totales, liberando flag');
    isUpdatingTotals = false;
  }, 10000); // 10 segundos de timeout
  
  console.log('=== INICIANDO ACTUALIZACI√ìN DE TOTALES (CONCURRENCY-SAFE) ===');
  console.log('Cuenta seleccionada:', selectedAccountId);
  
  try {
    // Verificaci√≥n m√∫ltiple de cuenta seleccionada
    if (!selectedAccountId) {
      console.log('‚ùå Cuenta seleccionada se perdi√≥ durante la ejecuci√≥n');
      $('total-cuenta').textContent = fmtCOP(0);
      return;
    }
    
    console.log('üîÑ Consultando Firebase directamente...');
    
    // Usar consulta optimizada
    const fbDocs = await getConsignationsOptimized(selectedAccountId);
    
    // Verificaci√≥n post-consulta
    if (!selectedAccountId) {
      console.log('‚ùå Cuenta seleccionada cambi√≥ durante la consulta Firebase');
      return;
    }
    
    console.log(`üìä Documentos encontrados en Firebase: ${fbDocs.length}`);
    
    // Calcular total del per√≠odo activo usando nueva l√≥gica simplificada
    const totalActual = calculateActivePeriodTotal(fbDocs);
    
    console.log(`üí∞ TOTAL CALCULADO PARA PER√çODO ACTIVO: ${totalActual}`);
    
    // Guardar en cach√©
    setCachedTotal(selectedAccountId, 'activePeriod', totalActual);
    
    // Verificaci√≥n final antes de actualizar UI
    if (!selectedAccountId) {
      console.log('‚ùå Cuenta seleccionada se perdi√≥ antes de actualizar UI');
      return;
    }
    
    // Actualizar la UI de forma at√≥mica
    updateTotalDisplay(totalActual);
    
  } catch(e) {
    console.error('‚ùå Error al actualizar totales:', e);
    // Solo actualizar a 0 si a√∫n tenemos la misma cuenta seleccionada
    if (selectedAccountId) {
      $('total-cuenta').textContent = fmtCOP(0);
    }
    console.log('Aplicando total 0 como fallback por error');
  } finally {
    // Limpiar timeout y liberar flag
    if (updateTimeout) {
      clearTimeout(updateTimeout);
      updateTimeout = null;
    }
    isUpdatingTotals = false;
  }
  
  console.log('=== FIN ACTUALIZACI√ìN DE TOTALES ===');
}

// Funci√≥n auxiliar para calcular total del per√≠odo activo - MEJORADA CON PRECISI√ìN
function calculateActivePeriodTotal(fbDocs) {
  // Encontrar el √∫ltimo separador verde (per√≠odo m√°s reciente)
  let ultimoSeparadorVerde = null;
  fbDocs.forEach(doc => {
    if (doc.isSeparator && doc.type === 'green') {
      if (!ultimoSeparadorVerde || (doc.orden || 0) < (ultimoSeparadorVerde.orden || 0)) {
        ultimoSeparadorVerde = doc;
      }
    }
  });
  
  let valoresParaSumar = [];
  
  if (ultimoSeparadorVerde) {
    // Hay separadores: sumar consignaciones ENCIMA del √∫ltimo separador verde
    console.log('üîç Calculando per√≠odo activo desde separador verde (orden:', ultimoSeparadorVerde.orden, ')');
    
    fbDocs.forEach(doc => {
      if (!doc.isSeparator) {
        const ordenDoc = doc.orden || 0;
        const ordenVerde = ultimoSeparadorVerde.orden || 0;
        
        // L√ìGICA CORREGIDA: Despu√©s del cuadre, las consignaciones tienen orden negativo
        // Si el separador verde tiene orden negativo, las consignaciones activas son las que tienen orden MAYOR (menos negativo)
        let incluirConsignacion = false;
        
        if (ordenVerde < 0) {
          // Separador verde con orden negativo (despu√©s del cuadre)
          // Incluir consignaciones con orden mayor (menos negativo o positivo)
          incluirConsignacion = ordenDoc < ordenVerde;
        } else {
          // Separador verde con orden positivo (antes del cuadre)
          // Incluir consignaciones con orden menor
          incluirConsignacion = ordenDoc < ordenVerde;
        }
        
        if (incluirConsignacion) {
          const valorValidado = validarPrecisionMonetaria(doc.valor || 0);
          valoresParaSumar.push(valorValidado);
          console.log(`‚úÖ Sumando consignaci√≥n del per√≠odo activo: ${valorValidado} (orden: ${ordenDoc})`);
        }
      }
    });
    
  } else {
    // No hay separadores: sumar todas las consignaciones
    console.log('üîç No hay separadores, sumando todas las consignaciones');
    
    fbDocs.forEach(doc => {
      if (!doc.isSeparator) {
        const valorValidado = validarPrecisionMonetaria(doc.valor || 0);
        valoresParaSumar.push(valorValidado);
        console.log(`‚úÖ Sumando consignaci√≥n (sin cortes): ${valorValidado}`);
      }
    });
  }
  
  // Usar suma con precisi√≥n monetaria
  const totalActual = sumarValoresMonetarios(valoresParaSumar);
  console.log(`üí∞ TOTAL CALCULADO CON PRECISI√ìN: ${totalActual}`);
  
  return totalActual;
}

// Funci√≥n auxiliar para actualizar la UI de forma at√≥mica
function updateTotalDisplay(totalActual) {
  const totalElement = $('total-cuenta');
  const formattedTotal = fmtCOP(totalActual);
  
  console.log('üéØ ACTUALIZANDO UI:');
  console.log('  - Elemento encontrado:', !!totalElement);
  console.log('  - Total sin formato:', totalActual);
  console.log('  - Total formateado:', formattedTotal);
  console.log('  - Valor actual en UI:', totalElement ? totalElement.textContent : 'ELEMENTO NO ENCONTRADO');
  
  if (totalElement) {
    // Actualizaci√≥n at√≥mica con m√∫ltiples m√©todos para asegurar compatibilidad
    totalElement.textContent = formattedTotal;
    totalElement.innerHTML = formattedTotal;
    totalElement.innerText = formattedTotal;
    
    // Forzar re-render visual
    totalElement.style.display = 'none';
    totalElement.offsetHeight; // Trigger reflow
    totalElement.style.display = '';
    
    console.log('  - Nuevo valor en UI:', totalElement.textContent);
    console.log('‚úÖ UI ACTUALIZADA EXITOSAMENTE');
    
    // Verificaci√≥n post-actualizaci√≥n
    setTimeout(() => {
      console.log('üîç VERIFICACI√ìN POST-ACTUALIZACI√ìN:');
      console.log('  - Valor final en UI:', totalElement.textContent);
    }, 100);
    
  } else {
    console.error('‚ùå ERROR: Elemento total-cuenta no encontrado');
  }
}

/* OPTIMIZACIONES DE RENDIMIENTO */

// Cach√© inteligente para totales calculados
const totalsCache = new Map();
const CACHE_EXPIRY_MS = 30000; // 30 segundos

// Funci√≥n para obtener clave de cach√©
function getCacheKey(accountId, operation) {
  return `${accountId}_${operation}`;
}

// Funci√≥n para obtener total desde cach√©
function getCachedTotal(accountId, operation) {
  const key = getCacheKey(accountId, operation);
  const cached = totalsCache.get(key);
  
  if (cached && (Date.now() - cached.timestamp) < CACHE_EXPIRY_MS) {
    console.log('üíæ Usando total desde cach√©:', operation, '‚Üí', cached.value);
    return cached.value;
  }
  
  return null;
}

// Funci√≥n para guardar total en cach√©
function setCachedTotal(accountId, operation, value) {
  const key = getCacheKey(accountId, operation);
  totalsCache.set(key, {
    value: value,
    timestamp: Date.now()
  });
  console.log('üíæ Total guardado en cach√©:', operation, '‚Üí', value);
}

// Funci√≥n para invalidar cach√©
function invalidateCache(accountId) {
  const keysToDelete = [];
  for (const key of totalsCache.keys()) {
    if (key.startsWith(accountId)) {
      keysToDelete.push(key);
    }
  }
  
  keysToDelete.forEach(key => totalsCache.delete(key));
  console.log('üóëÔ∏è Cach√© invalidado para cuenta:', accountId, '(', keysToDelete.length, 'entradas)');
}

// Debouncing para actualizaciones m√∫ltiples
let updateDebounceTimeout = null;
const DEBOUNCE_DELAY_MS = 500;

function debouncedUpdateTotals() {
  if (updateDebounceTimeout) {
    clearTimeout(updateDebounceTimeout);
  }
  
  updateDebounceTimeout = setTimeout(() => {
    console.log('‚è±Ô∏è Ejecutando actualizaci√≥n de totales debounced');
    updateSelectedTotals();
    updateTotalGeneral();
    updateDebounceTimeout = null;
  }, DEBOUNCE_DELAY_MS);
  
  console.log('‚è±Ô∏è Actualizaci√≥n de totales programada (debounced)');
}

// Funci√≥n optimizada para consultas Firebase con l√≠mites
async function getConsignationsOptimized(accountId, limit = null) {
  let query = db.collection('cuentas').doc(accountId).collection('consignaciones')
    .orderBy('orden', 'asc');
  
  if (limit) {
    query = query.limit(limit);
  }
  
  const startTime = Date.now();
  const snapshot = await query.get();
  const endTime = Date.now();
  
  console.log(`‚ö° Consulta Firebase optimizada: ${snapshot.size} docs en ${endTime - startTime}ms`);
  
  const items = [];
  snapshot.forEach(doc => items.push({id: doc.id, ...doc.data()}));
  
  return items;
}

// Funci√≥n para detectar operaciones pesadas y mostrar indicador
function showCalculationIndicator(show = true) {
  const indicator = document.getElementById('calculation-indicator');
  if (!indicator && show) {
    // Crear indicador si no existe
    const div = document.createElement('div');
    div.id = 'calculation-indicator';
    div.innerHTML = 'üîÑ Recalculando...';
    div.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(76, 175, 80, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      z-index: 1000;
      backdrop-filter: blur(5px);
    `;
    document.body.appendChild(div);
  } else if (indicator) {
    if (show) {
      indicator.style.display = 'block';
    } else {
      indicator.style.display = 'none';
    }
  }
}

/* REAL-TIME CALCULATION ENGINE - MOTOR DE C√ÅLCULO EN TIEMPO REAL OPTIMIZADO */

// Identificar separadores verdes afectados por un cambio en una consignaci√≥n
function identifyAffectedSeparators(consignation, allItems) {
  const affectedSeparators = [];
  const consignationOrder = consignation.orden || 0;
  
  console.log('üîç IDENTIFICANDO SEPARADORES AFECTADOS:');
  console.log('  - Consignaci√≥n orden:', consignationOrder);
  
  // Encontrar todos los separadores verdes que podr√≠an incluir esta consignaci√≥n
  for (const item of allItems) {
    if (item.isSeparator && item.type === 'green') {
      const separatorOrder = item.orden || 0;
      
      // Un separador verde incluye consignaciones que est√°n ANTES de √©l (orden menor)
      if (consignationOrder < separatorOrder) {
        // Verificar si hay un separador rojo entre la consignaci√≥n y el verde
        const redSeparatorBetween = allItems.find(s => 
          s.isSeparator && 
          s.type === 'red' && 
          s.orden > consignationOrder && 
          s.orden < separatorOrder
        );
        
        if (!redSeparatorBetween) {
          // No hay separador rojo entre ellos, este verde incluye la consignaci√≥n
          affectedSeparators.push(item);
          console.log(`  ‚úÖ Separador verde afectado (orden ${separatorOrder})`);
        } else {
          console.log(`  ‚ùå Separador verde NO afectado (orden ${separatorOrder}) - hay rojo intermedio`);
        }
      }
    }
  }
  
  console.log(`  üìä Total separadores afectados: ${affectedSeparators.length}`);
  return affectedSeparators;
}

// Calcular el total correcto para un separador verde espec√≠fico - MEJORADO CON PRECISI√ìN
async function calculateSeparatorTotal(separatorId, accountId) {
  console.log('üßÆ CALCULANDO TOTAL DE SEPARADOR CON PRECISI√ìN:', separatorId);
  
  try {
    // Obtener todos los items ordenados
    const snapshot = await db.collection('cuentas').doc(accountId).collection('consignaciones')
      .orderBy('orden', 'asc').get();
    
    const allItems = [];
    snapshot.forEach(doc => allItems.push({id: doc.id, ...doc.data()}));
    
    // Encontrar el separador verde espec√≠fico
    const greenSeparator = allItems.find(item => item.id === separatorId);
    if (!greenSeparator) {
      console.error('‚ùå Separador verde no encontrado:', separatorId);
      return 0;
    }
    
    const greenOrder = greenSeparator.orden || 0;
    console.log('  - Separador verde orden:', greenOrder);
    
    // Encontrar el separador rojo anterior (el que tiene orden menor m√°s cercano)
    let previousRedSeparator = null;
    for (const item of allItems) {
      if (item.isSeparator && item.type === 'red' && (item.orden || 0) < greenOrder) {
        if (!previousRedSeparator || (item.orden || 0) > (previousRedSeparator.orden || 0)) {
          previousRedSeparator = item;
        }
      }
    }
    
    const startOrder = previousRedSeparator ? previousRedSeparator.orden : --Infinity;
    console.log('  - Separador rojo anterior orden:', previousRedSeparator?.orden || 'ninguno');
    console.log('  - Rango de c√°lculo: >', startOrder, 'y <', greenOrder);
    
    // Recopilar valores para suma con precisi√≥n
    const valoresParaSumar = [];
    let consignationCount = 0;
    
    for (const item of allItems) {
      if (!item.isSeparator && 
          item.verifiedRole === 'Gerente' && 
          (item.orden || 0) > startOrder && 
          (item.orden || 0) < greenOrder) {
        
        const valorValidado = validarPrecisionMonetaria(item.valor || 0);
        valoresParaSumar.push(valorValidado);
        consignationCount++;
        console.log(`    ‚úÖ Incluida: ${valorValidado}`);
      }
    }
    
    // Calcular total con precisi√≥n monetaria
    const total = sumarValoresMonetarios(valoresParaSumar);
    console.log(`  üí∞ TOTAL CALCULADO CON PRECISI√ìN: ${total} (${consignationCount} consignaciones)`);
    
    return total;
    
  } catch (error) {
    console.error('‚ùå Error calculando total de separador:', error);
    return 0;
  }
}

// Recalcular m√∫ltiples separadores en lote usando Firebase batch - OPTIMIZADO
async function batchRecalculateSeparators(separatorIds, accountId) {
  if (!separatorIds || separatorIds.length === 0) {
    console.log('‚ÑπÔ∏è No hay separadores para recalcular');
    return;
  }
  
  console.log('üîÑ RECALCULANDO SEPARADORES EN LOTE (OPTIMIZADO):', separatorIds.length);
  
  // Mostrar indicador de c√°lculo para operaciones pesadas
  if (separatorIds.length > 3) {
    showCalculationIndicator(true);
  }
  
  try {
    const batch = db.batch();
    const updates = [];
    const startTime = Date.now();
    
    // Calcular nuevo total para cada separador
    for (const separatorId of separatorIds) {
      const newTotal = await calculateSeparatorTotal(separatorId, accountId);
      const separatorRef = db.collection('cuentas').doc(accountId).collection('consignaciones').doc(separatorId);
      
      batch.update(separatorRef, {
        total: newTotal,
        lastRecalculation: firebase.firestore.Timestamp.now(),
        calculationMethod: 'auto'
      });
      
      updates.push({ id: separatorId, total: newTotal });
      console.log(`  üìù Preparando actualizaci√≥n: ${separatorId} ‚Üí ${fmtCOP(newTotal)}`);
    }
    
    // Ejecutar todas las actualizaciones en una sola transacci√≥n
    await batch.commit();
    
    const endTime = Date.now();
    console.log(`‚úÖ REC√ÅLCULO EN LOTE COMPLETADO en ${endTime - startTime}ms`);
    
    updates.forEach(update => {
      console.log(`  ‚úÖ ${update.id}: ${fmtCOP(update.total)}`);
    });
    
    // Invalidar cach√© despu√©s de rec√°lculo
    invalidateCache(accountId);
    
    return updates;
    
  } catch (error) {
    console.error('‚ùå Error en rec√°lculo en lote:', error);
    throw error;
  } finally {
    // Ocultar indicador de c√°lculo
    showCalculationIndicator(false);
  }
}



// ** Total General (Implementaci√≥n m√°s robusta sin CollectionGroup) **
async function updateTotalGeneral(){ 
  try{ 
    // 1. Obtener todas las cuentas
    const accountsSnapshot = await db.collection('cuentas').get();
    let total = 0; 
    
    // 2. Obtener las consignaciones para cada cuenta (en paralelo)
    const consignPromises = accountsSnapshot.docs.map(doc => 
        db.collection('cuentas').doc(doc.id).collection('consignaciones').get()
    );
    
    const allConsignSnapshots = await Promise.all(consignPromises);

    // 3. Sumar todas las consignaciones no-separadoras de todas las cuentas
    allConsignSnapshots.forEach(snap => {
        snap.forEach(d => {
            const data = d.data();
            if(!data.isSeparator) {
                total += Number(data.valor || 0);
            }
        });
    });

    $('total-general').textContent = fmtCOP(total); 
  }catch(e){ 
    console.error("Error al actualizar total general (VERIFIQUE CONSOLA):", e);
    // En caso de fallo, se asegura de mostrar 0 para evitar valores incorrectos o vac√≠os.
    $('total-general').textContent = fmtCOP(0); 
  } 
}
// Se llama al inicio en subscribeAccounts y luego cada vez que se actualiza una cuenta.
setInterval(updateTotalGeneral,15000); 

/* BUSQUEDA */
const filter = (id) => {
    const q = $(id).value.toLowerCase();
    document.querySelectorAll('#accounts-list .account-item').forEach(it => {
        it.style.display = it.textContent.toLowerCase().includes(q) ? '' : 'none';
    });
};
$('search-name').addEventListener('input', () => filter('search-name'));
$('search-account').addEventListener('input', () => filter('search-account'));

window.addEventListener('load', ()=>{ 
    if(!usuario){ return; } 
    $('modal-options').classList.remove('hidden'); $('manager-pass').value=''; 
});
window.addEventListener('beforeunload', ()=>{ if(consignsUnsub) consignsUnsub(); });

// Funciones para el modal de datos grandes
function showDataModal(title, label, value, icon) {
    document.getElementById('data-modal-title').textContent = title;
    document.getElementById('data-modal-label').textContent = label;
    document.getElementById('data-modal-value').textContent = value;
    document.getElementById('data-modal-icon').textContent = icon;
    document.getElementById('data-modal').style.display = 'block';
}

function closeDataModal() {
    document.getElementById('data-modal').style.display = 'none';
}

// Cerrar modal al hacer clic fuera
window.addEventListener('click', function(event) {
    const dataModal = document.getElementById('data-modal');
    if (event.target === dataModal) {
        closeDataModal();
    }
});

// Cerrar modal con Escape
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        closeDataModal();
    }
});

// Agregar eventos de doble clic a las tarjetas de totales
setTimeout(() => {
    // Total General
    const totalGeneralCard = document.querySelector('.top-totals .card:nth-child(1)');
    if (totalGeneralCard) {
        totalGeneralCard.addEventListener('dblclick', function() {
            const value = document.getElementById('total-general').textContent;
            showDataModal('üí∞ TOTAL GENERAL', 'Suma de todas las cuentas', value, 'üè¶');
        });
        totalGeneralCard.style.cursor = 'pointer';
        totalGeneralCard.title = 'Doble clic para ver en grande';
    }

    // Total Cuenta Actual
    const totalCuentaCard = document.querySelector('.top-totals .card:nth-child(2)');
    if (totalCuentaCard) {
        totalCuentaCard.addEventListener('dblclick', function() {
            const value = document.getElementById('total-cuenta').textContent;
            const accountName = selectedAccountName || 'Cuenta Actual';
            showDataModal('üè¶ TOTAL CUENTA ACTUAL', accountName, value, 'üí≥');
        });
        totalCuentaCard.style.cursor = 'pointer';
        totalCuentaCard.title = 'Doble clic para ver en grande';
    }

    // Usuario
    const usuarioCard = document.querySelector('.top-totals .card:nth-child(3)');
    if (usuarioCard) {
        usuarioCard.addEventListener('dblclick', function() {
            const value = document.getElementById('user-info').textContent;
            showDataModal('üë§ USUARIO ACTIVO', 'Sesi√≥n actual', value, 'üîê');
        });
        usuarioCard.style.cursor = 'pointer';
        usuarioCard.title = 'Doble clic para ver en grande';
    }
}, 1000);

// ===== NUEVA L√ìGICA SIMPLE Y CONFIABLE PARA TOTALES VERDES =====
async function nuevaLogicaTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('‚ùå No hay cuenta seleccionada');
    return;
  }
  
  console.log('üîÑ NUEVA L√ìGICA: Recalculando todos los separadores verdes...');
  
  try {
    // 1. Obtener todos los datos de Firebase
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    
    // 2. Ordenar por orden ascendente
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`üìä Total items encontrados: ${allItems.length}`);
    
    // 3. Encontrar todos los separadores verdes
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`üü¢ Separadores verdes encontrados: ${separadoresVerdes.length}`);
    
    if (separadoresVerdes.length === 0) {
      console.log('‚ÑπÔ∏è No hay separadores verdes para actualizar');
      return;
    }
    
    // 4. Para cada separador verde, calcular su total
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`\nüü¢ PROCESANDO SEPARADOR: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      // 5. Encontrar el separador rojo anterior m√°s cercano
      let ordenRojoAnterior = --Infinity;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) < ordenVerde) {
          ordenRojoAnterior = Math.max(ordenRojoAnterior, item.orden || 0);
        }
      }
      
      console.log(`üî¥ Separador rojo anterior: ${ordenRojoAnterior === --Infinity ? 'NINGUNO' : ordenRojoAnterior}`);
      console.log(`üìè Rango de c√°lculo: ${ordenRojoAnterior === --Infinity ? '-‚àû' : ordenRojoAnterior} < consignaci√≥n < ${ordenVerde}`);
      
      // 6. Sumar consignaciones amarillas (Gerente) en el per√≠odo
      let total = 0;
      let conteo = 0;
      const consignacionesEncontradas = [];
      
      for (const item of allItems) {
        // Solo consignaciones (no separadores)
        if (item.isSeparator) continue;
        
        // Solo las verificadas por Gerente (amarillas)
        if (item.verifiedRole !== 'Gerente') continue;
        
        // Solo las que est√°n en el per√≠odo (despu√©s del rojo anterior y antes del verde)
        const ordenItem = item.orden || 0;
        
        // L√ìGICA CORREGIDA: Manejar separadores con orden negativo
        let incluirConsignacion = false;
        
        if (ordenVerde < 0) {
          // Separador verde con orden negativo (despu√©s del cuadre)
          // Las consignaciones activas son las que tienen orden POSITIVO
          incluirConsignacion = ordenItem > 0;
        } else {
          // Separador verde con orden positivo (antes del cuadre)
          // Las consignaciones activas est√°n entre el rojo anterior y el verde
          incluirConsignacion = ordenItem > ordenRojoAnterior && ordenItem < ordenVerde;
        }
        
        if (incluirConsignacion) {
          total += Number(item.valor || 0);
          conteo++;
          consignacionesEncontradas.push({
            id: item.id.substring(0, 8),
            valor: item.valor,
            orden: ordenItem,
            referencia: item.referencia
          });
        }
      }
      
      console.log(`üìã Consignaciones encontradas:`, consignacionesEncontradas);
      console.log(`üü¢ Separador ${separadorVerde.id.substring(0, 8)}: ${conteo} consignaciones = $${total}`);
      
      // 7. Actualizar en Firebase si cambi√≥
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`‚úÖ Actualizando: ${separadorVerde.total} ‚Üí ${total}`);
      } else {
        console.log(`‚ÑπÔ∏è Ya correcto: ${total}`);
      }
    }
    
    // 8. Guardar todos los cambios
    await batch.commit();
    console.log('‚úÖ NUEVA L√ìGICA: Rec√°lculo completado exitosamente');
    
    // 9. Actualizar la UI
    // La UI se actualizar√° autom√°ticamente a trav√©s del onSnapshot existente
    
  } catch (error) {
    console.error('‚ùå Error en nueva l√≥gica:', error);
  }
}

// Funci√≥n de depuraci√≥n mejorada
async function debugearDatosCompleto() {
  if (!selectedAccountId) {
    console.log('‚ùå No hay cuenta seleccionada');
    return;
  }
  
  console.log('üîç DEPURANDO DATOS COMPLETO...');
  
  const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
  const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
  
  console.log(`üìã TOTAL DE ITEMS: ${allItems.length}`);
  
  // Mostrar estructura ordenada
  console.log('\nüìã ESTRUCTURA COMPLETA (ordenada):');
  allItems.forEach((item, index) => {
    if (item.isSeparator) {
      console.log(`${index + 1}. üî¥üü¢ SEPARADOR ${item.type.toUpperCase()}: orden ${item.orden}, total: ${item.total || 0}`);
    } else {
      const estado = item.verifiedRole === 'Gerente' ? 'üü° AMARILLO' : 
                   item.verifiedRole === 'Administrativo' ? '‚ö™ GRIS' : '‚ö´ BLANCO';
      console.log(`${index + 1}. ${estado}: $${item.valor}, ref: ${item.referencia}, orden: ${item.orden}`);
    }
  });
  
  // Estad√≠sticas
  const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
  const separadoresRojos = allItems.filter(item => item.isSeparator && item.type === 'red');
  const consignacionesAmarillas = allItems.filter(item => !item.isSeparator && item.verifiedRole === 'Gerente');
  
  console.log(`\nüìä ESTAD√çSTICAS:`);
  console.log(`üü¢ Separadores verdes: ${separadoresVerdes.length}`);
  console.log(`üî¥ Separadores rojos: ${separadoresRojos.length}`);
  console.log(`üü° Consignaciones amarillas: ${consignacionesAmarillas.length}`);
  
  // Mostrar totales actuales de separadores verdes
  console.log(`\nüí∞ TOTALES ACTUALES DE SEPARADORES VERDES:`);
  separadoresVerdes.forEach(sep => {
    console.log(`  - ${sep.id.substring(0, 8)}: $${sep.total || 0} (orden: ${sep.orden})`);
  });
}

// Funci√≥n de prueba completa
async function probarNuevaLogicaCompleta() {
  console.log('üß™ PROBANDO NUEVA L√ìGICA COMPLETA...');
  
  if (!selectedAccountId) {
    console.log('‚ùå Selecciona una cuenta primero');
    return;
  }
  
  console.log('1Ô∏è‚É£ Depurando datos actuales...');
  await debugearDatosCompleto();
  
  console.log('\n2Ô∏è‚É£ Ejecutando nueva l√≥gica...');
  await nuevaLogicaTotalesVerdes();
  
  console.log('\n3Ô∏è‚É£ Verificando resultados...');
  await debugearDatosCompleto();
  
  console.log('‚úÖ PRUEBA COMPLETA TERMINADA');
}

// Actualizar las funciones existentes para usar la nueva l√≥gica
// (Funci√≥n duplicada removida - usar la implementaci√≥n principal en l√≠nea 2116)

// ===== NUEVA L√ìGICA SIMPLE Y CONFIABLE PARA TOTALES VERDES =====
async function nuevaLogicaTotalesVerdes() {
  if (!selectedAccountId) {
    console.log('‚ùå No hay cuenta seleccionada');
    return;
  }
  
  console.log('üîÑ NUEVA L√ìGICA: Recalculando todos los separadores verdes...');
  
  try {
    // 1. Obtener todos los datos de Firebase
    const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
    const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    
    // 2. Ordenar por orden ascendente
    allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
    
    console.log(`üìä Total items encontrados: ${allItems.length}`);
    
    // 3. Encontrar todos los separadores verdes
    const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
    console.log(`üü¢ Separadores verdes encontrados: ${separadoresVerdes.length}`);
    
    if (separadoresVerdes.length === 0) {
      console.log('‚ÑπÔ∏è No hay separadores verdes para actualizar');
      return;
    }
    
    // 4. Para cada separador verde, calcular su total
    const batch = db.batch();
    const col = db.collection('cuentas').doc(selectedAccountId).collection('consignaciones');
    
    for (const separadorVerde of separadoresVerdes) {
      const ordenVerde = separadorVerde.orden || 0;
      console.log(`\nüü¢ PROCESANDO SEPARADOR: ${separadorVerde.id.substring(0, 8)}, orden: ${ordenVerde}`);
      
      // 5. Encontrar el separador rojo anterior m√°s cercano
      let ordenRojoAnterior = --Infinity;
      for (const item of allItems) {
        if (item.isSeparator && item.type === 'red' && (item.orden || 0) < ordenVerde) {
          ordenRojoAnterior = Math.max(ordenRojoAnterior, item.orden || 0);
        }
      }
      
      console.log(`üî¥ Separador rojo anterior: ${ordenRojoAnterior === --Infinity ? 'NINGUNO' : ordenRojoAnterior}`);
      console.log(`üìè Rango de c√°lculo: ${ordenRojoAnterior === --Infinity ? '-‚àû' : ordenRojoAnterior} < consignaci√≥n < ${ordenVerde}`);
      
      // 6. Sumar consignaciones amarillas (Gerente) en el per√≠odo
      let total = 0;
      let conteo = 0;
      const consignacionesEncontradas = [];
      
      for (const item of allItems) {
        // Solo consignaciones (no separadores)
        if (item.isSeparator) continue;
        
        // Solo las verificadas por Gerente (amarillas)
        if (item.verifiedRole !== 'Gerente') continue;
        
        // Solo las que est√°n en el per√≠odo (despu√©s del rojo anterior y antes del verde)
        const ordenItem = item.orden || 0;
        
        // L√ìGICA CORREGIDA: Manejar separadores con orden negativo
        let incluirConsignacion = false;
        
        if (ordenVerde < 0) {
          // Separador verde con orden negativo (despu√©s del cuadre)
          // Las consignaciones activas son las que tienen orden POSITIVO
          incluirConsignacion = ordenItem > 0;
        } else {
          // Separador verde con orden positivo (antes del cuadre)
          // Las consignaciones activas est√°n entre el rojo anterior y el verde
          incluirConsignacion = ordenItem > ordenRojoAnterior && ordenItem < ordenVerde;
        }
        
        if (incluirConsignacion) {
          total += Number(item.valor || 0);
          conteo++;
          consignacionesEncontradas.push({
            id: item.id.substring(0, 8),
            valor: item.valor,
            orden: ordenItem,
            referencia: item.referencia
          });
        }
      }
      
      console.log(`üìã Consignaciones encontradas:`, consignacionesEncontradas);
      console.log(`üü¢ Separador ${separadorVerde.id.substring(0, 8)}: ${conteo} consignaciones = $${total}`);
      
      // 7. Actualizar en Firebase si cambi√≥
      if (separadorVerde.total !== total) {
        batch.update(col.doc(separadorVerde.id), { total: total });
        console.log(`‚úÖ Actualizando: ${separadorVerde.total} ‚Üí ${total}`);
      } else {
        console.log(`‚ÑπÔ∏è Ya correcto: ${total}`);
      }
    }
    
    // 8. Guardar todos los cambios
    await batch.commit();
    console.log('‚úÖ NUEVA L√ìGICA: Rec√°lculo completado exitosamente');
    
    // 9. Actualizar la UI
    // La UI se actualizar√° autom√°ticamente a trav√©s del onSnapshot existente
    
  } catch (error) {
    console.error('‚ùå Error en nueva l√≥gica:', error);
  }
}

// Funci√≥n de depuraci√≥n mejorada
async function debugearDatosCompleto() {
  if (!selectedAccountId) {
    console.log('‚ùå No hay cuenta seleccionada');
    return;
  }
  
  console.log('üîç DEPURANDO DATOS COMPLETO...');
  
  const snapshot = await db.collection('cuentas').doc(selectedAccountId).collection('consignaciones').get();
  const allItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  allItems.sort((a, b) => (a.orden || 0) - (b.orden || 0));
  
  console.log(`üìã TOTAL DE ITEMS: ${allItems.length}`);
  
  // Mostrar estructura ordenada
  console.log('\nüìã ESTRUCTURA COMPLETA (ordenada):');
  allItems.forEach((item, index) => {
    if (item.isSeparator) {
      console.log(`${index + 1}. üî¥üü¢ SEPARADOR ${item.type.toUpperCase()}: orden ${item.orden}, total: ${item.total || 0}`);
    } else {
      const estado = item.verifiedRole === 'Gerente' ? 'üü° AMARILLO' : 
                   item.verifiedRole === 'Administrativo' ? '‚ö™ GRIS' : '‚ö´ BLANCO';
      console.log(`${index + 1}. ${estado}: $${item.valor}, ref: ${item.referencia}, orden: ${item.orden}`);
    }
  });
  
  // Estad√≠sticas
  const separadoresVerdes = allItems.filter(item => item.isSeparator && item.type === 'green');
  const separadoresRojos = allItems.filter(item => item.isSeparator && item.type === 'red');
  const consignacionesAmarillas = allItems.filter(item => !item.isSeparator && item.verifiedRole === 'Gerente');
  
  console.log(`\nüìä ESTAD√çSTICAS:`);
  console.log(`üü¢ Separadores verdes: ${separadoresVerdes.length}`);
  console.log(`üî¥ Separadores rojos: ${separadoresRojos.length}`);
  console.log(`üü° Consignaciones amarillas: ${consignacionesAmarillas.length}`);
  
  // Mostrar totales actuales de separadores verdes
  console.log(`\nüí∞ TOTALES ACTUALES DE SEPARADORES VERDES:`);
  separadoresVerdes.forEach(sep => {
    console.log(`  - ${sep.id.substring(0, 8)}: $${sep.total || 0} (orden: ${sep.orden})`);
  });
}

// Funci√≥n de prueba completa
async function probarNuevaLogicaCompleta() {
  console.log('üß™ PROBANDO NUEVA L√ìGICA COMPLETA...');
  
  if (!selectedAccountId) {
    console.log('‚ùå Selecciona una cuenta primero');
    return;
  }
  
  console.log('1Ô∏è‚É£ Depurando datos actuales...');
  await debugearDatosCompleto();
  
  console.log('\n2Ô∏è‚É£ Ejecutando nueva l√≥gica...');
  await nuevaLogicaTotalesVerdes();
  
  console.log('\n3Ô∏è‚É£ Verificando resultados...');
  await debugearDatosCompleto();
  
  console.log('‚úÖ PRUEBA COMPLETA TERMINADA');
}

// Actualizar las funciones existentes para usar la nueva l√≥gica
// (Funci√≥n duplicada removida - usar la implementaci√≥n principal en l√≠nea 2116)

// *** MEJORA COMPLETA: Enter en cualquier modal y auto-selecci√≥n de campo ***
// Agregar eventos para mejorar la experiencia de usuario
document.addEventListener('DOMContentLoaded', function() {
  
  // *** MEJORA 1: Auto-seleccionar campo de contrase√±a al elegir Gerente ***
  const gerenteRadio = document.querySelector('input[name="sessionRole"][value="Gerente"]');
  const managerPassArea = document.getElementById('manager-pass-area');
  const managerPassField = document.getElementById('manager-pass');
  
  if (gerenteRadio && managerPassArea && managerPassField) {
    gerenteRadio.addEventListener('change', function() {
      if (this.value === 'Gerente') {
        // Mostrar √°rea de contrase√±a
        managerPassArea.classList.remove('hidden');
        
        // Peque√±a pausa para que el campo sea visible y luego seleccionarlo
        setTimeout(() => {
          managerPassField.focus();
          managerPassField.select();
        }, 100);
      }
    });
  }
  
  // *** MEJORA 2: Enter en cualquier campo de contrase√±a de cualquier modal ***
  function setupEnterKeyForPasswordFields() {
    // Para el campo manager-pass (modal de opciones)
    if (managerPassField) {
      managerPassField.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          // Buscar y hacer clic en el bot√≥n de aceptar del modal de opciones
          const optionsModal = document.getElementById('modal-options');
          if (optionsModal && !optionsModal.classList.contains('hidden')) {
            // Buscar bot√≥n de guardar/cerrar en el modal de opciones
            const acceptBtn = optionsModal.querySelector('.btn:not(.ghost)');
            if (acceptBtn) {
              acceptBtn.click();
            }
          }
        }
      });
    }
    
    // Para el campo modal-password-input (modal de verificaci√≥n)
    const modalPassField = document.getElementById('modal-password-input');
    if (modalPassField) {
      modalPassField.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          // Hacer clic en el bot√≥n modal-ok-btn
          const okBtn = document.getElementById('modal-ok-btn');
          if (okBtn) {
            okBtn.click();
          }
        }
      });
    }
    
    // *** MEJORA 3: Enter en cualquier input dentro de cualquier modal ***
    // Buscar todos los modales que puedan tener botones de aceptar
    const allModals = document.querySelectorAll('.modal:not(.hidden)');
    
    allModals.forEach(modal => {
      // Agregar Enter a todos los inputs dentro del modal
      const inputs = modal.querySelectorAll('input[type="text"], input[type="password"], input[type="number"]');
      
      inputs.forEach(input => {
        // Evitar duplicar eventos
        if (!input.hasAttribute('data-enter-setup')) {
          input.setAttribute('data-enter-setup', 'true');
          
          input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
              e.preventDefault();
              
              // Buscar bot√≥n de aceptar principal en este modal
              const acceptBtn = modal.querySelector('.btn:not(.ghost), button[type="submit"]');
              if (acceptBtn && acceptBtn.style.display !== 'none') {
                acceptBtn.click();
              }
            }
          });
        }
      });
    });
  }
  
  // Configurar los eventos de Enter
  setupEnterKeyForPasswordFields();
  
  // Re-configurar cuando se abren nuevos modales
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
        const target = mutation.target;
        if (target.classList && target.classList.contains('modal')) {
          // Si un modal cambi√≥ su visibilidad, reconfigurar
          setTimeout(setupEnterKeyForPasswordFields, 50);
        }
      }
    });
  });
  
  // Observar cambios en los modales
  document.querySelectorAll('.modal').forEach(modal => {
    observer.observe(modal, { attributes: true });
  });
});

</script>
</body>
</html>
