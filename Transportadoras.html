<!DOCTYPE html>
<html>
<head>
    <title>Dashboard Transportadoras</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos Base - Modernos, Limpios, Priorizando Móviles */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f0f2f5 0%, #e0e6ec 100%);
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Alinear al inicio verticalmente */
            min-height: 100vh;
            overflow-x: hidden;
            animation: fadeInBackground 1s ease-out;
        }

        @keyframes fadeInBackground {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .container {
            width: 95%; /* Más ancho para móvil, ajustar según sea necesario */
            max-width: 900px; /* Ancho máximo para escritorio */
            margin: 20px auto; /* Más margen vertical */
            padding: 20px; /* Más padding */
            background-color: #ffffff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            box-sizing: border-box; /* Incluir padding en ancho/alto */
        }

        /* Títulos */
        h1, h2 {
            color: #2e7d32; /* Verde oscuro */
            text-align: center;
            margin-bottom: 25px;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.05);
            font-size: 1.8em; /* Tamaño de fuente adaptable */
        }
        h1 {
            font-size: 2.2em;
            margin-bottom: 30px;
        }
        h2 {
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        /* Campos de Formulario y Entradas */
        .form-field {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }
        label {
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }
        input, select {
            padding: 12px 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s ease;
            background-color: #fcfcfc;
            width: 100%; /* Ancho completo para entradas */
            box-sizing: border-box; /* Incluir padding en el ancho */
        }
        input:focus, select:focus {
            border-color: #28a745;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.2);
            outline: none;
            background-color: #fff;
        }

        /* Botones */
        button, input[type="submit"] {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s ease;
            color: white;
            background-image: linear-gradient(135deg, #28a745 0%, #218838 100%);
            box-shadow: 0 4px 10px rgba(40, 167, 69, 0.2);
            letter-spacing: 0.5px;
            width: 100%; /* Ancho completo para botones */
            box-sizing: border-box;
        }

        button:hover, input[type="submit"]:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(40, 167, 69, 0.3);
            background-image: linear-gradient(135deg, #218838 0%, #1e7030 100%);
        }

        button:active, input[type="submit"]:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(40, 167, 69, 0.2);
        }

        /* Especificaciones de Pantalla de Inicio de Sesión */
        #login-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh; /* Altura completa para pantalla de inicio de sesión */
            position: fixed; /* Fijo para cubrir todo el viewport */
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(135deg, #e0e6ec 0%, #f0f2f5 100%); /* Fondo degradado sutil */
            z-index: 2000; /* Asegurar que esté encima */
        }

        #login-screen .login-card {
            background-color: #fff;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 400px;
            text-align: center;
            position: relative; /* Necesario para posicionamiento absoluto del icono de engranaje */
        }

        #login-screen h1 {
            color: #28a745;
            margin-bottom: 25px;
        }

        #login-screen input[type="password"] {
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        #login-screen button {
            margin-top: 20px;
        }

        #login-error {
            color: #dc3545;
            margin-top: 15px;
            font-weight: 600;
        }
        
        #disclaimer-text {
            font-size: 0.75em; /* Texto más pequeño para el aviso legal */
            color: #777;
            margin-top: 20px;
            line-height: 1.3;
            text-align: center;
        }


        /* Contenido del Dashboard */
        #dashboard-content {
            display: none; /* Oculto por defecto hasta iniciar sesión */
            padding: 10px;
        }

        .dashboard-section {
            background-color: #fdfdfd;
            padding: 15px;
            border: 1px solid #e9e9e9;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }
        .dashboard-section:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .dashboard-section h3 {
            color: #28a745;
            font-size: 1.3em;
            margin-bottom: 15px;
            border-bottom: 1px dashed #eee;
            padding-bottom: 8px;
            text-align: center;
        }

        .summary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dotted #e0e0e0;
            font-size: 0.95em;
        }
        .summary-item:last-child {
            border-bottom: none;
        }
        .summary-item strong {
            color: #333;
        }
        .summary-item span.value {
            font-weight: 600;
            color: #007bff;
        }
        .summary-item span.green-value {
            color: #28a745;
        }
        .summary-item span.red-value {
            color: #dc3545;
        }

        .global-summary {
            text-align: center;
            font-size: 1.1em;
            font-weight: 600;
            padding: 10px;
            background-color: #e6f7ed;
            border: 1px solid #28a745;
            border-radius: 8px;
            margin-top: 15px;
            color: #28a745;
        }

        /* Spinner de Carga */
        .loading-spinner {
            display: none;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #28a745;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .no-data-message {
            text-align: center;
            color: #777;
            padding: 20px;
            font-style: italic;
        }

        /* Media Queries para Adaptabilidad */
        @media (min-width: 768px) {
            h1 {
                font-size: 2.5em;
            }
            h2 {
                font-size: 1.8em;
            }
            .dashboard-sections-grid {
                display: grid;
                grid-template-columns: 1fr 1fr; /* Dos columnas en pantallas más grandes */
                gap: 20px;
            }
            button, input[type="submit"] {
                width: auto; /* Ancho automático para botones en escritorio */
                min-width: 180px;
            }
            .login-card {
                padding: 50px;
            }
        }

        /* Estilos de Modal de Alerta Genérico */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-out forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 450px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            position: relative;
            transform: translateY(0);
            animation: slideInFromTop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center; /* Centrar contenido dentro del modal */
        }

        @keyframes slideInFromTop {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-content h2 {
            color: #dc3545; /* Rojo para alertas */
            margin-bottom: 20px;
            border-bottom: none; /* Sin borde para el título del modal */
            padding-bottom: 0;
            font-size: 1.5em;
        }

        .modal-content p {
            font-size: 1.1em;
            margin-bottom: 25px;
            line-height: 1.4;
        }

        .modal-content button {
            background-image: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            width: 150px; /* Ancho específico para botones de modal */
            margin: 0 auto; /* Centrar botón */
        }
        .modal-content button:hover {
            background-image: linear-gradient(135deg, #0056b3 0%, #004085 100%);
        }
        .modal-content .close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 30px;
            color: #888;
            cursor: pointer;
        }
        .modal-content .close:hover {
            color: #333;
        }

        /* Estilos de Modal de Confirmación Genérico (añadido de versión anterior) */
        #generic_confirm_modal .modal-content {
            max-width: 450px;
            padding: 30px;
        }

        #generic_confirm_modal .modal-content button {
            width: 120px; /* Ajustar ancho del botón */
            margin: 0 10px; /* Espaciado entre botones */
            display: inline-block; /* Permitir que los botones estén lado a lado */
        }

        #generic_confirm_modal button[onclick*="genericConfirmProceed"] {
            background-image: linear-gradient(135deg, #28a745 0%, #218838 100%); /* Verde para Proceder */
        }
        #generic_confirm_modal button[onclick*="genericConfirmProceed"]:hover {
            background-image: linear-gradient(135deg, #218838 0%, #1e7030 100%);
        }

        #generic_confirm_modal button[onclick*="genericConfirmCancel"] {
            background-image: linear-gradient(135deg, #dc3545 0%, #c82333 100%); /* Rojo para Cancelar */
        }
        #generic_confirm_modal button[onclick*="genericConfirmCancel"]:hover {
            background-image: linear-gradient(135deg, #c82333 0%, #bb2d3b 100%);
        }

        #generic_confirm_modal .button-group {
            display: flex;
            justify-content: center;
            gap: 15px; /* Espaciado entre botones */
            margin-top: 20px;
        }

        /* Icono de Engranaje de Administrador */
        #admin_gear_icon {
            position: absolute; /* Cambiado a absoluto para la tarjeta de inicio de sesión */
            top: 15px;
            left: 20px; /* Posicionado a la izquierda para la pantalla de inicio de sesión */
            font-size: 2em;
            color: #2e7d32;
            cursor: pointer;
            transition: transform 0.3s ease;
            display: none; /* Oculto por defecto */
        }
        #admin_gear_icon:hover {
            transform: rotate(30deg);
        }

        /* Estilos de Modal de Gestión de Usuarios */
        #user_management_modal .user-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 20px;
            background-color: #f9f9f9;
        }
        #user_management_modal .user-item {
            display: flex;
            flex-wrap: wrap; /* Permitir envoltura en pantallas pequeñas */
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px dashed #ddd;
            margin-bottom: 5px;
            background-color: #fff;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        #user_management_modal .user-item:last-child {
            border-bottom: none;
        }
        #user_management_modal .user-info {
            flex-grow: 1;
            text-align: left;
            margin-right: 10px;
            margin-bottom: 5px; /* Espacio para elementos envueltos */
        }
        #user_management_modal .user-info strong {
            display: block; /* Nombre de usuario en nueva línea */
            color: #333;
            font-size: 1.1em;
            margin-bottom: 3px;
        }
        #user_management_modal .user-info span {
            display: block;
            font-size: 0.85em;
            color: #666;
        }
        #user_management_modal .user-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap; /* Permitir que los botones se envuelvan */
            justify-content: flex-end;
        }
        #user_management_modal .user-actions button {
            padding: 8px 12px;
            font-size: 0.85em;
            margin-top: 0; /* Anular margen de botón por defecto */
            width: auto; /* Reducir al contenido */
            box-shadow: none; /* Eliminar sombra del botón */
        }
        #user_management_modal .user-actions .kick-btn {
            background-image: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); /* Amarillo */
            color: #333;
        }
        #user_management_modal .user-actions .kick-btn:hover {
            background-image: linear-gradient(135deg, #e0a800 0%, #c28800 100%);
        }
        #user_management_modal .user-actions .block-btn {
            background-image: linear-gradient(135deg, #dc3545 0%, #c82333 100%); /* Rojo */
        }
        #user_management_modal .user-actions .block-btn:hover {
            background-image: linear-gradient(135deg, #c82333 0%, #bb2d3b 100%);
        }
        #user_management_modal .user-actions .unblock-btn {
            background-image: linear-gradient(135deg, #28a745 0%, #218838 100%); /* Verde */
        }
        #user_management_modal .user-actions .unblock-btn:hover {
            background-image: linear-gradient(135deg, #218838 0%, #1e7030 100%);
        }
        #user_management_modal .modal-error-message {
            color: #dc3545;
            margin-top: 10px;
            font-size: 0.9em;
        }

        /* Estilo para elementos de usuario bloqueados */
        #user_management_modal .user-item.blocked {
            background-color: #fbe6e6; /* Fondo rojo claro */
            border-color: #dc3545;
            opacity: 0.8;
        }

    </style>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
</head>
<body>
    <div id="login-screen">
        <div class="login-card">
            <span id="admin_gear_icon" title="Gestión de Usuarios Activos" onclick="mostrarModal('user_management_modal')">&#9881;</span>
            <h1>Dashboard Transportadoras</h1>
            <p>Por favor, ingresa la contraseña para acceder.</p>
            <div class="form-field">
                <label for="password_input">Contraseña:</label>
                <input type="password" id="password_input" placeholder="Ingresa la contraseña" autocomplete="off">
            </div>
            <button onclick="checkPassword()">Acceder al Dashboard</button>
            <p id="login-error"></p>
            <p id="disclaimer-text">Al ingresar, acepta los términos de manera automática donde el sistema tendrá acceso a su IP, y demás, que podrán ser usados únicamente para fines legales en caso de violar las políticas de uso. No se accederá a la cámara o micrófono.</p>
        </div>
    </div>

    <div class="container" id="dashboard-content">
        <h1>Resumen de Despachos por Transportadora</h1>

        <div class="form-field">
            <label for="transportadora_select">Seleccionar Transportadora:</label>
            <select id="transportadora_select" onchange="handleTransportadoraChange()">
                <option value="">Cargando transportadoras...</option>
            </select>
        </div>

        <div class="loading-spinner" id="loading_spinner"></div>
        <div id="no_data_message" class="no-data-message" style="display:none;">
            <p>No hay datos disponibles para la transportadora seleccionada o con los filtros actuales.</p>
        </div>

        <div class="dashboard-sections-grid">
            <div class="dashboard-section">
                <h3>Pedidos Despachados</h3>
                <div id="despachos_despachados_asesor">
                    <p class="no-data-message">Seleccione una transportadora para ver el resumen de despachos.</p>
                </div>
            </div>

            <div class="dashboard-section">
                <h3>Pedidos Pendientes por Despachar</h3>
                <div id="pedidos_pendientes_global">
                    <p class="global-summary">Total Paquetes Pendientes: <span id="total_paquetes_pendientes" class="red-value">0</span></p>
                    <div id="pedidos_pendientes_asesor">
                        <p class="no-data-message">Seleccione una transportadora para ver los pedidos pendientes.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Alerta Genérico -->
    <div id="generic_alert_modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="cerrarModal('generic_alert_modal')">&times;</span>
            <h2 id="generic_alert_title">Alerta</h2>
            <p id="generic_alert_message"></p>
            <button type="button" onclick="cerrarModal('generic_alert_modal')">Aceptar</button>
        </div>
    </div>

    <!-- Modal de Confirmación Genérico -->
    <div id="generic_confirm_modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="genericConfirmCancel()"></span>
            <h2 id="generic_confirm_title">Confirmar Acción</h2>
            <p id="generic_confirm_message"></p>
            <div class="button-group">
                <button type="button" onclick="genericConfirmProceed()">Sí</button>
                <button type="button" onclick="genericConfirmCancel()">No</button>
            </div>
        </div>
    </div>

    <!-- Modal de Gestión de Usuarios (NUEVO) -->
    <div id="user_management_modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="cerrarModal('user_management_modal')">&times;</span>
            <h2>Gestión de Usuarios Activos</h2>
            <p id="user_management_error" class="modal-error-message"></p>
            <div class="user-list" id="active_users_list">
                <p>Cargando usuarios activos...</p>
            </div>
            <button type="button" onclick="cerrarModal('user_management_modal')">Cerrar</button>
        </div>
    </div>

    <script>
        const LOGIN_PASSWORD = "2025"; // Contraseña para acceder al dashboard
        const SESSION_DURATION_MS = 3 * 60 * 1000; // 3 minutos en milisegundos
        const LOCKOUT_DURATION_MS = 5 * 60 * 1000; // 5 minutos en milisegundos para bloqueo por cambio de transportadora
        const ACTIVE_SESSION_THRESHOLD_MS = 5 * 60 * 1000; // 5 minutos para considerar una sesión activa en la lista

        // Configuración de Firebase (Igual que en generar_pedidos.html)
        const firebaseConfig = {
            apiKey: "AIzaSyChvezwN6DrYXdnBvGLxnjhi4I9xUaxKfU",
            authDomain: "lazapateria-c4157.firebaseapp.com",
            projectId: "lazapateria-c4157",
            storageBucket: "lazapateria-c4157.firebasestorage.app",
            measurementId: "G-HVG7615JEE"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const transportadorasCollection = db.collection('transportadoras');
        const registrosCollection = db.collection('registros');
        const globalSettingsRef = db.collection('settings').doc('global_block'); // Para obtener estado de bloqueo y tiempo de retardo
        const activeSessionsCollection = db.collection('active_sessions'); // NUEVO: Para sesiones de usuario activas
        const usersCollection = db.collection('users'); // NUEVO: Para perfiles de usuario y roles

        let dashboardListenerUnsubscribe = null; // Listener para actualizaciones en tiempo real de datos del dashboard
        let sessionCheckInterval = null; // Intervalo para expiración de sesión y verificación de bloqueo
        let activeUsersListenerUnsubscribe = null; // NUEVO: Listener para usuarios activos en el modal de administrador

        // Variables globales para almacenar el estado de bloqueo actual desde el listener de Firestore
        let isGlobalManualBlock = false;
        let isAutoBlockedPermanently = false;

        // --- Elementos de la UI ---
        const loginScreen = document.getElementById('login-screen');
        const dashboardContent = document.getElementById('dashboard-content');
        const passwordInput = document.getElementById('password_input');
        const loginError = document.getElementById('login-error');
        const transportadoraSelect = document.getElementById('transportadora_select');
        const despachosDespachadosAsesorDiv = document.getElementById('despachos_despachados_asesor');
        const totalPaquetesPendientesSpan = document.getElementById('total_paquetes_pendientes');
        const pedidosPendientesAsesorDiv = document.getElementById('pedidos_pendientes_asesor');
        const loadingSpinner = document.getElementById('loading_spinner');
        const noDataMessage = document.getElementById('no_data_message');
        const adminGearIcon = document.getElementById('admin_gear_icon'); // NUEVO
        const activeUsersListDiv = document.getElementById('active_users_list'); // NUEVO
        const userManagementErrorP = document.getElementById('user_management_error'); // NUEVO

        // --- Funciones de Modal de Alerta Genérico ---
        function showAlert(message, title = "Alerta") {
            document.getElementById('generic_alert_title').textContent = title;
            document.getElementById('generic_alert_message').textContent = message;
            document.getElementById('generic_alert_modal').style.display = 'flex';
        }

        function cerrarModal(id) {
            document.getElementById(id).style.display = 'none';
            if (id === 'user_management_modal' && activeUsersListenerUnsubscribe) {
                activeUsersListenerUnsubscribe(); // Desvincular listener cuando el modal se cierra
                activeUsersListenerUnsubscribe = null;
                console.log("Listener de gestión de usuarios desvinculado.");
            }
        }

        // --- Funciones de Modal de Confirmación Genérico ---
        let confirmCallback = null;
        let cancelCallback = null;
        let originalTransportadoraSelection = ''; // Para almacenar la transportadora antes de un posible cambio

        function showConfirm(message, onConfirm, onCancel, title = "Confirmar Acción") {
            document.getElementById('generic_confirm_title').textContent = title;
            document.getElementById('generic_confirm_message').textContent = message;
            confirmCallback = onConfirm;
            cancelCallback = onCancel;
            document.getElementById('generic_confirm_modal').style.display = 'flex';
        }

        function genericConfirmProceed() {
            if (confirmCallback) {
                confirmCallback();
            }
            cerrarModal('generic_confirm_modal');
        }

        function genericConfirmCancel() {
            if (cancelCallback) {
                cancelCallback();
            }
            cerrarModal('generic_confirm_modal');
            // Revertir la selección del menú desplegable si el usuario cancela
            transportadoraSelect.value = originalTransportadoraSelection;
        }

        /**
         * Simula la obtención de una IP pública. En un entorno real, esto provendría de un servidor.
         */
        async function getSimulatedPublicIP() {
            try {
                // Usando una API pública para obtener la IP del cliente. Esto podría ser bloqueado por CORS o políticas de seguridad
                // en algunos entornos (por ejemplo, iframes).
                const response = await fetch('https://api.ipify.org?format=json');
                if (!response.ok) {
                    throw new Error(`Error HTTP! estado: ${response.status}`);
                }
                const data = await response.json();
                console.log("IP obtenida:", data.ip);
                return data.ip;
            } catch (error) {
                console.warn("Error al obtener la IP de la API, usando marcador de posición:", error);
                // Volver a un marcador de posición o una cadena aleatoria si la API falla
                return '0.0.0.0 (Simulado)';
            }
        }

        /**
         * Cierra la sesión del usuario, borra los datos de la sesión y muestra la pantalla de inicio de sesión.
         * NO borra lockoutEndTime si está activo.
         * @param {string} message - Mensaje a mostrar en la pantalla de inicio de sesión.
         */
        async function logoutUser(message) {
            console.log("Intentando cerrar sesión del usuario...");
            const currentUserId = localStorage.getItem('user_id'); // Asumiendo que user_id se almacena durante el inicio de sesión

            if (currentUserId) {
                try {
                    // Eliminar el registro de la sesión activa de Firestore
                    const sessionRef = activeSessionsCollection.doc(currentUserId);
                    await sessionRef.delete();
                    console.log(`Sesión activa para el usuario ${currentUserId} eliminada de Firestore.`);
                } catch (error) {
                    console.error("Error al eliminar la sesión activa de Firestore:", error);
                }
            }

            localStorage.removeItem('lastLoginTime'); // Borrar marca de tiempo de la sesión
            localStorage.removeItem('currentSelectedTransportadora'); // Borrar la selección de transportadora bloqueada
            localStorage.removeItem('user_id'); // Borrar user_id al cerrar sesión
            localStorage.removeItem('datosUsuario'); // Borrar datos del usuario

            if (sessionCheckInterval) {
                clearInterval(sessionCheckInterval); // Detener verificación de sesión
                sessionCheckInterval = null;
            }
            if (dashboardListenerUnsubscribe) {
                dashboardListenerUnsubscribe(); // Desvincular listener de datos del dashboard
                dashboardListenerUnsubscribe = null;
            }

            dashboardContent.style.display = 'none';
            loginScreen.style.display = 'flex';
            loginError.textContent = message;
            passwordInput.value = ''; // Borrar campo de contraseña
            console.log("Usuario cerró sesión:", message);
            // Después de cerrar sesión, ocultar el icono de engranaje de administrador
            adminGearIcon.style.display = 'none';
        }

        /**
         * Verifica la contraseña ingresada y concede acceso al dashboard si es correcta.
         * También verifica el estado de bloqueo global de Firestore y el bloqueo interno.
         */
        async function checkPassword() {
            const dashboardLockoutEndTime = localStorage.getItem('dashboardLockoutEndTime');
            const currentTime = Date.now();

            if (dashboardLockoutEndTime && currentTime < parseInt(dashboardLockoutEndTime)) {
                // El usuario está bloqueado activamente, muestra un mensaje genérico sin tiempo
                loginError.textContent = `Su acceso ha sido bloqueado debido a una violación de las políticas de uso. Por favor, contacte al administrador para revisar su situación.`;
                passwordInput.value = '';
                return; // Evitar el inicio de sesión si está bloqueado activamente
            } else if (dashboardLockoutEndTime && currentTime >= parseInt(dashboardLockoutEndTime)) {
                // El bloqueo expiró, borrarlo
                localStorage.removeItem('dashboardLockoutEndTime');
                console.log("Bloqueo del dashboard expirado y borrado.");
            }

            if (passwordInput.value === LOGIN_PASSWORD) {
                let currentIp = await getSimulatedPublicIP();
                // Generar un ID de usuario simulado basado en la contraseña.
                // En un sistema real, este ID vendría de Firebase Authentication (auth.currentUser.uid)
                let simulatedUserId = `user_${btoa(passwordInput.value).slice(0, 10)}`; 

                let userRole = 'operador'; // Rol por defecto
                let userName = 'Operador';

                try {
                    // Intentar obtener los datos del usuario de la colección 'users' en Firestore
                    const userDocRef = usersCollection.doc(simulatedUserId);
                    const userDoc = await userDocRef.get();

                    if (userDoc.exists) {
                        const userData = userDoc.data();
                        userRole = userData.permisos || 'operador'; // Obtener el rol de Firestore, por defecto 'operador'
                        userName = userData.username || 'Usuario'; // Obtener el nombre de usuario de Firestore
                        console.log(`Rol y nombre obtenidos de Firestore para ${simulatedUserId}: Rol=${userRole}, Nombre=${userName}`);
                    } else {
                        console.warn(`No se encontró un documento de usuario en Firestore para ID: ${simulatedUserId}. Asignando rol por defecto 'operador'.`);
                        // Opcional: si el usuario no existe en 'users', podrías crear uno básico aquí,
                        // pero para la gestión de roles, es mejor que existan previamente.
                    }

                } catch (firestoreError) {
                    console.error("Error al obtener datos de usuario de Firestore:", firestoreError);
                    // En caso de error, mantener el rol y nombre por defecto.
                }

                // Almacenar datos de usuario (incluido el rol de Firestore) en localStorage
                const datosUsuario = {
                    usuario: simulatedUserId, // Usar el ID simulado como 'usuario'
                    nombreCompleto: userName,
                    permisos: userRole
                };
                localStorage.setItem('datosUsuario', JSON.stringify(datosUsuario));
                localStorage.setItem('user_id', simulatedUserId); // Almacenar user_id por separado para un fácil acceso
                console.log("checkPassword: datosUsuario guardados en localStorage:", datosUsuario); // LOG DE DEBUG

                try {
                    // Verificar si el usuario está bloqueado en active_sessions
                    const userSessionDoc = await activeSessionsCollection.doc(simulatedUserId).get();
                    if (userSessionDoc.exists && userSessionDoc.data().isBlocked) {
                        logoutUser('Su usuario ha sido bloqueado por un administrador. Contacte al soporte.');
                        return;
                    }

                    // Verificar el estado de bloqueo global directamente desde Firestore
                    const doc = await globalSettingsRef.get();
                    if (doc.exists) {
                        const settings = doc.data();
                        isGlobalManualBlock = settings.isBlocked || false; // Bloqueo manual global
                        isAutoBlockedPermanently = settings.isAutoBlockedPermanently || false; // Bloqueo automático activado

                        if (isGlobalManualBlock || isAutoBlockedPermanently) {
                            logoutUser('El sistema de pedidos está actualmente bloqueado y no se puede acceder al dashboard.');
                            return;
                        }
                    } else {
                        isGlobalManualBlock = false;
                        isAutoBlockedPermanently = false;
                    }

                    // Si no está bloqueado, crear/actualizar sesión activa
                    await activeSessionsCollection.doc(simulatedUserId).set({
                        userId: simulatedUserId,
                        username: userName,
                        lastActivity: firebase.firestore.FieldValue.serverTimestamp(), // Marca de tiempo de Firestore
                        ipAddress: currentIp, // Almacenar la IP
                        isBlocked: false // Asegurar que no esté bloqueado inicialmente
                    }, { merge: true });

                    localStorage.setItem('lastLoginTime', currentTime); // Almacenar tiempo de inicio de sesión
                    localStorage.setItem('currentSessionIP', currentIp); // Almacenar la IP para validación de sesión

                    loginScreen.style.display = 'none';
                    dashboardContent.style.display = 'block';

                    // Mostrar/ocultar el icono de engranaje de administrador según el rol
                    if (userRole === 'administrador') {
                        adminGearIcon.style.display = 'block';
                        console.log("checkPassword: Rol es ADMINISTRADOR. Tuerca DEBERÍA ser visible."); // LOG DE DEBUG
                    } else {
                        adminGearIcon.style.display = 'none';
                        console.log("checkPassword: Rol es OPERADOR. Tuerca DEBERÍA estar oculta."); // LOG DE DEBUG
                    }

                    loadTransportadorasAndDashboard();

                    // Iniciar verificación periódica de sesión y estado de bloqueo
                    if (sessionCheckInterval) {
                        clearInterval(sessionCheckInterval);
                    }
                    sessionCheckInterval = setInterval(checkSessionAndBlockStatus, 10 * 1000); // Verificar cada 10 segundos

                } catch (error) {
                    console.error("Error durante el inicio de sesión o la creación de la sesión:", error);
                    logoutUser('Error al acceder. Inténtelo de nuevo.');
                    return;
                }
            } else {
                loginError.textContent = 'Contraseña incorrecta. Inténtalo de nuevo.';
                passwordInput.value = ''; // Borrar entrada de contraseña
            }
        }

        /**
         * Verifica la expiración de la sesión, el estado de bloqueo global y el bloqueo de IP/usuario.
         * Si la sesión expiró o el sistema/usuario está bloqueado, cierra la sesión del usuario.
         */
        async function checkSessionAndBlockStatus() {
            const lastLoginTime = localStorage.getItem('lastLoginTime');
            const currentTime = Date.now();
            const dashboardLockoutEndTime = localStorage.getItem('dashboardLockoutEndTime');
            const currentUserId = localStorage.getItem('user_id');
            const currentSessionIP = localStorage.getItem('currentSessionIP');
            
            const userDatos = JSON.parse(localStorage.getItem('datosUsuario')); // Obtener datos del usuario del localStorage
            const userRole = userDatos?.permisos;

            console.log("checkSessionAndBlockStatus: Ejecutando verificación de sesión."); // LOG DE DEBUG
            console.log("checkSessionAndBlockStatus: Rol de usuario actual:", userRole); // LOG DE DEBUG

            // 1. Primero verificar el bloqueo interno del dashboard
            if (dashboardLockoutEndTime && currentTime < parseInt(dashboardLockoutEndTime)) {
                logoutUser(`Su acceso ha sido bloqueado debido a una violación de las políticas de uso. Por favor, contacte al administrador para revisar su situación.`);
                return;
            } else if (dashboardLockoutEndTime && currentTime >= parseInt(dashboardLockoutEndTime)) {
                localStorage.removeItem('dashboardLockoutEndTime');
                console.log("Bloqueo del dashboard expirado y borrado.");
            }

            // 2. Verificar la expiración de la sesión
            if (!lastLoginTime || (currentTime - parseInt(lastLoginTime) > SESSION_DURATION_MS)) {
                logoutUser('Su sesión ha expirado. Por favor, ingrese la contraseña de nuevo.');
                return;
            }

            // Si un usuario ha iniciado sesión, actualizar continuamente su lastActivity y verificar el estado específico de su sesión
            if (currentUserId) {
                try {
                    const sessionRef = activeSessionsCollection.doc(currentUserId);
                    const sessionDoc = await sessionRef.get();

                    if (!sessionDoc.exists) {
                        // Si la sesión fue eliminada por un administrador, cerrar sesión
                        logoutUser('Su sesión ha sido terminada por un administrador.');
                        return;
                    }

                    const sessionData = sessionDoc.data();
                    const fetchedIp = await getSimulatedPublicIP(); // Obtener la IP actual para comparación

                    if (sessionData.isBlocked) {
                        // Usuario bloqueado específicamente por el administrador
                        logoutUser('Su usuario ha sido bloqueado por un administrador. Contacte al soporte.');
                        return;
                    }

                    // Verificar la consistencia de la IP - solo si se almacenó una IP y si es diferente
                    if (sessionData.ipAddress && fetchedIp !== '0.0.0.0 (Simulado)' && sessionData.ipAddress !== fetchedIp) {
                        logoutUser('Su sesión ha sido detectada desde una ubicación diferente. Por favor, ingrese de nuevo.');
                        return;
                    }

                    // Actualizar la marca de tiempo de lastActivity para mantener la sesión activa en Firestore
                    await sessionRef.update({
                        lastActivity: firebase.firestore.FieldValue.serverTimestamp(),
                        ipAddress: fetchedIp // Actualizar la IP en caso de que cambie ligeramente o para un mejor seguimiento
                    });
                } catch (error) {
                    console.error("Error al verificar el estado de la sesión activa:", error);
                    // En caso de error de Firestore, considerar cerrar sesión por seguridad
                    logoutUser('Error de verificación de sesión. Por favor, ingrese de nuevo.');
                    return;
                }
            }


            // 3. Verificar el estado de bloqueo global en tiempo real desde la aplicación principal (el listener de Firebase ya actualiza las globales)
            if (isGlobalManualBlock || isAutoBlockedPermanently) {
                logoutUser('El sistema de pedidos ha sido bloqueado. No se puede acceder al dashboard.');
                return;
            }

            // Mostrar/ocultar el icono de engranaje de administrador según el rol
            if (userRole === 'administrador') {
                adminGearIcon.style.display = 'block';
                console.log("checkSessionAndBlockStatus: Rol es ADMINISTRADOR. Tuerca DEBERÍA ser visible."); // LOG DE DEBUG
            } else {
                adminGearIcon.style.display = 'none';
                console.log("checkSessionAndBlockStatus: Rol es OPERADOR. Tuerca DEBERÍA estar oculta."); // LOG DE DEBUG
            }
        }


        /**
         * Carga la lista de transportadoras en el menú desplegable y luego carga los datos del dashboard.
         */
        async function loadTransportadorasAndDashboard() {
            transportadoraSelect.innerHTML = '<option value="">Cargando transportadoras...</option>';
            try {
                const snapshot = await transportadorasCollection.orderBy('name').get();
                transportadoraSelect.innerHTML = '<option value="">Seleccione una transportadora</option>';
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const option = document.createElement('option');
                    option.value = data.name;
                    option.textContent = data.name;
                    transportadoraSelect.appendChild(option);
                });

                // Establecer la transportadora inicial desde localStorage si existe
                const storedTransportadora = localStorage.getItem('currentSelectedTransportadora');
                if (storedTransportadora && Array.from(transportadoraSelect.options).some(option => option.value === storedTransportadora)) {
                    transportadoraSelect.value = storedTransportadora;
                }
                // Almacenar la selección actual como el "original" para comparar
                originalTransportadoraSelection = transportadoraSelect.value;

                // Llamar a loadDashboardDataInternal explícitamente, no a través de onchange todavía
                loadDashboardDataInternal(); 
            } catch (error) {
                console.error("Error cargando transportadoras:", error);
                transportadoraSelect.innerHTML = '<option value="">Error cargando transportadoras</option>';
                showNoDataMessage();
            }
        }

        /**
         * Maneja el evento de cambio para el menú desplegable de selección de transportadora.
         * Implementa la lógica de advertencia y bloqueo.
         */
        function handleTransportadoraChange() {
            const newSelectedTransportadora = transportadoraSelect.value;
            const currentSelectedTransportadora = localStorage.getItem('currentSelectedTransportadora');
            const currentTime = Date.now();

            // Escenario 1: No se había seleccionado ninguna transportadora todavía, y el usuario seleccionó una
            if (!currentSelectedTransportadora && newSelectedTransportadora) {
                localStorage.setItem('currentSelectedTransportadora', newSelectedTransportadora);
                originalTransportadoraSelection = newSelectedTransportadora; // Bloquearla como la original
                loadDashboardDataInternal();
                return; // Salir después de la primera selección válida
            }
            
            // Escenario 2: El usuario intenta deseleccionar (volver a la opción vacía) o cambiar después de que una selección fue bloqueada
            // Esta es la verificación de "violación".
            if (newSelectedTransportadora === '' && currentSelectedTransportadora !== '') {
                // El usuario deseleccionó después de que una transportadora ya estaba bloqueada
                showConfirm(
                    '¡Advertencia! Al seleccionar una transportadora, solo podrá ver los datos de esa transportadora durante su sesión activa. Intentar deseleccionar la transportadora es una violación de las políticas de uso de la aplicación y resultará en un bloqueo inmediato y el reporte al administrador. ¿Desea continuar con esta acción?',
                    () => { // El usuario confirmó (Sí)
                        localStorage.setItem('dashboardLockoutEndTime', currentTime + LOCKOUT_DURATION_MS);
                        logoutUser('Su acceso ha sido bloqueado debido a una violación de las políticas de uso. Por favor, contacte al administrador para revisar su situación.');
                    },
                    () => { // El usuario canceló (No) - genericConfirmCancel ya maneja la reversión del menú desplegable
                        // No se necesita ninguna acción específica aquí, ya que genericConfirmCancel maneja la reversión de la UI.
                    },
                    'Violación de Derechos'
                );
                return; // Salir después de mostrar la confirmación
            } else if (currentSelectedTransportadora && newSelectedTransportadora !== currentSelectedTransportadora) {
                 // El usuario intentó cambiar a una transportadora diferente
                showConfirm(
                    '¡Advertencia! Al seleccionar una transportadora, solo podrá ver los datos de esa transportadora durante su sesión activa. Intentar cambiar a otra transportadora es una violación de las políticas de uso de la aplicación y resultará en un bloqueo inmediato y el reporte al administrador. ¿Desea continuar con esta acción?',
                    () => { // El usuario confirmó (Sí)
                        localStorage.setItem('dashboardLockoutEndTime', currentTime + LOCKOUT_DURATION_MS);
                        logoutUser('Su acceso ha sido bloqueado debido a una violación de las políticas de uso. Por favor, contacte al administrador para revisar su situación.');
                    },
                    () => { // El usuario canceló (No) - genericConfirmCancel ya maneja la reversión del menú desplegable
                        // No se necesita ninguna acción específica aquí, ya que genericConfirmCancel maneja la reversión de la UI.
                    },
                    'Violación de Derechos'
                );
                return; // Salir después de mostrar la confirmación
            }

            // Escenario 3: El usuario volvió a seleccionar la MISMA transportadora (no es una violación)
            if (newSelectedTransportadora === currentSelectedTransportadora) {
                loadDashboardDataInternal();
            }
            // Si llegamos aquí y no se realizó ninguna acción especial (ej. carga inicial o no se necesitaba ningún cambio al valor bloqueado actual)
            // loadDashboardDataInternal() se llamará a través de la configuración inicial o la nueva selección.
        }


        /**
         * Función interna para cargar datos del dashboard sin verificaciones de bloqueo adicionales,
         * llamada después de que se confirma la selección de la transportadora o en la carga inicial.
         */
        async function loadDashboardDataInternal() {
            showLoadingSpinner();
            noDataMessage.style.display = 'none';

            if (dashboardListenerUnsubscribe) {
                dashboardListenerUnsubscribe(); // Desvincular listener anterior
                console.log("Listener de dashboard anterior desvinculado.");
            }

            const selectedTransportadora = transportadoraSelect.value;
            console.log("Transportadora seleccionada para la carga de datos:", selectedTransportadora);

            if (!selectedTransportadora) {
                despachosDespachadosAsesorDiv.innerHTML = '<p class="no-data-message">Seleccione una transportadora para ver el resumen de despachos.</p>';
                totalPaquetesPendientesSpan.textContent = '0';
                pedidosPendientesAsesorDiv.innerHTML = '<p class="no-data-message">Seleccione una transportadora para ver los pedidos pendientes.</p>';
                hideLoadingSpinner();
                return;
            }

            // Configurar listener en tiempo real para registros filtrados por la transportadora seleccionada
            dashboardListenerUnsubscribe = registrosCollection
                .where('transportadora', '==', selectedTransportadora)
                .onSnapshot(snapshot => {
                    console.log("Registros actualizados para la transportadora seleccionada:", selectedTransportadora);
                    processDashboardData(snapshot.docs);
                    hideLoadingSpinner();
                }, error => {
                    console.error("Error al escuchar los datos del dashboard:", error);
                    despachosDespachadosAsesorDiv.innerHTML = '<p class="no-data-message">Error al cargar los datos.</p>';
                    totalPaquetesPendientesSpan.textContent = 'Error';
                    pedidosPendientesAsesorDiv.innerHTML = '<p class="no-data-message"></p>'; // Borrar esto en caso de error
                    hideLoadingSpinner();
                });
        }

        /**
         * Procesa los datos de la instantánea para agregar y mostrar los resúmenes del dashboard.
         * @param {Array<firebase.firestore.DocumentSnapshot>} docs - Array de instantáneas de documentos.
         */
        function processDashboardData(docs) {
            let despachadosPorAsesor = {};
            let pendientesPorAsesor = {}; // Nuevo: para pendientes por asesor
            let totalPaquetesDespachados = 0; // Nuevo: total para despachados
            let totalPaquetesPendientes = 0;
            const now = new Date();

            if (docs.length === 0) {
                showNoDataMessage();
                despachosDespachadosAsesorDiv.innerHTML = '<p class="no-data-message">No hay despachos para esta transportadora.</p>';
                totalPaquetesPendientesSpan.textContent = '0';
                pedidosPendientesAsesorDiv.innerHTML = '<p class="no-data-message">No hay pedidos pendientes para esta transportadora.</p>';
                return;
            }

            docs.forEach(doc => {
                const data = doc.data();
                const asesor = data.asesor || 'Desconocido';
                const numPares = parseInt(data.num_pares || 0);
                const despachado = data.despachado === true;
                const enviadoAEmpaque = data.enviadoAEmpaque === true;
                const fechaHoraCreacion = data.fecha_hora ? data.fecha_hora.toDate() : null;

                if (despachado) {
                    if (!despachadosPorAsesor[asesor]) {
                        despachadosPorAsesor[asesor] = { paquetes: 0 }; // Se eliminó el valor
                    }
                    despachadosPorAsesor[asesor].paquetes += numPares;
                    totalPaquetesDespachados += numPares; // Acumular total despachados
                } else {
                    // Verificar estado "pendiente": NO despachado Y NO enviado a empaque
                    const isPending = !despachado && !enviadoAEmpaque;
                    if (isPending) {
                        totalPaquetesPendientes += numPares;
                        if (!pendientesPorAsesor[asesor]) {
                            pendientesPorAsesor[asesor] = { paquetes: 0 };
                        }
                        pendientesPorAsesor[asesor].paquetes += numPares;
                    }
                }
            });

            renderDespachosDespachados(despachadosPorAsesor, totalPaquetesDespachados); // Pasar total despachados
            renderPedidosPendientes(pendientesPorAsesor); // Nuevo: llamar a la renderización de pendientes
            totalPaquetesPendientesSpan.textContent = totalPaquetesPendientes;

            // Si hay datos, ocultar el mensaje general de no hay datos
            if (Object.keys(despachadosPorAsesor).length > 0 || totalPaquetesPendientes > 0) {
                noDataMessage.style.display = 'none';
            } else {
                showNoDataMessage();
            }
        }

        /**
         * Renderiza la sección "Pedidos Despachados".
         * @param {Object} data - Datos agregados de elementos despachados por asesor.
         * @param {number} totalDispatchedPackages - Total de paquetes despachados para la transportadora seleccionada.
         */
        function renderDespachosDespachados(data, totalDispatchedPackages) {
            let html = `<p class="global-summary">Total Paquetes Despachados: <span class="green-value">${totalDispatchedPackages}</span></p>`; // Añadir total despachados
            const asesores = Object.keys(data).sort(); // Ordenar por nombre de asesor

            if (asesores.length === 0 && totalDispatchedPackages === 0) {
                html += '<p class="no-data-message">No hay pedidos despachados para esta transportadora.</p>';
            } else {
                asesores.forEach(asesor => {
                    html += `
                        <div class="summary-item">
                            <span><strong>Asesor:</strong> ${asesor}</span>
                            <span>Paquetes: <span class="value green-value">${data[asesor].paquetes}</span></span>
                        </div>
                    `;
                });
            }
            despachosDespachadosAsesorDiv.innerHTML = html;
        }

        /**
         * Renderiza la sección "Pedidos Pendientes por Despachar" por asesor.
         * @param {Object} data - Datos agregados de elementos pendientes por asesor.
         */
        function renderPedidosPendientes(data) {
            let html = '';
            const asesores = Object.keys(data).sort(); // Ordenar por nombre de asesor

            if (asesores.length === 0) {
                html = '<p class="no-data-message">No hay pedidos pendientes para esta transportadora.</p>';
            } else {
                asesores.forEach(asesor => {
                    html += `
                        <div class="summary-item">
                            <span><strong>Asesor:</strong> ${asesor}</span>
                            <span>Paquetes: <span class="value red-value">${data[asesor].paquetes}</span></span>
                        </div>
                    `;
                });
            }
            pedidosPendientesAsesorDiv.innerHTML = html;
        }

        function showLoadingSpinner() {
            loadingSpinner.style.display = 'block';
            despachosDespachadosAsesorDiv.innerHTML = ''; // Borrar contenido mientras carga
            totalPaquetesPendientesSpan.textContent = 'Cargando...';
            pedidosPendientesAsesorDiv.innerHTML = ''; // Borrar contenido mientras carga
            noDataMessage.style.display = 'none';
        }

        function hideLoadingSpinner() {
            loadingSpinner.style.display = 'none';
        }

        function showNoDataMessage() {
            noDataMessage.style.display = 'block';
            despachosDespachadosAsesorDiv.innerHTML = '<p class="no-data-message">No hay datos disponibles para la transportadora seleccionada.</p>';
            pedidosPendientesAsesorDiv.innerHTML = ''; // Mantener esto vacío o mostrar mensaje específico de pendientes
            totalPaquetesPendientesSpan.textContent = '0'; // Asegurar que el total sea 0
        }

        // --- Funciones de Gestión de Usuarios (NUEVO) ---
        /**
         * Carga los usuarios activos en el modal de gestión de usuarios.
         */
        async function loadActiveUsers() {
            userManagementErrorP.textContent = ''; // Borrar errores anteriores
            activeUsersListDiv.innerHTML = '<p>Cargando usuarios activos...</p>';

            if (activeUsersListenerUnsubscribe) {
                activeUsersListenerUnsubscribe(); // Desvincular listener anterior si existe
            }

            activeUsersListenerUnsubscribe = activeSessionsCollection
                .orderBy('lastActivity', 'desc')
                .onSnapshot(snapshot => {
                    activeUsersListDiv.innerHTML = ''; // Borrar lista
                    if (snapshot.empty) {
                        activeUsersListDiv.innerHTML = '<p>No hay usuarios activos en este momento.</p>';
                        return;
                    }

                    let html = '';
                    const now = Date.now();
                    snapshot.forEach(doc => {
                        const user = doc.data();
                        const userId = doc.id; // El ID del documento es el ID de usuario
                        const lastActivityDate = user.lastActivity ? user.lastActivity.toDate() : null;
                        const isRecent = lastActivityDate && (now - lastActivityDate.getTime() < ACTIVE_SESSION_THRESHOLD_MS);
                        const isBlocked = user.isBlocked || false;
                        const className = isBlocked ? 'user-item blocked' : 'user-item';

                        // Mostrar solo si hay actividad reciente o está explícitamente bloqueado
                        if (isRecent || isBlocked) {
                            html += `
                                <div class="${className}" data-user-id="${userId}">
                                    <div class="user-info">
                                        <strong>${user.username || userId}</strong>
                                        <span>ID: ${userId}</span>
                                        <span>IP: ${user.ipAddress || 'N/A'}</span>
                                        <span>Última actividad: ${lastActivityDate ? lastActivityDate.toLocaleString('es-CO') : 'N/A'}</span>
                                        ${isBlocked ? '<span>Estado: <strong style="color: red;">BLOQUEADO</strong></span>' : ''}
                                    </div>
                                    <div class="user-actions">
                                        <button class="kick-btn" onclick="kickUser('${userId}')">Sacar del Sistema</button>
                                        ${isBlocked ?
                                            `<button class="unblock-btn" onclick="toggleUserBlock('${userId}', false)">Desbloquear</button>` :
                                            `<button class="block-btn" onclick="toggleUserBlock('${userId}', true)">Bloquear</button>`
                                        }
                                    </div>
                                </div>
                            `;
                        }
                    });
                    activeUsersListDiv.innerHTML = html;
                    if (!html) {
                        activeUsersListDiv.innerHTML = '<p>No hay usuarios activos en este momento.</p>';
                    }
                }, error => {
                    console.error("Error al obtener usuarios activos:", error);
                    userManagementErrorP.textContent = 'Error al cargar la lista de usuarios activos.';
                    activeUsersListDiv.innerHTML = '<p>Error al cargar usuarios.</p>';
                });
        }

        /**
         * Expulsa a un usuario eliminando su sesión activa.
         * @param {string} userId - El ID del usuario a expulsar.
         */
        function kickUser(userId) {
            showConfirm(`¿Está seguro de que desea sacar a ${userId} del sistema? Esto terminará su sesión.`, async () => {
                try {
                    await activeSessionsCollection.doc(userId).delete();
                    console.log(`Usuario ${userId} expulsado.`);
                    userManagementErrorP.textContent = `Usuario ${userId} sacado del sistema.`;
                    setTimeout(() => userManagementErrorP.textContent = '', 3000);
                } catch (error) {
                    console.error("Error al expulsar al usuario:", error);
                    userManagementErrorP.textContent = `Error al sacar a ${userId} del sistema.`;
                }
            });
        }

        /**
         * Bloquea o desbloquea a un usuario.
         * @param {string} userId - El ID del usuario a bloquear/desbloquear.
         * @param {boolean} blockStatus - true para bloquear, false para desbloquear.
         */
        function toggleUserBlock(userId, blockStatus) {
            const actionText = blockStatus ? 'bloquear' : 'desbloquear';
            showConfirm(`¿Está seguro de que desea ${actionText} a ${userId}?`, async () => {
                try {
                    await activeSessionsCollection.doc(userId).update({ isBlocked: blockStatus });
                    console.log(`Estado de bloqueo del usuario ${userId} establecido en ${blockStatus}.`);
                    userManagementErrorP.textContent = `Usuario ${userId} ${blockStatus ? 'bloqueado' : 'desbloqueado'} correctamente.`;
                    setTimeout(() => userManagementErrorP.textContent = '', 3000);
                } catch (error) {
                    console.error(`Error al ${actionText} usuario:`, error);
                    userManagementErrorP.textContent = `Error al ${actionText} a ${userId}.`;
                }
            });
        }


        // --- Event Listeners y Carga Inicial ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded: Página cargada."); // LOG DE DEBUG

            passwordInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    checkPassword();
                }
            });

            // Hacer visible el icono de engranaje de administrador si el usuario es administrador (después de la verificación inicial)
            const storedDatosUsuario = JSON.parse(localStorage.getItem('datosUsuario'));
            console.log("DOMContentLoaded: datosUsuario del localStorage:", storedDatosUsuario); // LOG DE DEBUG
            
            if (storedDatosUsuario && storedDatosUsuario.permisos && storedDatosUsuario.permisos.toLowerCase() === 'administrador') {
                adminGearIcon.style.display = 'block';
                console.log("DOMContentLoaded: Rol detectado ADMINISTRADOR. Tuerca DEBERÍA ser visible."); // LOG DE DEBUG
            } else {
                adminGearIcon.style.display = 'none';
                console.log("DOMContentLoaded: Rol detectado NO ADMINISTRADOR. Tuerca DEBERÍA estar oculta."); // LOG DE DEBUG
            }
            
            // Listener para la configuración global inmediatamente para detectar cambios de bloqueo
            globalSettingsRef.onSnapshot(doc => {
                if (doc.exists) {
                    const settings = doc.data();
                    isGlobalManualBlock = settings.isBlocked || false;
                    isAutoBlockedPermanently = settings.isAutoBlockedPermanently || false;
                    console.log("globalSettingsRef.onSnapshot: Estado de bloqueo global actualizado:", isGlobalManualBlock, isAutoBlockedPermanently); // LOG DE DEBUG
                    checkSessionAndBlockStatus(); // Verificar inmediatamente si el usuario debe cerrar sesión debido al bloqueo
                } else {
                    isGlobalManualBlock = false;
                    isAutoBlockedPermanently = false;
                    console.log("globalSettingsRef.onSnapshot: Documento de configuración global no existe, asumiendo desbloqueado."); // LOG DE DEBUG
                    checkSessionAndBlockStatus();
                }
            }, error => {
                console.error("Error al escuchar cambios en global_block:", error);
                isGlobalManualBlock = false;
                isAutoBlockedPermanently = false;
                checkSessionAndBlockStatus();
            });

            // En la carga inicial, verificar si existe una sesión
            const lastLoginTime = localStorage.getItem('lastLoginTime');
            const dashboardLockoutEndTime = localStorage.getItem('dashboardLockoutEndTime');
            const currentTime = Date.now();

            if (dashboardLockoutEndTime && currentTime < parseInt(dashboardLockoutEndTime)) {
                console.log("DOMContentLoaded: Bloqueo de dashboard activo."); // LOG DE DEBUG
                logoutUser(`Su acceso ha sido bloqueado debido a una violación de las políticas de uso. Por favor, contacte al administrador para revisar su situación.`);
            } else if (lastLoginTime && (currentTime - parseInt(lastLoginTime)) < SESSION_DURATION_MS) {
                console.log("DOMContentLoaded: Sesión válida detectada."); // LOG DE DEBUG
                dashboardContent.style.display = 'block';
                loginScreen.style.display = 'none';
                loadTransportadorasAndDashboard();
                if (!sessionCheckInterval) {
                    sessionCheckInterval = setInterval(checkSessionAndBlockStatus, 10 * 1000);
                }
                // Mostrar/ocultar el icono de engranaje de administrador en la carga según el rol ya determinado desde localStorage
                const userDatos = JSON.parse(localStorage.getItem('datosUsuario'));
                if (userDatos && userDatos.permisos && userDatos.permisos.toLowerCase() === 'administrador') {
                    adminGearIcon.style.display = 'block';
                    console.log("DOMContentLoaded (después de sesión válida): Rol ADMINISTRADOR. Tuerca DEBERÍA ser visible."); // LOG DE DEBUG
                } else {
                    adminGearIcon.style.display = 'none';
                    console.log("DOMContentLoaded (después de sesión válida): Rol NO ADMINISTRADOR. Tuerca DEBERÍA estar oculta."); // LOG DE DEBUG
                }

            } else {
                console.log("DOMContentLoaded: No hay sesión válida, mostrando pantalla de inicio de sesión."); // LOG DE DEBUG
                logoutUser('Por favor, ingrese su contraseña.');
            }
        });

        // Listener de eventos para abrir el modal de gestión de usuarios
        adminGearIcon.addEventListener('click', () => {
            console.log("adminGearIcon clicked: Abriendo modal de gestión de usuarios."); // LOG DE DEBUG
            mostrarModal('user_management_modal');
            loadActiveUsers(); // Cargar usuarios cuando se abre el modal
        });
    </script>
</body>
</html>
